// 
// Generated by @himenon/openapi-typescript-code-generator v0.12.2
// 
// OpenApi : 3.0.0
// 
// 


export namespace Schemas {
    /** API error response. */
    export interface APIErrorResponse {
        /** A list of errors. */
        errors: string[];
    }
    /** Attributes used to create an API Key. */
    export interface APIKeyCreateAttributes {
        /** Name of the API key. */
        name: string;
    }
    /** Object used to create an API key. */
    export interface APIKeyCreateData {
        attributes: Schemas.APIKeyCreateAttributes;
        type: Schemas.APIKeysType;
    }
    /** Request used to create an API key. */
    export interface APIKeyCreateRequest {
        data: Schemas.APIKeyCreateData;
    }
    /** Resources related to the API key. */
    export interface APIKeyRelationships {
        created_by?: Schemas.RelationshipToUser;
        modified_by?: Schemas.RelationshipToUser;
    }
    /** Response for retrieving an API key. */
    export interface APIKeyResponse {
        data?: Schemas.FullAPIKey;
        /** Array of objects related to the API key. */
        included?: Schemas.APIKeyResponseIncludedItem[];
    }
    export type APIKeyResponseIncludedItem = Schemas.User;
    /** Attributes used to update an API Key. */
    export interface APIKeyUpdateAttributes {
        /** Name of the API key. */
        name: string;
    }
    /** Object used to update an API key. */
    export interface APIKeyUpdateData {
        attributes: Schemas.APIKeyUpdateAttributes;
        /** ID of the API key. */
        id: string;
        type: Schemas.APIKeysType;
    }
    /** Request used to update an API key. */
    export interface APIKeyUpdateRequest {
        data: Schemas.APIKeyUpdateData;
    }
    /** Response for a list of API keys. */
    export interface APIKeysResponse {
        /** Array of API keys. */
        data?: Schemas.PartialAPIKey[];
        /** Array of objects related to the API key. */
        included?: Schemas.APIKeyResponseIncludedItem[];
    }
    /** Sorting options */
    export type APIKeysSort = "created_at" | "-created_at" | "last4" | "-last4" | "modified_at" | "-modified_at" | "name" | "-name";
    /** API Keys resource type. */
    export type APIKeysType = "api_keys";
    /** Attributes used to create an application Key. */
    export interface ApplicationKeyCreateAttributes {
        /** Name of the application key. */
        name: string;
        /** Array of scopes to grant the application key. This feature is in private beta, please contact Datadog support to enable scopes for your application keys. */
        scopes?: string[] | null;
    }
    /** Object used to create an application key. */
    export interface ApplicationKeyCreateData {
        attributes: Schemas.ApplicationKeyCreateAttributes;
        type: Schemas.ApplicationKeysType;
    }
    /** Request used to create an application key. */
    export interface ApplicationKeyCreateRequest {
        data: Schemas.ApplicationKeyCreateData;
    }
    /** Resources related to the application key. */
    export interface ApplicationKeyRelationships {
        owned_by?: Schemas.RelationshipToUser;
    }
    /** Response for retrieving an application key. */
    export interface ApplicationKeyResponse {
        data?: Schemas.FullApplicationKey;
        /** Array of objects related to the application key. */
        included?: Schemas.ApplicationKeyResponseIncludedItem[];
    }
    export type ApplicationKeyResponseIncludedItem = Schemas.User | Schemas.Role;
    /** Attributes used to update an application Key. */
    export interface ApplicationKeyUpdateAttributes {
        /** Name of the application key. */
        name?: string;
        /** Array of scopes to grant the application key. This feature is in private beta, please contact Datadog support to enable scopes for your application keys. */
        scopes?: string[] | null;
    }
    /** Object used to update an application key. */
    export interface ApplicationKeyUpdateData {
        attributes: Schemas.ApplicationKeyUpdateAttributes;
        /** ID of the application key. */
        id: string;
        type: Schemas.ApplicationKeysType;
    }
    /** Request used to update an application key. */
    export interface ApplicationKeyUpdateRequest {
        data: Schemas.ApplicationKeyUpdateData;
    }
    /** Sorting options */
    export type ApplicationKeysSort = "created_at" | "-created_at" | "last4" | "-last4" | "name" | "-name";
    /** Application Keys resource type. */
    export type ApplicationKeysType = "application_keys";
    /** The AuthN Mapping object returned by API. */
    export interface AuthNMapping {
        attributes?: Schemas.AuthNMappingAttributes;
        /** ID of the AuthN Mapping. */
        id: string;
        /** Included data in the AuthN Mapping response. */
        included?: Schemas.AuthNMappingIncluded[];
        relationships?: Schemas.AuthNMappingRelationships;
        type: Schemas.AuthNMappingsType;
    }
    /** Attributes of AuthN Mapping. */
    export interface AuthNMappingAttributes {
        /** Key portion of a key/value pair of the attribute sent from the Identity Provider. */
        attribute_key?: string;
        /** Value portion of a key/value pair of the attribute sent from the Identity Provider. */
        attribute_value?: string;
        /** Creation time of the AuthN Mapping. */
        created_at?: string;
        /** Time of last AuthN Mapping modification. */
        modified_at?: string;
        /** The ID of the SAML assertion attribute. */
        saml_assertion_attribute_id?: number;
    }
    /** Key/Value pair of attributes used for create request. */
    export interface AuthNMappingCreateAttributes {
        /** Key portion of a key/value pair of the attribute sent from the Identity Provider. */
        attribute_key?: string;
        /** Value portion of a key/value pair of the attribute sent from the Identity Provider. */
        attribute_value?: string;
    }
    /** Data for creating an AuthN Mapping. */
    export interface AuthNMappingCreateData {
        attributes?: Schemas.AuthNMappingCreateAttributes;
        relationships?: Schemas.AuthNMappingCreateRelationships;
        type: Schemas.AuthNMappingsType;
    }
    /** Relationship of AuthN Mapping create object to Role. */
    export interface AuthNMappingCreateRelationships {
        role?: Schemas.RelationshipToRole;
    }
    /** Request for creating an AuthN Mapping. */
    export interface AuthNMappingCreateRequest {
        data: Schemas.AuthNMappingCreateData;
    }
    export type AuthNMappingIncluded = Schemas.SAMLAssertionAttribute | Schemas.Role;
    /** All relationships associated with AuthN Mapping. */
    export interface AuthNMappingRelationships {
        role?: Schemas.RelationshipToRole;
        saml_assertion_attribute?: Schemas.RelationshipToSAMLAssertionAttribute;
    }
    /** AuthN Mapping response from the API. */
    export interface AuthNMappingResponse {
        data?: Schemas.AuthNMapping;
    }
    /** Key/Value pair of attributes used for update request. */
    export interface AuthNMappingUpdateAttributes {
        /** Key portion of a key/value pair of the attribute sent from the Identity Provider. */
        attribute_key?: string;
        /** Value portion of a key/value pair of the attribute sent from the Identity Provider. */
        attribute_value?: string;
    }
    /** Data for updating an AuthN Mapping. */
    export interface AuthNMappingUpdateData {
        attributes?: Schemas.AuthNMappingUpdateAttributes;
        /** ID of the AuthN Mapping. */
        id: string;
        relationships?: Schemas.AuthNMappingUpdateRelationships;
        type: Schemas.AuthNMappingsType;
    }
    /** Relationship of AuthN Mapping update object to Role. */
    export interface AuthNMappingUpdateRelationships {
        role?: Schemas.RelationshipToRole;
    }
    /** Request to update an AuthN Mapping. */
    export interface AuthNMappingUpdateRequest {
        data: Schemas.AuthNMappingUpdateData;
    }
    /** Array of AuthN Mappings response. */
    export interface AuthNMappingsResponse {
        /** Array of returned AuthN Mappings. */
        data?: Schemas.AuthNMapping[];
        meta?: Schemas.ResponseMetaAttributes;
    }
    /** Sorting options for AuthN Mappings. */
    export type AuthNMappingsSort = "created_at" | "-created_at" | "role_id" | "-role_id" | "saml_assertion_attribute_id" | "-saml_assertion_attribute_id" | "role.name" | "-role.name" | "saml_assertion_attribute.attribute_key" | "-saml_assertion_attribute.attribute_key" | "saml_assertion_attribute.attribute_value" | "-saml_assertion_attribute.attribute_value";
    /** AuthN Mappings resource type. */
    export type AuthNMappingsType = "authn_mappings";
    /** A Cloud Workload Security Agent rule returned by the API. */
    export interface CloudWorkloadSecurityAgentRuleAttributes {
        /** The category of the Agent rule. */
        category?: string;
        /** When the Agent rule was created, timestamp in milliseconds. */
        creationDate?: number;
        creator?: Schemas.CloudWorkloadSecurityAgentRuleCreatorAttributes;
        /** Whether the rule is included by default. */
        defaultRule?: boolean;
        /** The description of the Agent rule. */
        description?: string;
        /** Whether the Agent rule is enabled. */
        enabled?: boolean;
        /** The SECL expression of the Agent rule. */
        expression?: string;
        /** The name of the Agent rule. */
        name?: string;
        /** When the Agent rule was last updated, timestamp in milliseconds. */
        updatedAt?: number;
        updater?: Schemas.CloudWorkloadSecurityAgentRuleUpdaterAttributes;
        /** The version of the Agent rule. */
        version?: number;
    }
    /** Create a new Cloud Workload Security Agent rule. */
    export interface CloudWorkloadSecurityAgentRuleCreateAttributes {
        /** The description of the Agent rule. */
        description?: string;
        /** Whether the Agent rule is enabled. */
        enabled?: boolean;
        /** The SECL expression of the Agent rule. */
        expression: string;
        /** The name of the Agent rule. */
        name: string;
    }
    /** Object for a single Agent rule. */
    export interface CloudWorkloadSecurityAgentRuleCreateData {
        attributes: Schemas.CloudWorkloadSecurityAgentRuleCreateAttributes;
        type: Schemas.CloudWorkloadSecurityAgentRuleType;
    }
    /** Request object that includes the Agent rule to create. */
    export interface CloudWorkloadSecurityAgentRuleCreateRequest {
        data: Schemas.CloudWorkloadSecurityAgentRuleCreateData;
    }
    /** The attributes of the user who created the Agent rule. */
    export interface CloudWorkloadSecurityAgentRuleCreatorAttributes {
        /** The handle of the user. */
        handle?: string;
        /** The name of the user. */
        name?: string;
    }
    /** Object for a single Agent rule. */
    export interface CloudWorkloadSecurityAgentRuleData {
        attributes?: Schemas.CloudWorkloadSecurityAgentRuleAttributes;
        /** The ID of the Agent rule. */
        id?: string;
        type?: Schemas.CloudWorkloadSecurityAgentRuleType;
    }
    /** Response object that includes an Agent rule. */
    export interface CloudWorkloadSecurityAgentRuleResponse {
        data?: Schemas.CloudWorkloadSecurityAgentRuleData;
    }
    /** The type of the resource. The value should always be `agent_rule`. */
    export type CloudWorkloadSecurityAgentRuleType = "agent_rule";
    /** Update an existing Cloud Workload Security Agent rule. */
    export interface CloudWorkloadSecurityAgentRuleUpdateAttributes {
        /** The description of the Agent rule. */
        description?: string;
        /** Whether the Agent rule is enabled. */
        enabled?: boolean;
        /** The SECL expression of the Agent rule. */
        expression?: string;
    }
    /** Object for a single Agent rule. */
    export interface CloudWorkloadSecurityAgentRuleUpdateData {
        attributes: Schemas.CloudWorkloadSecurityAgentRuleUpdateAttributes;
        type: Schemas.CloudWorkloadSecurityAgentRuleType;
    }
    /** Request object that includes the Agent rule with the attributes to update. */
    export interface CloudWorkloadSecurityAgentRuleUpdateRequest {
        data: Schemas.CloudWorkloadSecurityAgentRuleUpdateData;
    }
    /** The attributes of the user who last updated the Agent rule. */
    export interface CloudWorkloadSecurityAgentRuleUpdaterAttributes {
        /** The handle of the user. */
        handle?: string;
        /** The name of the user. */
        name?: string;
    }
    /** Response object that includes a list of Agent rule. */
    export interface CloudWorkloadSecurityAgentRulesListResponse {
        /** A list of Agent rules objects. */
        data?: Schemas.CloudWorkloadSecurityAgentRuleData[];
    }
    /** HTTP header used to compress the media-type. */
    export type ContentEncoding = "gzip" | "deflate";
    /** Creator of the object. */
    export interface Creator {
        /** Email of the creator. */
        email?: string;
        /** Handle of the creator. */
        handle?: string;
        /** Name of the creator. */
        name?: string;
    }
    /** Request containing a list of dashboards to add. */
    export interface DashboardListAddItemsRequest {
        /** List of dashboards to add the dashboard list. */
        dashboards?: Schemas.DashboardListItemRequest[];
    }
    /** Response containing a list of added dashboards. */
    export interface DashboardListAddItemsResponse {
        /** List of dashboards added to the dashboard list. */
        added_dashboards_to_list?: Schemas.DashboardListItemResponse[];
    }
    /** Request containing a list of dashboards to delete. */
    export interface DashboardListDeleteItemsRequest {
        /** List of dashboards to delete from the dashboard list. */
        dashboards?: Schemas.DashboardListItemRequest[];
    }
    /** Response containing a list of deleted dashboards. */
    export interface DashboardListDeleteItemsResponse {
        /** List of dashboards deleted from the dashboard list. */
        deleted_dashboards_from_list?: Schemas.DashboardListItemResponse[];
    }
    /** A dashboard within a list. */
    export interface DashboardListItem {
        author?: Schemas.Creator;
        /** Date of creation of the dashboard. */
        created?: string;
        /** URL to the icon of the dashboard. */
        icon?: string;
        /** ID of the dashboard. */
        id: string;
        /** Whether or not the dashboard is in the favorites. */
        is_favorite?: boolean;
        /** Whether or not the dashboard is read only. */
        is_read_only?: boolean;
        /** Whether the dashboard is publicly shared or not. */
        is_shared?: boolean;
        /** Date of last edition of the dashboard. */
        modified?: string;
        /** Popularity of the dashboard. */
        popularity?: number;
        /** Title of the dashboard. */
        title?: string;
        type: Schemas.DashboardType;
        /** URL path to the dashboard. */
        url?: string;
    }
    /** A dashboard within a list. */
    export interface DashboardListItemRequest {
        /** ID of the dashboard. */
        id: string;
        type: Schemas.DashboardType;
    }
    /** A dashboard within a list. */
    export interface DashboardListItemResponse {
        /** ID of the dashboard. */
        id: string;
        type: Schemas.DashboardType;
    }
    /** Dashboards within a list. */
    export interface DashboardListItems {
        /** List of dashboards in the dashboard list. */
        dashboards: Schemas.DashboardListItem[];
        /** Number of dashboards in the dashboard list. */
        total?: number;
    }
    /** Request containing the list of dashboards to update to. */
    export interface DashboardListUpdateItemsRequest {
        /** List of dashboards to update the dashboard list to. */
        dashboards?: Schemas.DashboardListItemRequest[];
    }
    /** Response containing a list of updated dashboards. */
    export interface DashboardListUpdateItemsResponse {
        /** List of dashboards in the dashboard list. */
        dashboards?: Schemas.DashboardListItemResponse[];
    }
    /** The type of the dashboard. */
    export type DashboardType = "custom_timeboard" | "custom_screenboard" | "integration_screenboard" | "integration_timeboard" | "host_timeboard";
    /** Datadog API key. */
    export interface FullAPIKey {
        attributes?: Schemas.FullAPIKeyAttributes;
        /** ID of the API key. */
        id?: string;
        relationships?: Schemas.APIKeyRelationships;
        type?: Schemas.APIKeysType;
    }
    /** Attributes of a full API key. */
    export interface FullAPIKeyAttributes {
        /** Creation date of the API key. */
        created_at?: string;
        /** The API key. */
        key?: string;
        /** The last four characters of the API key. */
        last4?: string;
        /** Date the API key was last modified. */
        modified_at?: string;
        /** Name of the API key. */
        name?: string;
    }
    /** Datadog application key. */
    export interface FullApplicationKey {
        attributes?: Schemas.FullApplicationKeyAttributes;
        /** ID of the application key. */
        id?: string;
        relationships?: Schemas.ApplicationKeyRelationships;
        type?: Schemas.ApplicationKeysType;
    }
    /** Attributes of a full application key. */
    export interface FullApplicationKeyAttributes {
        /** Creation date of the application key. */
        created_at?: string;
        /** The application key. */
        key?: string;
        /** The last four characters of the application key. */
        last4?: string;
        /** Name of the application key. */
        name?: string;
        /** Array of scopes to grant the application key. This feature is in private beta, please contact Datadog support to enable scopes for your application keys. */
        scopes?: string[] | null;
    }
    /** Structured log message. */
    export type HTTPLog = Schemas.HTTPLogItem[];
    /** List of errors. */
    export interface HTTPLogError {
        /** Error message. */
        detail?: string;
        /** Error code. */
        status?: string;
        /** Error title. */
        title?: string;
    }
    /** Invalid query performed. */
    export interface HTTPLogErrors {
        /** Structured errors. */
        errors?: Schemas.HTTPLogError[];
    }
    /** Logs that are sent over HTTP. */
    export interface HTTPLogItem {
        /**
         * The integration name associated with your log: the technology from which the log originated.
         * When it matches an integration name, Datadog automatically installs the corresponding parsers and facets.
         * See [reserved attributes](https://docs.datadoghq.com/logs/log_collection/#reserved-attributes).
         */
        ddsource?: string;
        /** Tags associated with your logs. */
        ddtags?: string;
        /** The name of the originating host of the log. */
        hostname?: string;
        /**
         * The message [reserved attribute](https://docs.datadoghq.com/logs/log_collection/#reserved-attributes)
         * of your log. By default, Datadog ingests the value of the message attribute as the body of the log entry.
         * That value is then highlighted and displayed in the Logstream, where it is indexed for full text search.
         */
        message?: string;
        /**
         * The name of the application or service generating the log events.
         * It is used to switch from Logs to APM, so make sure you define the same value when you use both products.
         * See [reserved attributes](https://docs.datadoghq.com/logs/log_collection/#reserved-attributes).
         */
        service?: string;
    }
    /** The incident's attributes for a create request. */
    export interface IncidentCreateAttributes {
        /** A flag indicating whether the incident caused customer impact. */
        customer_impacted: boolean;
        /** A condensed view of the user-defined fields for which to create initial selections. */
        fields?: {
            [key: string]: Schemas.IncidentFieldAttributes;
        };
        /** An array of initial timeline cells to be placed at the beginning of the incident timeline. */
        initial_cells?: Schemas.IncidentTimelineCellCreateAttributes[];
        /** Notification handles that will be notified of the incident at creation. */
        notification_handles?: Schemas.IncidentNotificationHandle[];
        /** The title of the incident, which summarizes what happened. */
        title: string;
    }
    /** Incident data for a create request. */
    export interface IncidentCreateData {
        attributes: Schemas.IncidentCreateAttributes;
        relationships?: Schemas.IncidentCreateRelationships;
        type: Schemas.IncidentType;
    }
    /** The relationships the incident will have with other resources once created. */
    export interface IncidentCreateRelationships {
        commander_user: Schemas.NullableRelationshipToUser;
    }
    /** Create request for an incident. */
    export interface IncidentCreateRequest {
        data: Schemas.IncidentCreateData;
    }
    export type IncidentFieldAttributes = Schemas.IncidentFieldAttributesSingleValue | Schemas.IncidentFieldAttributesMultipleValue;
    /** A field with potentially multiple values selected. */
    export interface IncidentFieldAttributesMultipleValue {
        type?: Schemas.IncidentFieldAttributesValueType;
        /** The multiple values selected for this field. */
        value?: string[] | null;
    }
    /** A field with a single value selected. */
    export interface IncidentFieldAttributesSingleValue {
        type?: Schemas.IncidentFieldAttributesSingleValueType;
        /** The single value selected for this field. */
        value?: string | null;
    }
    /** Type of the single value field definitions. */
    export type IncidentFieldAttributesSingleValueType = "dropdown" | "textbox";
    /** Type of the multiple value field definitions. */
    export type IncidentFieldAttributesValueType = "multiselect" | "textarray" | "metrictag" | "autocomplete";
    /** Integration metadata resource type. */
    export type IncidentIntegrationMetadataType = "incident_integrations";
    /** A notification handle that will be notified at incident creation. */
    export interface IncidentNotificationHandle {
        /** The name of the notified handle. */
        display_name?: string;
        /** The email address used for the notification. */
        handle?: string;
    }
    /** Incident postmortem resource type. */
    export type IncidentPostmortemType = "incident_postmortems";
    /** Object related to an incident. */
    export type IncidentRelatedObject = "users";
    /** Response with an incident. */
    export interface IncidentResponse {
        data: Schemas.IncidentResponseData;
        /** Included related resources that the user requested. */
        included?: Schemas.IncidentResponseIncludedItem[];
    }
    /** The incident's attributes from a response. */
    export interface IncidentResponseAttributes {
        /** Timestamp when the incident was created. */
        created?: string;
        /**
         * Length of the incident's customer impact in seconds.
         * Equals the difference between `customer_impact_start` and `customer_impact_end`.
         */
        customer_impact_duration?: number;
        /** Timestamp when customers were no longer impacted by the incident. */
        customer_impact_end?: string | null;
        /** A summary of the impact customers experienced during the incident. */
        customer_impact_scope?: string | null;
        /** Timestamp when customers began being impacted by the incident. */
        customer_impact_start?: string | null;
        /** A flag indicating whether the incident caused customer impact. */
        customer_impacted?: boolean;
        /** Timestamp when the incident was detected. */
        detected?: string | null;
        /** A condensed view of the user-defined fields attached to incidents. */
        fields?: {
            [key: string]: Schemas.IncidentFieldAttributes;
        };
        /** Timestamp when the incident was last modified. */
        modified?: string;
        /** Notification handles that will be notified of the incident during update. */
        notification_handles?: Schemas.IncidentNotificationHandle[] | null;
        /** The UUID of the postmortem object attached to the incident. */
        postmortem_id?: string;
        /** The monotonically increasing integer ID for the incident. */
        public_id?: number;
        /** Timestamp when the incident's state was set to resolved. */
        resolved?: string | null;
        /**
         * The amount of time in seconds to detect the incident.
         * Equals the difference between `customer_impact_start` and `detected`.
         */
        time_to_detect?: number;
        /** The amount of time in seconds to call incident after detection. Equals the difference of `detected` and `created`. */
        time_to_internal_response?: number;
        /** The amount of time in seconds to resolve customer impact after detecting the issue. Equals the difference between `customer_impact_end` and `detected`. */
        time_to_repair?: number;
        /** The amount of time in seconds to resolve the incident after it was created. Equals the difference between `created` and `resolved`. */
        time_to_resolve?: number;
        /** The title of the incident, which summarizes what happened. */
        title: string;
    }
    /** Incident data from a response. */
    export interface IncidentResponseData {
        attributes?: Schemas.IncidentResponseAttributes;
        /** The incident's ID. */
        id: string;
        relationships?: Schemas.IncidentResponseRelationships;
        type: Schemas.IncidentType;
    }
    export type IncidentResponseIncludedItem = Schemas.User;
    /** The metadata object containing pagination metadata. */
    export interface IncidentResponseMeta {
        pagination?: Schemas.IncidentResponseMetaPagination;
    }
    /** Pagination properties. */
    export interface IncidentResponseMetaPagination {
        /** The index of the first element in the next page of results. Equal to page size added to the current offset. */
        next_offset?: number;
        /** The index of the first element in the results. */
        offset?: number;
        /** Maximum size of pages to return. */
        size?: number;
    }
    /** The incident's relationships from a response. */
    export interface IncidentResponseRelationships {
        commander_user?: Schemas.NullableRelationshipToUser;
        created_by_user?: Schemas.RelationshipToUser;
        integrations?: Schemas.RelationshipToIncidentIntegrationMetadatas;
        last_modified_by_user?: Schemas.RelationshipToUser;
        postmortem?: Schemas.RelationshipToIncidentPostmortem;
    }
    /** The incident service's attributes for a create request. */
    export interface IncidentServiceCreateAttributes {
        /** Name of the incident service. */
        name: string;
    }
    /** Incident Service payload for create requests. */
    export interface IncidentServiceCreateData {
        attributes?: Schemas.IncidentServiceCreateAttributes;
        relationships?: Schemas.IncidentServiceRelationships;
        type: Schemas.IncidentServiceType;
    }
    /** Create request with an incident service payload. */
    export interface IncidentServiceCreateRequest {
        data: Schemas.IncidentServiceCreateData;
    }
    export type IncidentServiceIncludedItems = Schemas.User;
    /** The incident service's relationships. */
    export interface IncidentServiceRelationships {
        created_by?: Schemas.RelationshipToUser;
        last_modified_by?: Schemas.RelationshipToUser;
    }
    /** Response with an incident service payload. */
    export interface IncidentServiceResponse {
        data: Schemas.IncidentServiceResponseData;
        /** Included objects from relationships. */
        included?: Schemas.IncidentServiceIncludedItems[];
    }
    /** The incident service's attributes from a response. */
    export interface IncidentServiceResponseAttributes {
        /** Timestamp of when the incident service was created. */
        created?: string;
        /** Timestamp of when the incident service was modified. */
        modified?: string;
        /** Name of the incident service. */
        name?: string;
    }
    /** Incident Service data from responses. */
    export interface IncidentServiceResponseData {
        attributes?: Schemas.IncidentServiceResponseAttributes;
        /** The incident service's ID. */
        id: string;
        relationships?: Schemas.IncidentServiceRelationships;
        type: Schemas.IncidentServiceType;
    }
    /** Incident service resource type. */
    export type IncidentServiceType = "services";
    /** The incident service's attributes for an update request. */
    export interface IncidentServiceUpdateAttributes {
        /** Name of the incident service. */
        name: string;
    }
    /** Incident Service payload for update requests. */
    export interface IncidentServiceUpdateData {
        attributes?: Schemas.IncidentServiceUpdateAttributes;
        /** The incident service's ID. */
        id?: string;
        relationships?: Schemas.IncidentServiceRelationships;
        type: Schemas.IncidentServiceType;
    }
    /** Update request with an incident service payload. */
    export interface IncidentServiceUpdateRequest {
        data: Schemas.IncidentServiceUpdateData;
    }
    /** Response with a list of incident service payloads. */
    export interface IncidentServicesResponse {
        /** An array of incident services. */
        data: Schemas.IncidentServiceResponseData[];
        /** Included related resources which the user requested. */
        included?: Schemas.IncidentServiceIncludedItems[];
        meta?: Schemas.IncidentResponseMeta;
    }
    /** The incident team's attributes for a create request. */
    export interface IncidentTeamCreateAttributes {
        /** Name of the incident team. */
        name: string;
    }
    /** Incident Team data for a create request. */
    export interface IncidentTeamCreateData {
        attributes?: Schemas.IncidentTeamCreateAttributes;
        relationships?: Schemas.IncidentTeamRelationships;
        type: Schemas.IncidentTeamType;
    }
    /** Create request with an incident team payload. */
    export interface IncidentTeamCreateRequest {
        data: Schemas.IncidentTeamCreateData;
    }
    export type IncidentTeamIncludedItems = Schemas.User;
    /** The incident team's relationships. */
    export interface IncidentTeamRelationships {
        created_by?: Schemas.RelationshipToUser;
        last_modified_by?: Schemas.RelationshipToUser;
    }
    /** Response with an incident team payload. */
    export interface IncidentTeamResponse {
        data: Schemas.IncidentTeamResponseData;
        /** Included objects from relationships. */
        included?: Schemas.IncidentTeamIncludedItems[];
    }
    /** The incident team's attributes from a response. */
    export interface IncidentTeamResponseAttributes {
        /** Timestamp of when the incident team was created. */
        created?: string;
        /** Timestamp of when the incident team was modified. */
        modified?: string;
        /** Name of the incident team. */
        name?: string;
    }
    /** Incident Team data from a response. */
    export interface IncidentTeamResponseData {
        attributes?: Schemas.IncidentTeamResponseAttributes;
        /** The incident team's ID. */
        id?: string;
        relationships?: Schemas.IncidentTeamRelationships;
        type?: Schemas.IncidentTeamType;
    }
    /** Incident Team resource type. */
    export type IncidentTeamType = "teams";
    /** The incident team's attributes for an update request. */
    export interface IncidentTeamUpdateAttributes {
        /** Name of the incident team. */
        name: string;
    }
    /** Incident Team data for an update request. */
    export interface IncidentTeamUpdateData {
        attributes?: Schemas.IncidentTeamUpdateAttributes;
        /** The incident team's ID. */
        id?: string;
        relationships?: Schemas.IncidentTeamRelationships;
        type: Schemas.IncidentTeamType;
    }
    /** Update request with an incident team payload. */
    export interface IncidentTeamUpdateRequest {
        data: Schemas.IncidentTeamUpdateData;
    }
    /** Response with a list of incident team payloads. */
    export interface IncidentTeamsResponse {
        /** An array of incident teams. */
        data: Schemas.IncidentTeamResponseData[];
        /** Included related resources which the user requested. */
        included?: Schemas.IncidentTeamIncludedItems[];
        meta?: Schemas.IncidentResponseMeta;
    }
    export type IncidentTimelineCellCreateAttributes = Schemas.IncidentTimelineCellMarkdownCreateAttributes;
    /** Type of the Markdown timeline cell. */
    export type IncidentTimelineCellMarkdownContentType = "markdown";
    /** Timeline cell data for Markdown timeline cells for a create request. */
    export interface IncidentTimelineCellMarkdownCreateAttributes {
        cell_type: Schemas.IncidentTimelineCellMarkdownContentType;
        content: Schemas.IncidentTimelineCellMarkdownCreateAttributesContent;
        /** A flag indicating whether the timeline cell is important and should be highlighted. */
        important?: boolean;
    }
    /** The Markdown timeline cell contents. */
    export interface IncidentTimelineCellMarkdownCreateAttributesContent {
        /** The Markdown content of the cell. */
        content?: string;
    }
    /** Incident resource type. */
    export type IncidentType = "incidents";
    /** The incident's attributes for an update request. */
    export interface IncidentUpdateAttributes {
        /** Timestamp when customers were no longer impacted by the incident. */
        customer_impact_end?: string | null;
        /** A summary of the impact customers experienced during the incident. */
        customer_impact_scope?: string;
        /** Timestamp when customers began being impacted by the incident. */
        customer_impact_start?: string | null;
        /** A flag indicating whether the incident caused customer impact. */
        customer_impacted?: boolean;
        /** Timestamp when the incident was detected. */
        detected?: string | null;
        /** A condensed view of the user-defined fields for which to update selections. */
        fields?: {
            [key: string]: Schemas.IncidentFieldAttributes;
        };
        /** Notification handles that will be notified of the incident during update. */
        notification_handles?: Schemas.IncidentNotificationHandle[];
        /** Timestamp when the incident's state was set to resolved. */
        resolved?: string | null;
        /** The title of the incident, which summarizes what happened. */
        title?: string;
    }
    /** Incident data for an update request. */
    export interface IncidentUpdateData {
        attributes?: Schemas.IncidentUpdateAttributes;
        /** The team's ID. */
        id: string;
        relationships?: Schemas.IncidentUpdateRelationships;
        type: Schemas.IncidentType;
    }
    /** The incident's relationships for an update request. */
    export interface IncidentUpdateRelationships {
        commander_user?: Schemas.NullableRelationshipToUser;
        integrations?: Schemas.RelationshipToIncidentIntegrationMetadatas;
        postmortem?: Schemas.RelationshipToIncidentPostmortem;
    }
    /** Update request for an incident. */
    export interface IncidentUpdateRequest {
        data: Schemas.IncidentUpdateData;
    }
    /** Response with a list of incidents. */
    export interface IncidentsResponse {
        /** An array of incidents. */
        data: Schemas.IncidentResponseData[];
        /** Included related resources that the user requested. */
        included?: Schemas.IncidentResponseIncludedItem[];
        meta?: Schemas.IncidentResponseMeta;
    }
    /** Response for a list of application keys. */
    export interface ListApplicationKeysResponse {
        /** Array of application keys. */
        data?: Schemas.PartialApplicationKey[];
        /** Array of objects related to the application key. */
        included?: Schemas.ApplicationKeyResponseIncludedItem[];
    }
    /** Object description of a log after being processed and stored by Datadog. */
    export interface Log {
        attributes?: Schemas.LogAttributes;
        /** Unique ID of the Log. */
        id?: string;
        type?: Schemas.LogType;
    }
    /** JSON object containing all log attributes and their associated values. */
    export interface LogAttributes {
        /** JSON object of attributes from your log. */
        attributes?: {
            [key: string]: {};
        };
        /** Name of the machine from where the logs are being sent. */
        host?: string;
        /**
         * The message [reserved attribute](https://docs.datadoghq.com/logs/log_collection/#reserved-attributes)
         * of your log. By default, Datadog ingests the value of the message attribute as the body of the log entry.
         * That value is then highlighted and displayed in the Logstream, where it is indexed for full text search.
         */
        message?: string;
        /**
         * The name of the application or service generating the log events.
         * It is used to switch from Logs to APM, so make sure you define the same
         * value when you use both products.
         */
        service?: string;
        /** Status of the message associated with your log. */
        status?: string;
        /** Array of tags associated with your log. */
        tags?: string[];
        /** Timestamp of your log. */
        timestamp?: string;
    }
    /** Type of the event. */
    export type LogType = "log";
    /** A bucket values */
    export interface LogsAggregateBucket {
        /** The key, value pairs for each group by */
        by?: {
            [key: string]: string;
        };
        /** A map of the metric name -> value for regular compute or list of values for a timeseries */
        computes?: {
            [key: string]: Schemas.LogsAggregateBucketValue;
        };
    }
    export type LogsAggregateBucketValue = Schemas.LogsAggregateBucketValueSingleString | Schemas.LogsAggregateBucketValueSingleNumber | Schemas.LogsAggregateBucketValueTimeseries;
    /** A single number value */
    export type LogsAggregateBucketValueSingleNumber = number;
    /** A single string value */
    export type LogsAggregateBucketValueSingleString = string;
    /** A timeseries array */
    export type LogsAggregateBucketValueTimeseries = Schemas.LogsAggregateBucketValueTimeseriesPoint[];
    /** A timeseries point */
    export interface LogsAggregateBucketValueTimeseriesPoint {
        /** The time value for this point */
        time?: string;
        /** The value for this point */
        value?: number;
    }
    /** The object sent with the request to retrieve a list of logs from your organization. */
    export interface LogsAggregateRequest {
        /** The list of metrics or timeseries to compute for the retrieved buckets. */
        compute?: Schemas.LogsCompute[];
        filter?: Schemas.LogsQueryFilter;
        /** The rules for the group by */
        group_by?: Schemas.LogsGroupBy[];
        options?: Schemas.LogsQueryOptions;
        page?: Schemas.LogsAggregateRequestPage;
    }
    /** Paging settings */
    export interface LogsAggregateRequestPage {
        /** The returned paging point to use to get the next results */
        cursor?: string;
    }
    /** The response object for the logs aggregate API endpoint */
    export interface LogsAggregateResponse {
        data?: Schemas.LogsAggregateResponseData;
        meta?: Schemas.LogsResponseMetadata;
    }
    /** The query results */
    export interface LogsAggregateResponseData {
        /** The list of matching buckets, one item per bucket */
        buckets?: Schemas.LogsAggregateBucket[];
    }
    /** The status of the response */
    export type LogsAggregateResponseStatus = "done" | "timeout";
    /** A sort rule */
    export interface LogsAggregateSort {
        aggregation?: Schemas.LogsAggregationFunction;
        /** The metric to sort by (only used for `type=measure`) */
        metric?: string;
        order?: Schemas.LogsSortOrder;
        type?: Schemas.LogsAggregateSortType;
    }
    /** The type of sorting algorithm */
    export type LogsAggregateSortType = "alphabetical" | "measure";
    /** An aggregation function */
    export type LogsAggregationFunction = "count" | "cardinality" | "pc75" | "pc90" | "pc95" | "pc98" | "pc99" | "sum" | "min" | "max" | "avg";
    /** The logs archive. */
    export interface LogsArchive {
        data?: Schemas.LogsArchiveDefinition;
    }
    /** The attributes associated with the archive. */
    export interface LogsArchiveAttributes {
        destination: Schemas.LogsArchiveDestination;
        /**
         * To store the tags in the archive, set the value "true".
         * If it is set to "false", the tags will be deleted when the logs are sent to the archive.
         */
        include_tags?: boolean;
        /** The archive name. */
        name: string;
        /** The archive query/filter. Logs matching this query are included in the archive. */
        query: string;
        /** An array of tags to add to rehydrated logs from an archive. */
        rehydration_tags?: string[];
        state?: Schemas.LogsArchiveState;
    }
    /** The logs archive. */
    export interface LogsArchiveCreateRequest {
        data?: Schemas.LogsArchiveCreateRequestDefinition;
    }
    /** The attributes associated with the archive. */
    export interface LogsArchiveCreateRequestAttributes {
        destination: Schemas.LogsArchiveCreateRequestDestination;
        /**
         * To store the tags in the archive, set the value "true".
         * If it is set to "false", the tags will be deleted when the logs are sent to the archive.
         */
        include_tags?: boolean;
        /** The archive name. */
        name: string;
        /** The archive query/filter. Logs matching this query are included in the archive. */
        query: string;
        /** An array of tags to add to rehydrated logs from an archive. */
        rehydration_tags?: string[];
    }
    /** The definition of an archive. */
    export interface LogsArchiveCreateRequestDefinition {
        attributes?: Schemas.LogsArchiveCreateRequestAttributes;
        /** The type of the resource. The value should always be archives. */
        type: string;
    }
    export type LogsArchiveCreateRequestDestination = Schemas.LogsArchiveDestinationAzure | Schemas.LogsArchiveDestinationGCS | Schemas.LogsArchiveDestinationS3;
    /** The definition of an archive. */
    export interface LogsArchiveDefinition {
        attributes?: Schemas.LogsArchiveAttributes;
        /** The archive ID. */
        id?: string;
        /** The type of the resource. The value should always be archives. */
        type: string;
    }
    export type LogsArchiveDestination = Schemas.LogsArchiveDestinationAzure | Schemas.LogsArchiveDestinationGCS | Schemas.LogsArchiveDestinationS3;
    /** The Azure archive destination. */
    export interface LogsArchiveDestinationAzure {
        /** The container where the archive will be stored. */
        container: string;
        integration: Schemas.LogsArchiveIntegrationAzure;
        /** The archive path. */
        path?: string;
        /** The region where the archive will be stored. */
        region?: string;
        /** The associated storage account. */
        storage_account: string;
        type: Schemas.LogsArchiveDestinationAzureType;
    }
    /** Type of the Azure archive destination. */
    export type LogsArchiveDestinationAzureType = "azure";
    /** The GCS archive destination. */
    export interface LogsArchiveDestinationGCS {
        /** The bucket where the archive will be stored. */
        bucket: string;
        integration: Schemas.LogsArchiveIntegrationGCS;
        /** The archive path. */
        path?: string;
        type: Schemas.LogsArchiveDestinationGCSType;
    }
    /** Type of the GCS archive destination. */
    export type LogsArchiveDestinationGCSType = "gcs";
    /** The S3 archive destination. */
    export interface LogsArchiveDestinationS3 {
        /** The bucket where the archive will be stored. */
        bucket: string;
        integration: Schemas.LogsArchiveIntegrationS3;
        /** The archive path. */
        path?: string;
        type: Schemas.LogsArchiveDestinationS3Type;
    }
    /** Type of the S3 archive destination. */
    export type LogsArchiveDestinationS3Type = "s3";
    /** The Azure archive's integration destination. */
    export interface LogsArchiveIntegrationAzure {
        /** A client ID. */
        client_id: string;
        /** A tenant ID. */
        tenant_id: string;
    }
    /** The GCS archive's integration destination. */
    export interface LogsArchiveIntegrationGCS {
        /** A client email. */
        client_email: string;
        /** A project ID. */
        project_id: string;
    }
    /** The S3 Archive's integration destination. */
    export interface LogsArchiveIntegrationS3 {
        /** The account ID for the integration. */
        account_id: string;
        /** The path of the integration. */
        role_name: string;
    }
    /** A ordered list of archive IDs. */
    export interface LogsArchiveOrder {
        data?: Schemas.LogsArchiveOrderDefinition;
    }
    /** The attributes associated with the archive order. */
    export interface LogsArchiveOrderAttributes {
        /**
         * An ordered array of `<ARCHIVE_ID>` strings, the order of archive IDs in the array
         * define the overall archives order for Datadog.
         */
        archive_ids: string[];
    }
    /** The definition of an archive order. */
    export interface LogsArchiveOrderDefinition {
        attributes: Schemas.LogsArchiveOrderAttributes;
        type: Schemas.LogsArchiveOrderDefinitionType;
    }
    /** Type of the archive order definition. */
    export type LogsArchiveOrderDefinitionType = "archive_order";
    /** The state of the archive. */
    export type LogsArchiveState = "UNKNOWN" | "WORKING" | "FAILING" | "WORKING_AUTH_LEGACY";
    /** The available archives. */
    export interface LogsArchives {
        /** A list of archives. */
        data?: Schemas.LogsArchiveDefinition[];
    }
    /** A compute rule to compute metrics or timeseries */
    export interface LogsCompute {
        aggregation: Schemas.LogsAggregationFunction;
        /**
         * The time buckets' size (only used for type=timeseries)
         * Defaults to a resolution of 150 points
         */
        interval?: string;
        /** The metric to use */
        metric?: string;
        type?: Schemas.LogsComputeType;
    }
    /** The type of compute */
    export type LogsComputeType = "timeseries" | "total";
    /** A group by rule */
    export interface LogsGroupBy {
        /** The name of the facet to use (required) */
        facet: string;
        histogram?: Schemas.LogsGroupByHistogram;
        /** The maximum buckets to return for this group by */
        limit?: number;
        missing?: Schemas.LogsGroupByMissing;
        sort?: Schemas.LogsAggregateSort;
        total?: Schemas.LogsGroupByTotal;
    }
    /**
     * Used to perform a histogram computation (only for measure facets).
     * Note: At most 100 buckets are allowed, the number of buckets is (max - min)/interval.
     */
    export interface LogsGroupByHistogram {
        /** The bin size of the histogram buckets */
        interval: number;
        /**
         * The maximum value for the measure used in the histogram
         * (values greater than this one are filtered out)
         */
        max: number;
        /**
         * The minimum value for the measure used in the histogram
         * (values smaller than this one are filtered out)
         */
        min: number;
    }
    export type LogsGroupByMissing = Schemas.LogsGroupByMissingString | Schemas.LogsGroupByMissingNumber;
    /** The missing value to use if there is a number valued facet. */
    export type LogsGroupByMissingNumber = number;
    /** The missing value to use if there is string valued facet. */
    export type LogsGroupByMissingString = string;
    export type LogsGroupByTotal = Schemas.LogsGroupByTotalBoolean | Schemas.LogsGroupByTotalString | Schemas.LogsGroupByTotalNumber;
    /** If set to true, creates an additional bucket labeled "$facet_total" */
    export type LogsGroupByTotalBoolean = boolean;
    /** A number to use as the key value for the total bucket */
    export type LogsGroupByTotalNumber = number;
    /** A string to use as the key value for the total bucket */
    export type LogsGroupByTotalString = string;
    /** The request for a logs list. */
    export interface LogsListRequest {
        filter?: Schemas.LogsQueryFilter;
        options?: Schemas.LogsQueryOptions;
        page?: Schemas.LogsListRequestPage;
        sort?: Schemas.LogsSort;
    }
    /** Paging attributes for listing logs. */
    export interface LogsListRequestPage {
        /** List following results with a cursor provided in the previous query. */
        cursor?: string;
        /** Maximum number of logs in the response. */
        limit?: number;
    }
    /** Response object with all logs matching the request and pagination information. */
    export interface LogsListResponse {
        /** Array of logs matching the request. */
        data?: Schemas.Log[];
        links?: Schemas.LogsListResponseLinks;
        meta?: Schemas.LogsResponseMetadata;
    }
    /** Links attributes. */
    export interface LogsListResponseLinks {
        /**
         * Link for the next set of results. Note that the request can also be made using the
         * POST endpoint.
         */
        next?: string;
    }
    /** The compute rule to compute the log-based metric. */
    export interface LogsMetricCompute {
        aggregation_type: Schemas.LogsMetricComputeAggregationType;
        /** The path to the value the log-based metric will aggregate on (only used if the aggregation type is a "distribution"). */
        path?: string;
    }
    /** The type of aggregation to use. */
    export type LogsMetricComputeAggregationType = "count" | "distribution";
    /** The object describing the Datadog log-based metric to create. */
    export interface LogsMetricCreateAttributes {
        compute: Schemas.LogsMetricCompute;
        filter?: Schemas.LogsMetricFilter;
        /** The rules for the group by. */
        group_by?: Schemas.LogsMetricGroupBy[];
    }
    /** The new log-based metric properties. */
    export interface LogsMetricCreateData {
        attributes: Schemas.LogsMetricCreateAttributes;
        id: Schemas.LogsMetricID;
        type: Schemas.LogsMetricType;
    }
    /** The new log-based metric body. */
    export interface LogsMetricCreateRequest {
        data: Schemas.LogsMetricCreateData;
    }
    /** The log-based metric filter. Logs matching this filter will be aggregated in this metric. */
    export interface LogsMetricFilter {
        /** The search query - following the log search syntax. */
        query?: string;
    }
    /** A group by rule. */
    export interface LogsMetricGroupBy {
        /** The path to the value the log-based metric will be aggregated over. */
        path: string;
        /** Eventual name of the tag that gets created. By default, the path attribute is used as the tag name. */
        tag_name?: string;
    }
    /** The name of the log-based metric. */
    export type LogsMetricID = string;
    /** The log-based metric object. */
    export interface LogsMetricResponse {
        data?: Schemas.LogsMetricResponseData;
    }
    /** The object describing a Datadog log-based metric. */
    export interface LogsMetricResponseAttributes {
        compute?: Schemas.LogsMetricResponseCompute;
        filter?: Schemas.LogsMetricResponseFilter;
        /** The rules for the group by. */
        group_by?: Schemas.LogsMetricResponseGroupBy[];
    }
    /** The compute rule to compute the log-based metric. */
    export interface LogsMetricResponseCompute {
        aggregation_type?: Schemas.LogsMetricResponseComputeAggregationType;
        /** The path to the value the log-based metric will aggregate on (only used if the aggregation type is a "distribution"). */
        path?: string;
    }
    /** The type of aggregation to use. */
    export type LogsMetricResponseComputeAggregationType = "count" | "distribution";
    /** The log-based metric properties. */
    export interface LogsMetricResponseData {
        attributes?: Schemas.LogsMetricResponseAttributes;
        id?: Schemas.LogsMetricID;
        type?: Schemas.LogsMetricType;
    }
    /** The log-based metric filter. Logs matching this filter will be aggregated in this metric. */
    export interface LogsMetricResponseFilter {
        /** The search query - following the log search syntax. */
        query?: string;
    }
    /** A group by rule. */
    export interface LogsMetricResponseGroupBy {
        /** The path to the value the log-based metric will be aggregated over. */
        path?: string;
        /** Eventual name of the tag that gets created. By default, the path attribute is used as the tag name. */
        tag_name?: string;
    }
    /** The type of the resource. The value should always be logs_metrics. */
    export type LogsMetricType = "logs_metrics";
    /** The log-based metric properties that will be updated. */
    export interface LogsMetricUpdateAttributes {
        filter?: Schemas.LogsMetricFilter;
        /** The rules for the group by. */
        group_by?: Schemas.LogsMetricGroupBy[];
    }
    /** The new log-based metric properties. */
    export interface LogsMetricUpdateData {
        attributes: Schemas.LogsMetricUpdateAttributes;
        type: Schemas.LogsMetricType;
    }
    /** The new log-based metric body. */
    export interface LogsMetricUpdateRequest {
        data: Schemas.LogsMetricUpdateData;
    }
    /** All the available log-based metric objects. */
    export interface LogsMetricsResponse {
        /** A list of log-based metric objects. */
        data?: Schemas.LogsMetricResponseData[];
    }
    /** The search and filter query settings */
    export interface LogsQueryFilter {
        /** The minimum time for the requested logs, supports date math and regular timestamps (milliseconds). */
        from?: string;
        /** For customers with multiple indexes, the indexes to search. Defaults to ['*'] which means all indexes. */
        indexes?: string[];
        /** The search query - following the log search syntax. */
        query?: string;
        /** The maximum time for the requested logs, supports date math and regular timestamps (milliseconds). */
        to?: string;
    }
    /**
     * Global query options that are used during the query.
     * Note: You should only supply timezone or time offset but not both otherwise the query will fail.
     */
    export interface LogsQueryOptions {
        /** The time offset (in seconds) to apply to the query. */
        timeOffset?: number;
        /** The timezone can be specified both as an offset, for example: "UTC+03:00". */
        timezone?: string;
    }
    /** The metadata associated with a request */
    export interface LogsResponseMetadata {
        /** The time elapsed in milliseconds */
        elapsed?: number;
        page?: Schemas.LogsResponseMetadataPage;
        /** The identifier of the request */
        request_id?: string;
        status?: Schemas.LogsAggregateResponseStatus;
        /**
         * A list of warnings (non fatal errors) encountered, partial results might be returned if
         * warnings are present in the response.
         */
        warnings?: Schemas.LogsWarning[];
    }
    /** Paging attributes. */
    export interface LogsResponseMetadataPage {
        /**
         * The cursor to use to get the next results, if any. To make the next request, use the same.
         * parameters with the addition of the `page[cursor]`.
         */
        after?: string;
    }
    /** Sort parameters when querying logs. */
    export type LogsSort = "timestamp" | "-timestamp";
    /** The order to use, ascending or descending */
    export type LogsSortOrder = "asc" | "desc";
    /** A warning message indicating something that went wrong with the query */
    export interface LogsWarning {
        /** A unique code for this type of warning */
        code?: string;
        /** A detailed explanation of this specific warning */
        detail?: string;
        /** A short human-readable summary of the warning */
        title?: string;
    }
    /** Object for a single metric tag configuration. */
    export interface Metric {
        id?: Schemas.MetricName;
        type?: Schemas.MetricType;
    }
    /** Object for a single metric's indexed tags. */
    export interface MetricAllTags {
        attributes?: Schemas.MetricAllTagsAttributes;
        id?: Schemas.MetricName;
        type?: Schemas.MetricType;
    }
    /** Object containing the definition of a metric's tags. */
    export interface MetricAllTagsAttributes {
        /** List of indexed tag value pairs. */
        tags?: string[];
    }
    /** Response object that includes a single metric's indexed tags. */
    export interface MetricAllTagsResponse {
        data?: Schemas.MetricAllTags;
    }
    /** The metric bulk configure tags resource. */
    export type MetricBulkConfigureTagsType = "metric_bulk_configure_tags";
    /** Request object to bulk configure tags for metrics matching the given prefix. */
    export interface MetricBulkTagConfigCreate {
        attributes?: Schemas.MetricBulkTagConfigCreateAttributes;
        id: Schemas.MetricBulkTagConfigNamePrefix;
        type: Schemas.MetricBulkConfigureTagsType;
    }
    /** Optional parameters for bulk creating metric tag configurations. */
    export interface MetricBulkTagConfigCreateAttributes {
        emails?: Schemas.MetricBulkTagConfigEmailList;
        tags?: Schemas.MetricBulkTagConfigTagNameList;
    }
    /** Wrapper object for a single bulk tag configuration request. */
    export interface MetricBulkTagConfigCreateRequest {
        data: Schemas.MetricBulkTagConfigCreate;
    }
    /** Request object to bulk delete all tag configurations for metrics matching the given prefix. */
    export interface MetricBulkTagConfigDelete {
        attributes?: Schemas.MetricBulkTagConfigDeleteAttributes;
        id: Schemas.MetricBulkTagConfigNamePrefix;
        type: Schemas.MetricBulkConfigureTagsType;
    }
    /** Optional parameters for bulk deleting metric tag configurations. */
    export interface MetricBulkTagConfigDeleteAttributes {
        emails?: Schemas.MetricBulkTagConfigEmailList;
    }
    /** Wrapper object for a single bulk tag deletion request. */
    export interface MetricBulkTagConfigDeleteRequest {
        data: Schemas.MetricBulkTagConfigDelete;
    }
    /** A list of account emails to notify when the configuration is applied. */
    export type MetricBulkTagConfigEmailList = string[];
    /** A text prefix to match against metric names. */
    export type MetricBulkTagConfigNamePrefix = string;
    /** Wrapper for a single bulk tag configuration status response. */
    export interface MetricBulkTagConfigResponse {
        data?: Schemas.MetricBulkTagConfigStatus;
    }
    /**
     * The status of a request to bulk configure metric tags.
     * It contains the fields from the original request for reference.
     */
    export interface MetricBulkTagConfigStatus {
        attributes?: Schemas.MetricBulkTagConfigStatusAttributes;
        id: Schemas.MetricBulkTagConfigNamePrefix;
        type: Schemas.MetricBulkConfigureTagsType;
    }
    /** Optional attributes for the status of a bulk tag configuration request. */
    export interface MetricBulkTagConfigStatusAttributes {
        emails?: Schemas.MetricBulkTagConfigEmailList;
        /** The status of the request. */
        status?: string;
        tags?: Schemas.MetricBulkTagConfigTagNameList;
    }
    /** A list of tag names to apply to the configuration. */
    export type MetricBulkTagConfigTagNameList = string[];
    /** A time and space aggregation combination for use in query. */
    export interface MetricCustomAggregation {
        space: Schemas.MetricCustomSpaceAggregation;
        time: Schemas.MetricCustomTimeAggregation;
    }
    /**
     * A list of queryable aggregation combinations for a count, rate, or gauge metric.
     * By default, count and rate metrics require the (time: sum, space: sum) aggregation and
     * Gauge metrics require the (time: avg, space: avg) aggregation.
     * Additional time & space combinations are also available:
     *
     * - time: avg, space: avg
     * - time: avg, space: max
     * - time: avg, space: min
     * - time: avg, space: sum
     * - time: count, space: sum
     * - time: max, space: max
     * - time: min, space: min
     * - time: sum, space: avg
     * - time: sum, space: sum
     *
     * Can only be applied to metrics that have a `metric_type` of `count`, `rate`, or `gauge`.
     */
    export type MetricCustomAggregations = Schemas.MetricCustomAggregation[];
    /** A space aggregation for use in query. */
    export type MetricCustomSpaceAggregation = "avg" | "max" | "min" | "sum";
    /** A time aggregation for use in query. */
    export type MetricCustomTimeAggregation = "avg" | "count" | "max" | "min" | "sum";
    /** Object for a single metric's distinct volume. */
    export interface MetricDistinctVolume {
        attributes?: Schemas.MetricDistinctVolumeAttributes;
        id?: Schemas.MetricName;
        type?: Schemas.MetricDistinctVolumeType;
    }
    /** Object containing the definition of a metric's distinct volume. */
    export interface MetricDistinctVolumeAttributes {
        /** Distinct volume for the given metric. */
        distinct_volume?: number;
    }
    /** The metric distinct volume type. */
    export type MetricDistinctVolumeType = "distinct_metric_volumes";
    /** Object for a single metric's ingested and indexed volume. */
    export interface MetricIngestedIndexedVolume {
        attributes?: Schemas.MetricIngestedIndexedVolumeAttributes;
        id?: Schemas.MetricName;
        type?: Schemas.MetricIngestedIndexedVolumeType;
    }
    /** Object containing the definition of a metric's ingested and indexed volume. */
    export interface MetricIngestedIndexedVolumeAttributes {
        /** Indexed volume for the given metric. */
        indexed_volume?: number;
        /** Ingested volume for the given metric. */
        ingested_volume?: number;
    }
    /** The metric ingested and indexed volume type. */
    export type MetricIngestedIndexedVolumeType = "metric_volumes";
    /** The metric name for this resource. */
    export type MetricName = string;
    /** Object for a single metric tag configuration. */
    export interface MetricTagConfiguration {
        attributes?: Schemas.MetricTagConfigurationAttributes;
        id?: Schemas.MetricName;
        type?: Schemas.MetricTagConfigurationType;
    }
    /** Object containing the definition of a metric tag configuration attributes. */
    export interface MetricTagConfigurationAttributes {
        aggregations?: Schemas.MetricCustomAggregations;
        /** Timestamp when the tag configuration was created. */
        created_at?: string;
        /**
         * Toggle to turn on/off percentile aggregations for distribution metrics.
         * Only present when the `metric_type` is `distribution`.
         */
        include_percentiles?: boolean;
        metric_type?: Schemas.MetricTagConfigurationMetricTypes;
        /** Timestamp when the tag configuration was last modified. */
        modified_at?: string;
        /** List of tag keys on which to group. */
        tags?: string[];
    }
    /** Object containing the definition of a metric tag configuration to be created. */
    export interface MetricTagConfigurationCreateAttributes {
        aggregations?: Schemas.MetricCustomAggregations;
        /**
         * Toggle to include/exclude percentiles for a distribution metric.
         * Defaults to false. Can only be applied to metrics that have a `metric_type` of `distribution`.
         */
        include_percentiles?: boolean;
        metric_type: Schemas.MetricTagConfigurationMetricTypes;
        /** A list of tag keys that will be queryable for your metric. */
        tags: string[];
    }
    /** Object for a single metric to be configure tags on. */
    export interface MetricTagConfigurationCreateData {
        attributes?: Schemas.MetricTagConfigurationCreateAttributes;
        id: Schemas.MetricName;
        type: Schemas.MetricTagConfigurationType;
    }
    /** Request object that includes the metric that you would like to configure tags for. */
    export interface MetricTagConfigurationCreateRequest {
        data: Schemas.MetricTagConfigurationCreateData;
    }
    /** The metric's type. */
    export type MetricTagConfigurationMetricTypes = "gauge" | "count" | "rate" | "distribution";
    /** Response object which includes a single metric's tag configuration. */
    export interface MetricTagConfigurationResponse {
        data?: Schemas.MetricTagConfiguration;
    }
    /** The metric tag configuration resource type. */
    export type MetricTagConfigurationType = "manage_tags";
    /** Object containing the definition of a metric tag configuration to be updated. */
    export interface MetricTagConfigurationUpdateAttributes {
        aggregations?: Schemas.MetricCustomAggregations;
        /**
         * Toggle to include/exclude percentiles for a distribution metric.
         * Defaults to false. Can only be applied to metrics that have a `metric_type` of `distribution`.
         */
        include_percentiles?: boolean;
        /** A list of tag keys that will be queryable for your metric. */
        tags?: string[];
    }
    /** Object for a single tag configuration to be edited. */
    export interface MetricTagConfigurationUpdateData {
        attributes?: Schemas.MetricTagConfigurationUpdateAttributes;
        id: Schemas.MetricName;
        type: Schemas.MetricTagConfigurationType;
    }
    /** Request object that includes the metric that you would like to edit the tag configuration on. */
    export interface MetricTagConfigurationUpdateRequest {
        data: Schemas.MetricTagConfigurationUpdateData;
    }
    /** The metric resource type. */
    export type MetricType = "metrics";
    export type MetricVolumes = Schemas.MetricDistinctVolume | Schemas.MetricIngestedIndexedVolume;
    /** Response object which includes a single metric's volume. */
    export interface MetricVolumesResponse {
        data?: Schemas.MetricVolumes;
    }
    export type MetricsAndMetricTagConfigurations = Schemas.Metric | Schemas.MetricTagConfiguration;
    /** Response object that includes metrics and metric tag configurations. */
    export interface MetricsAndMetricTagConfigurationsResponse {
        /** Array of metrics and metric tag configurations. */
        data?: Schemas.MetricsAndMetricTagConfigurations[];
    }
    /** Relationship to user. */
    export interface NullableRelationshipToUser {
        data: Schemas.NullableRelationshipToUserData;
    }
    /** Relationship to user object. */
    export interface NullableRelationshipToUserData {
        /** A unique identifier that represents the user. */
        id: string;
        type: Schemas.UsersType;
    }
    /** Organization object. */
    export interface Organization {
        attributes?: Schemas.OrganizationAttributes;
        /** ID of the organization. */
        id?: string;
        type: Schemas.OrganizationsType;
    }
    /** Attributes of the organization. */
    export interface OrganizationAttributes {
        /** Creation time of the organization. */
        created_at?: string;
        /** Description of the organization. */
        description?: string;
        /** Whether or not the organization is disabled. */
        disabled?: boolean;
        /** Time of last organization modification. */
        modified_at?: string;
        /** Name of the organization. */
        name?: string;
        /** Public ID of the organization. */
        public_id?: string;
        /** Sharing type of the organization. */
        sharing?: string;
        /** URL of the site that this organization exists at. */
        url?: string;
    }
    /** Organizations resource type. */
    export type OrganizationsType = "orgs";
    /** Pagination object. */
    export interface Pagination {
        /** Total count. */
        total_count?: number;
        /** Total count of elements matched by the filter. */
        total_filtered_count?: number;
    }
    /** Partial Datadog API key. */
    export interface PartialAPIKey {
        attributes?: Schemas.PartialAPIKeyAttributes;
        /** ID of the API key. */
        id?: string;
        relationships?: Schemas.APIKeyRelationships;
        type?: Schemas.APIKeysType;
    }
    /** Attributes of a partial API key. */
    export interface PartialAPIKeyAttributes {
        /** Creation date of the API key. */
        created_at?: string;
        /** The last four characters of the API key. */
        last4?: string;
        /** Date the API key was last modified. */
        modified_at?: string;
        /** Name of the API key. */
        name?: string;
    }
    /** Partial Datadog application key. */
    export interface PartialApplicationKey {
        attributes?: Schemas.PartialApplicationKeyAttributes;
        /** ID of the application key. */
        id?: string;
        relationships?: Schemas.ApplicationKeyRelationships;
        type?: Schemas.ApplicationKeysType;
    }
    /** Attributes of a partial application key. */
    export interface PartialApplicationKeyAttributes {
        /** Creation date of the application key. */
        created_at?: string;
        /** The last four characters of the application key. */
        last4?: string;
        /** Name of the application key. */
        name?: string;
        /** Array of scopes to grant the application key. This feature is in private beta, please contact Datadog support to enable scopes for your application keys. */
        scopes?: string[] | null;
    }
    /** Response for retrieving a partial application key. */
    export interface PartialApplicationKeyResponse {
        data?: Schemas.PartialApplicationKey;
        /** Array of objects related to the application key. */
        included?: Schemas.ApplicationKeyResponseIncludedItem[];
    }
    /** Permission object. */
    export interface Permission {
        attributes?: Schemas.PermissionAttributes;
        /** ID of the permission. */
        id?: string;
        type: Schemas.PermissionsType;
    }
    /** Attributes of a permission. */
    export interface PermissionAttributes {
        /** Creation time of the permission. */
        created?: string;
        /** Description of the permission. */
        description?: string;
        /** Displayed name for the permission. */
        display_name?: string;
        /** Display type. */
        display_type?: string;
        /** Name of the permission group. */
        group_name?: string;
        /** Name of the permission. */
        name?: string;
        /** Whether or not the permission is restricted. */
        restricted?: boolean;
    }
    /** Payload with API-returned permissions. */
    export interface PermissionsResponse {
        /** Array of permissions. */
        data?: Schemas.Permission[];
    }
    /** Permissions resource type. */
    export type PermissionsType = "permissions";
    /** Response metadata object. */
    export interface ProcessSummariesMeta {
        page?: Schemas.ProcessSummariesMetaPage;
    }
    /** Paging attributes. */
    export interface ProcessSummariesMetaPage {
        /**
         * The cursor used to get the next results, if any. To make the next request, use the same
         * parameters with the addition of the `page[cursor]`.
         */
        after?: string;
        /** Number of results returned. */
        size?: number;
    }
    /** List of process summaries. */
    export interface ProcessSummariesResponse {
        /** Array of process summary objects. */
        data?: Schemas.ProcessSummary[];
        meta?: Schemas.ProcessSummariesMeta;
    }
    /** Process summary object. */
    export interface ProcessSummary {
        attributes?: Schemas.ProcessSummaryAttributes;
        /** Process ID. */
        id?: string;
        type?: Schemas.ProcessSummaryType;
    }
    /** Attributes for a process summary. */
    export interface ProcessSummaryAttributes {
        /** Process command line. */
        cmdline?: string;
        /** Host running the process. */
        host?: string;
        /** Process ID. */
        pid?: number;
        /** Parent process ID. */
        ppid?: number;
        /** Time the process was started. */
        start?: string;
        /** List of tags associated with the process. */
        tags?: string[];
        /** Time the process was seen. */
        timestamp?: string;
        /** Process owner. */
        user?: string;
    }
    /** Type of process summary. */
    export type ProcessSummaryType = "process";
    /** Direction of sort. */
    export type QuerySortOrder = "asc" | "desc";
    /** A relationship reference for an integration metadata object. */
    export interface RelationshipToIncidentIntegrationMetadataData {
        /** A unique identifier that represents the integration metadata. */
        id: string;
        type: Schemas.IncidentIntegrationMetadataType;
    }
    /** A relationship reference for multiple integration metadata objects. */
    export interface RelationshipToIncidentIntegrationMetadatas {
        /** The integration metadata relationship array */
        data: Schemas.RelationshipToIncidentIntegrationMetadataData[];
    }
    /** A relationship reference for postmortems. */
    export interface RelationshipToIncidentPostmortem {
        data: Schemas.RelationshipToIncidentPostmortemData;
    }
    /** The postmortem relationship data. */
    export interface RelationshipToIncidentPostmortemData {
        /** A unique identifier that represents the postmortem. */
        id: string;
        type: Schemas.IncidentPostmortemType;
    }
    /** Relationship to an organization. */
    export interface RelationshipToOrganization {
        data: Schemas.RelationshipToOrganizationData;
    }
    /** Relationship to organization object. */
    export interface RelationshipToOrganizationData {
        /** ID of the organization. */
        id: string;
        type: Schemas.OrganizationsType;
    }
    /** Relationship to organizations. */
    export interface RelationshipToOrganizations {
        /** Relationships to organization objects. */
        data: Schemas.RelationshipToOrganizationData[];
    }
    /** Relationship to a permissions object. */
    export interface RelationshipToPermission {
        data?: Schemas.RelationshipToPermissionData;
    }
    /** Relationship to permission object. */
    export interface RelationshipToPermissionData {
        /** ID of the permission. */
        id?: string;
        type?: Schemas.PermissionsType;
    }
    /** Relationship to multiple permissions objects. */
    export interface RelationshipToPermissions {
        /** Relationships to permission objects. */
        data?: Schemas.RelationshipToPermissionData[];
    }
    /** Relationship to role. */
    export interface RelationshipToRole {
        data?: Schemas.RelationshipToRoleData;
    }
    /** Relationship to role object. */
    export interface RelationshipToRoleData {
        /** ID of the role. */
        id?: string;
        type?: Schemas.RolesType;
    }
    /** Relationship to roles. */
    export interface RelationshipToRoles {
        /** An array containing type and ID of a role. */
        data?: Schemas.RelationshipToRoleData[];
    }
    /** AuthN Mapping relationship to SAML Assertion Attribute. */
    export interface RelationshipToSAMLAssertionAttribute {
        data: Schemas.RelationshipToSAMLAssertionAttributeData;
    }
    /** Data of AuthN Mapping relationship to SAML Assertion Attribute. */
    export interface RelationshipToSAMLAssertionAttributeData {
        /** The ID of the SAML assertion attribute. */
        id: number;
        type: Schemas.SAMLAssertionAttributesType;
    }
    /** Relationship to user. */
    export interface RelationshipToUser {
        data: Schemas.RelationshipToUserData;
    }
    /** Relationship to user object. */
    export interface RelationshipToUserData {
        /** A unique identifier that represents the user. */
        id: string;
        type: Schemas.UsersType;
    }
    /** Relationship to users. */
    export interface RelationshipToUsers {
        /** Relationships to user objects. */
        data: Schemas.RelationshipToUserData[];
    }
    /** Object describing meta attributes of response. */
    export interface ResponseMetaAttributes {
        page?: Schemas.Pagination;
    }
    /** Role object returned by the API. */
    export interface Role {
        attributes?: Schemas.RoleAttributes;
        /** ID of the role. */
        id?: string;
        relationships?: Schemas.RoleResponseRelationships;
        type: Schemas.RolesType;
    }
    /** Attributes of the role. */
    export interface RoleAttributes {
        /** Creation time of the role. */
        created_at?: string;
        /** Time of last role modification. */
        modified_at?: string;
        /** Name of the role. */
        name?: string;
        /** Number of users with that role. */
        user_count?: number;
    }
    /** Data for the clone role request. */
    export interface RoleClone {
        attributes: Schemas.RoleCloneAttributes;
        type: Schemas.RolesType;
    }
    /** Attributes required to create a new role by cloning an existing one. */
    export interface RoleCloneAttributes {
        /** Name of the new role that is cloned. */
        name: string;
    }
    /** Request to create a role by cloning an existing role. */
    export interface RoleCloneRequest {
        data: Schemas.RoleClone;
    }
    /** Attributes of the created role. */
    export interface RoleCreateAttributes {
        /** Creation time of the role. */
        created_at?: string;
        /** Time of last role modification. */
        modified_at?: string;
        /** Name of the role. */
        name: string;
    }
    /** Data related to the creation of a role. */
    export interface RoleCreateData {
        attributes: Schemas.RoleCreateAttributes;
        relationships?: Schemas.RoleRelationships;
        type?: Schemas.RolesType;
    }
    /** Create a role. */
    export interface RoleCreateRequest {
        data: Schemas.RoleCreateData;
    }
    /** Response containing information about a created role. */
    export interface RoleCreateResponse {
        data?: Schemas.RoleCreateResponseData;
    }
    /** Role object returned by the API. */
    export interface RoleCreateResponseData {
        attributes?: Schemas.RoleCreateAttributes;
        /** ID of the role. */
        id?: string;
        relationships?: Schemas.RoleResponseRelationships;
        type: Schemas.RolesType;
    }
    /** Relationships of the role object. */
    export interface RoleRelationships {
        permissions?: Schemas.RelationshipToPermissions;
        users?: Schemas.RelationshipToUsers;
    }
    /** Response containing information about a single role. */
    export interface RoleResponse {
        data?: Schemas.Role;
    }
    /** Relationships of the role object returned by the API. */
    export interface RoleResponseRelationships {
        permissions?: Schemas.RelationshipToPermissions;
    }
    /** Attributes of the role. */
    export interface RoleUpdateAttributes {
        /** Creation time of the role. */
        created_at?: string;
        /** Time of last role modification. */
        modified_at?: string;
        /** Name of the role. */
        name?: string;
    }
    /** Data related to the update of a role. */
    export interface RoleUpdateData {
        attributes: Schemas.RoleUpdateAttributes;
        /** ID of the role. */
        id: string;
        type: Schemas.RolesType;
    }
    /** Update a role. */
    export interface RoleUpdateRequest {
        data: Schemas.RoleUpdateData;
    }
    /** Response containing information about an updated role. */
    export interface RoleUpdateResponse {
        data?: Schemas.RoleUpdateResponseData;
    }
    /** Role object returned by the API. */
    export interface RoleUpdateResponseData {
        attributes?: Schemas.RoleUpdateAttributes;
        /** ID of the role. */
        id?: string;
        relationships?: Schemas.RoleResponseRelationships;
        type: Schemas.RolesType;
    }
    /** Response containing information about multiple roles. */
    export interface RolesResponse {
        /** Array of returned roles. */
        data?: Schemas.Role[];
        meta?: Schemas.ResponseMetaAttributes;
    }
    /** Sorting options for roles. */
    export type RolesSort = "name" | "-name" | "modified_at" | "-modified_at" | "user_count" | "-user_count";
    /** Roles type. */
    export type RolesType = "roles";
    /** SAML assertion attribute. */
    export interface SAMLAssertionAttribute {
        attributes?: Schemas.SAMLAssertionAttributeAttributes;
        /** The ID of the SAML assertion attribute. */
        id: number;
        type: Schemas.SAMLAssertionAttributesType;
    }
    /** Key/Value pair of attributes used in SAML assertion attributes. */
    export interface SAMLAssertionAttributeAttributes {
        /** Key portion of a key/value pair of the attribute sent from the Identity Provider. */
        attribute_key?: string;
        /** Value portion of a key/value pair of the attribute sent from the Identity Provider. */
        attribute_value?: string;
    }
    /** SAML assertion attributes resource type. */
    export type SAMLAssertionAttributesType = "saml_assertion_attributes";
    /** The security filter's properties. */
    export interface SecurityFilter {
        attributes?: Schemas.SecurityFilterAttributes;
        id?: Schemas.SecurityFilterID;
        type?: Schemas.SecurityFilterType;
    }
    /** The object describing a security filter. */
    export interface SecurityFilterAttributes {
        /** The list of exclusion filters applied in this security filter. */
        exclusion_filters?: Schemas.SecurityFilterExclusionFilterResponse[];
        filtered_data_type?: Schemas.SecurityFilterFilteredDataType;
        /** Whether the security filter is the built-in filter. */
        is_builtin?: boolean;
        /** Whether the security filter is enabled. */
        is_enabled?: boolean;
        /** The security filter name. */
        name?: string;
        /** The security filter query. Logs accepted by this query will be accepted by this filter. */
        query?: string;
        /** The version of the security filter. */
        version?: number;
    }
    /** Object containing the attributes of the security filter to be created. */
    export interface SecurityFilterCreateAttributes {
        /** Exclusion filters to exclude some logs from the security filter. */
        exclusion_filters: Schemas.SecurityFilterExclusionFilter[];
        filtered_data_type: Schemas.SecurityFilterFilteredDataType;
        /** Whether the security filter is enabled. */
        is_enabled: boolean;
        /** The name of the security filter. */
        name: string;
        /** The query of the security filter. */
        query: string;
    }
    /** Object for a single security filter. */
    export interface SecurityFilterCreateData {
        attributes: Schemas.SecurityFilterCreateAttributes;
        type: Schemas.SecurityFilterType;
    }
    /** Request object that includes the security filter that you would like to create. */
    export interface SecurityFilterCreateRequest {
        data: Schemas.SecurityFilterCreateData;
    }
    /** Exclusion filter for the security filter. */
    export interface SecurityFilterExclusionFilter {
        /** Exclusion filter name. */
        name: string;
        /** Exclusion filter query. Logs that match this query are excluded from the security filter. */
        query: string;
    }
    /** A single exclusion filter. */
    export interface SecurityFilterExclusionFilterResponse {
        /** The exclusion filter name. */
        name?: string;
        /** The exclusion filter query. */
        query?: string;
    }
    /** The filtered data type. */
    export type SecurityFilterFilteredDataType = "logs";
    /** The ID of the security filter. */
    export type SecurityFilterID = string;
    /** Optional metadata associated to the response. */
    export interface SecurityFilterMeta {
        /** A warning message. */
        warning?: string;
    }
    /** Response object which includes a single security filter. */
    export interface SecurityFilterResponse {
        data?: Schemas.SecurityFilter;
        meta?: Schemas.SecurityFilterMeta;
    }
    /** The type of the resource. The value should always be `security_filters`. */
    export type SecurityFilterType = "security_filters";
    /** The security filters properties to be updated. */
    export interface SecurityFilterUpdateAttributes {
        /** Exclusion filters to exclude some logs from the security filter. */
        exclusion_filters?: Schemas.SecurityFilterExclusionFilter[];
        filtered_data_type?: Schemas.SecurityFilterFilteredDataType;
        /** Whether the security filter is enabled. */
        is_enabled?: boolean;
        /** The name of the security filter. */
        name?: string;
        /** The query of the security filter. */
        query?: string;
        /** The version of the security filter to update. */
        version?: number;
    }
    /** The new security filter properties. */
    export interface SecurityFilterUpdateData {
        attributes: Schemas.SecurityFilterUpdateAttributes;
        type: Schemas.SecurityFilterType;
    }
    /** The new security filter body. */
    export interface SecurityFilterUpdateRequest {
        data: Schemas.SecurityFilterUpdateData;
    }
    /** All the available security filters objects. */
    export interface SecurityFiltersResponse {
        /** A list of security filters objects. */
        data?: Schemas.SecurityFilter[];
        meta?: Schemas.SecurityFilterMeta;
    }
    /** The rule's suppression filter. */
    export interface SecurityMonitoringFilter {
        action?: Schemas.SecurityMonitoringFilterAction;
        /** Query for selecting logs to apply the filtering action. */
        query?: string;
    }
    /** The type of filtering action. */
    export type SecurityMonitoringFilterAction = "require" | "suppress";
    /** List of rules. */
    export interface SecurityMonitoringListRulesResponse {
        /** Array containing the list of rules. */
        data?: Schemas.SecurityMonitoringRuleResponse[];
        meta?: Schemas.ResponseMetaAttributes;
    }
    /** Case when signal is generated. */
    export interface SecurityMonitoringRuleCase {
        /**
         * A rule case contains logical operations (`>`,`>=`, `&&`, `||`) to determine if a signal should be generated
         * based on the event counts in the previously defined queries.
         */
        condition?: string;
        /** Name of the case. */
        name?: string;
        /** Notification targets for each rule case. */
        notifications?: string[];
        status?: Schemas.SecurityMonitoringRuleSeverity;
    }
    /** Case when signal is generated. */
    export interface SecurityMonitoringRuleCaseCreate {
        /**
         * A rule case contains logical operations (`>`,`>=`, `&&`, `||`) to determine if a signal should be generated
         * based on the event counts in the previously defined queries.
         */
        condition?: string;
        /** Name of the case. */
        name?: string;
        /** Notification targets for each rule case. */
        notifications?: string[];
        status: Schemas.SecurityMonitoringRuleSeverity;
    }
    /** Create a new rule. */
    export interface SecurityMonitoringRuleCreatePayload {
        /** Cases for generating signals. */
        cases: Schemas.SecurityMonitoringRuleCaseCreate[];
        /** Additional queries to filter matched events before they are processed. */
        filters?: Schemas.SecurityMonitoringFilter[];
        /** Whether the notifications include the triggering group-by values in their title. */
        hasExtendedTitle?: boolean;
        /** Whether the rule is enabled. */
        isEnabled: boolean;
        /** Message for generated signals. */
        message: string;
        /** The name of the rule. */
        name: string;
        options: Schemas.SecurityMonitoringRuleOptions;
        /** Queries for selecting logs which are part of the rule. */
        queries: Schemas.SecurityMonitoringRuleQueryCreate[];
        /** Tags for generated signals. */
        tags?: string[];
        type?: Schemas.SecurityMonitoringRuleTypeCreate;
    }
    /** The detection method. */
    export type SecurityMonitoringRuleDetectionMethod = "threshold" | "new_value" | "anomaly_detection" | "impossible_travel";
    /**
     * A time window is specified to match when at least one of the cases matches true. This is a sliding window
     * and evaluates in real time.
     */
    export type SecurityMonitoringRuleEvaluationWindow = 0 | 60 | 300 | 600 | 900 | 1800 | 3600 | 7200;
    /** Options on impossible travel rules. */
    export interface SecurityMonitoringRuleImpossibleTravelOptions {
        baselineUserLocations?: Schemas.SecurityMonitoringRuleImpossibleTravelOptionsBaselineUserLocations;
    }
    /**
     * If true, signals are suppressed for the first 24 hours. In that time, Datadog learns the user's regular
     * access locations. This can be helpful to reduce noise and infer VPN usage or credentialed API access.
     */
    export type SecurityMonitoringRuleImpossibleTravelOptionsBaselineUserLocations = boolean;
    /**
     * Once a signal is generated, the signal will remain open if a case is matched at least once within
     * this keep alive window.
     */
    export type SecurityMonitoringRuleKeepAlive = 0 | 60 | 300 | 600 | 900 | 1800 | 3600 | 7200 | 10800 | 21600;
    /**
     * A signal will close regardless of the query being matched once the time exceeds the maximum duration.
     * This time is calculated from the first seen timestamp.
     */
    export type SecurityMonitoringRuleMaxSignalDuration = 0 | 60 | 300 | 600 | 900 | 1800 | 3600 | 7200 | 10800 | 21600 | 43200 | 86400;
    /** Options on new value rules. */
    export interface SecurityMonitoringRuleNewValueOptions {
        forgetAfter?: Schemas.SecurityMonitoringRuleNewValueOptionsForgetAfter;
        learningDuration?: Schemas.SecurityMonitoringRuleNewValueOptionsLearningDuration;
    }
    /** The duration in days after which a learned value is forgotten. */
    export type SecurityMonitoringRuleNewValueOptionsForgetAfter = 1 | 2 | 7 | 14 | 21 | 28;
    /**
     * The duration in days during which values are learned, and after which signals will be generated for values that
     * weren't learned. If set to 0, a signal will be generated for all new values after the first value is learned.
     */
    export type SecurityMonitoringRuleNewValueOptionsLearningDuration = 0 | 1 | 7;
    /** Options on rules. */
    export interface SecurityMonitoringRuleOptions {
        detectionMethod?: Schemas.SecurityMonitoringRuleDetectionMethod;
        evaluationWindow?: Schemas.SecurityMonitoringRuleEvaluationWindow;
        impossibleTravelOptions?: Schemas.SecurityMonitoringRuleImpossibleTravelOptions;
        keepAlive?: Schemas.SecurityMonitoringRuleKeepAlive;
        maxSignalDuration?: Schemas.SecurityMonitoringRuleMaxSignalDuration;
        newValueOptions?: Schemas.SecurityMonitoringRuleNewValueOptions;
    }
    /** Query for matching rule. */
    export interface SecurityMonitoringRuleQuery {
        aggregation?: Schemas.SecurityMonitoringRuleQueryAggregation;
        /** Field for which the cardinality is measured. Sent as an array. */
        distinctFields?: string[];
        /** Fields to group by. */
        groupByFields?: string[];
        /**
         * The target field to aggregate over when using the sum or max
         * aggregations.
         */
        metric?: string;
        /** Name of the query. */
        name?: string;
        /** Query to run on logs. */
        query?: string;
    }
    /** The aggregation type. */
    export type SecurityMonitoringRuleQueryAggregation = "count" | "cardinality" | "sum" | "max" | "new_value" | "geo_data";
    /** Query for matching rule. */
    export interface SecurityMonitoringRuleQueryCreate {
        aggregation?: Schemas.SecurityMonitoringRuleQueryAggregation;
        /** Field for which the cardinality is measured. Sent as an array. */
        distinctFields?: string[];
        /** Fields to group by. */
        groupByFields?: string[];
        /**
         * The target field to aggregate over when using the sum or max
         * aggregations.
         */
        metric?: string;
        /** Name of the query. */
        name?: string;
        /** Query to run on logs. */
        query: string;
    }
    /** Rule. */
    export interface SecurityMonitoringRuleResponse {
        /** Cases for generating signals. */
        cases?: Schemas.SecurityMonitoringRuleCase[];
        /** When the rule was created, timestamp in milliseconds. */
        createdAt?: number;
        /** User ID of the user who created the rule. */
        creationAuthorId?: number;
        /** Additional queries to filter matched events before they are processed. */
        filters?: Schemas.SecurityMonitoringFilter[];
        /** Whether the notifications include the triggering group-by values in their title. */
        hasExtendedTitle?: boolean;
        /** The ID of the rule. */
        id?: string;
        /** Whether the rule is included by default. */
        isDefault?: boolean;
        /** Whether the rule has been deleted. */
        isDeleted?: boolean;
        /** Whether the rule is enabled. */
        isEnabled?: boolean;
        /** Message for generated signals. */
        message?: string;
        /** The name of the rule. */
        name?: string;
        options?: Schemas.SecurityMonitoringRuleOptions;
        /** Queries for selecting logs which are part of the rule. */
        queries?: Schemas.SecurityMonitoringRuleQuery[];
        /** Tags for generated signals. */
        tags?: string[];
        type?: Schemas.SecurityMonitoringRuleTypeRead;
        /** User ID of the user who updated the rule. */
        updateAuthorId?: number;
        /** The version of the rule. */
        version?: number;
    }
    /** Severity of the Security Signal. */
    export type SecurityMonitoringRuleSeverity = "info" | "low" | "medium" | "high" | "critical";
    /** The rule type. */
    export type SecurityMonitoringRuleTypeCreate = "log_detection" | "workload_security";
    /** The rule type. */
    export type SecurityMonitoringRuleTypeRead = "log_detection" | "infrastructure_configuration" | "workload_security" | "cloud_configuration";
    /** Update an existing rule. */
    export interface SecurityMonitoringRuleUpdatePayload {
        /** Cases for generating signals. */
        cases?: Schemas.SecurityMonitoringRuleCase[];
        /** Additional queries to filter matched events before they are processed. */
        filters?: Schemas.SecurityMonitoringFilter[];
        /** Whether the notifications include the triggering group-by values in their title. */
        hasExtendedTitle?: boolean;
        /** Whether the rule is enabled. */
        isEnabled?: boolean;
        /** Message for generated signals. */
        message?: string;
        /** Name of the rule. */
        name?: string;
        options?: Schemas.SecurityMonitoringRuleOptions;
        /** Queries for selecting logs which are part of the rule. */
        queries?: Schemas.SecurityMonitoringRuleQuery[];
        /** Tags for generated signals. */
        tags?: string[];
        /** The version of the rule being updated. */
        version?: number;
    }
    /** Object description of a security signal. */
    export interface SecurityMonitoringSignal {
        attributes?: Schemas.SecurityMonitoringSignalAttributes;
        /** The unique ID of the security signal. */
        id?: string;
        type?: Schemas.SecurityMonitoringSignalType;
    }
    /**
     * The object containing all signal attributes and their
     * associated values.
     */
    export interface SecurityMonitoringSignalAttributes {
        /** A JSON object of attributes in the security signal. */
        attributes?: {
            [key: string]: {};
        };
        /** The message in the security signal defined by the rule that generated the signal. */
        message?: string;
        /** An array of tags associated with the security signal. */
        tags?: string[];
        /** The timestamp of the security signal. */
        timestamp?: string;
    }
    /** The request for a security signal list. */
    export interface SecurityMonitoringSignalListRequest {
        filter?: Schemas.SecurityMonitoringSignalListRequestFilter;
        page?: Schemas.SecurityMonitoringSignalListRequestPage;
        sort?: Schemas.SecurityMonitoringSignalsSort;
    }
    /** Search filters for listing security signals. */
    export interface SecurityMonitoringSignalListRequestFilter {
        /** The minimum timestamp for requested security signals. */
        from?: string;
        /** Search query for listing security signals. */
        query?: string;
        /** The maximum timestamp for requested security signals. */
        to?: string;
    }
    /** The paging attributes for listing security signals. */
    export interface SecurityMonitoringSignalListRequestPage {
        /** A list of results using the cursor provided in the previous query. */
        cursor?: string;
        /** The maximum number of security signals in the response. */
        limit?: number;
    }
    /** The type of event. */
    export type SecurityMonitoringSignalType = "signal";
    /**
     * The response object with all security signals matching the request
     * and pagination information.
     */
    export interface SecurityMonitoringSignalsListResponse {
        /** An array of security signals matching the request. */
        data?: Schemas.SecurityMonitoringSignal[];
        links?: Schemas.SecurityMonitoringSignalsListResponseLinks;
        meta?: Schemas.SecurityMonitoringSignalsListResponseMeta;
    }
    /** Links attributes. */
    export interface SecurityMonitoringSignalsListResponseLinks {
        /**
         * The link for the next set of results. **Note**: The request can also be made using the
         * POST endpoint.
         */
        next?: string;
    }
    /** Meta attributes. */
    export interface SecurityMonitoringSignalsListResponseMeta {
        page?: Schemas.SecurityMonitoringSignalsListResponseMetaPage;
    }
    /** Paging attributes. */
    export interface SecurityMonitoringSignalsListResponseMetaPage {
        /**
         * The cursor used to get the next results, if any. To make the next request, use the same
         * parameters with the addition of the `page[cursor]`.
         */
        after?: string;
    }
    /** The sort parameters used for querying security signals. */
    export type SecurityMonitoringSignalsSort = "timestamp" | "-timestamp";
    /** Attributes of the created user. */
    export interface ServiceAccountCreateAttributes {
        /** The email of the user. */
        email: string;
        /** The name of the user. */
        name?: string;
        /** Whether the user is a service account. Must be true. */
        service_account: boolean;
        /** The title of the user. */
        title?: string;
    }
    /** Object to create a service account User. */
    export interface ServiceAccountCreateData {
        attributes: Schemas.ServiceAccountCreateAttributes;
        relationships?: Schemas.UserRelationships;
        type: Schemas.UsersType;
    }
    /** Create a service account. */
    export interface ServiceAccountCreateRequest {
        data: Schemas.ServiceAccountCreateData;
    }
    /** User object returned by the API. */
    export interface User {
        attributes?: Schemas.UserAttributes;
        /** ID of the user. */
        id?: string;
        relationships?: Schemas.UserResponseRelationships;
        type?: Schemas.UsersType;
    }
    /** Attributes of user object returned by the API. */
    export interface UserAttributes {
        /** Creation time of the user. */
        created_at?: string;
        /** Whether the user is disabled. */
        disabled?: boolean;
        /** Email of the user. */
        email?: string;
        /** Handle of the user. */
        handle?: string;
        /** URL of the user's icon. */
        icon?: string;
        /** Time that the user was last modified. */
        modified_at?: string;
        /** Name of the user. */
        name?: string | null;
        /** Whether the user is a service account. */
        service_account?: boolean;
        /** Status of the user. */
        status?: string;
        /** Title of the user. */
        title?: string | null;
        /** Whether the user is verified. */
        verified?: boolean;
    }
    /** Attributes of the created user. */
    export interface UserCreateAttributes {
        /** The email of the user. */
        email: string;
        /** The name of the user. */
        name?: string;
        /** The title of the user. */
        title?: string;
    }
    /** Object to create a user. */
    export interface UserCreateData {
        attributes: Schemas.UserCreateAttributes;
        relationships?: Schemas.UserRelationships;
        type: Schemas.UsersType;
    }
    /** Create a user. */
    export interface UserCreateRequest {
        data: Schemas.UserCreateData;
    }
    /** Object to create a user invitation. */
    export interface UserInvitationData {
        relationships: Schemas.UserInvitationRelationships;
        type: Schemas.UserInvitationsType;
    }
    /** Attributes of a user invitation. */
    export interface UserInvitationDataAttributes {
        /** Creation time of the user invitation. */
        created_at?: string;
        /** Time of invitation expiration. */
        expires_at?: string;
        /** Type of invitation. */
        invite_type?: string;
        /** UUID of the user invitation. */
        uuid?: string;
    }
    /** Relationships data for user invitation. */
    export interface UserInvitationRelationships {
        user: Schemas.RelationshipToUser;
    }
    /** User invitation as returned by the API. */
    export interface UserInvitationResponse {
        data?: Schemas.UserInvitationResponseData;
    }
    /** Object of a user invitation returned by the API. */
    export interface UserInvitationResponseData {
        attributes?: Schemas.UserInvitationDataAttributes;
        /** ID of the user invitation. */
        id?: string;
        type?: Schemas.UserInvitationsType;
    }
    /** Object to invite users to join the organization. */
    export interface UserInvitationsRequest {
        /** List of user invitations. */
        data: Schemas.UserInvitationData[];
    }
    /** User invitations as returned by the API. */
    export interface UserInvitationsResponse {
        /** Array of user invitations. */
        data?: Schemas.UserInvitationResponseData[];
    }
    /** User invitations type. */
    export type UserInvitationsType = "user_invitations";
    /** Relationships of the user object. */
    export interface UserRelationships {
        roles?: Schemas.RelationshipToRoles;
    }
    /** Response containing information about a single user. */
    export interface UserResponse {
        data?: Schemas.User;
        /** Array of objects related to the user. */
        included?: Schemas.UserResponseIncludedItem[];
    }
    export type UserResponseIncludedItem = Schemas.Organization | Schemas.Permission | Schemas.Role;
    /** Relationships of the user object returned by the API. */
    export interface UserResponseRelationships {
        org?: Schemas.RelationshipToOrganization;
        other_orgs?: Schemas.RelationshipToOrganizations;
        other_users?: Schemas.RelationshipToUsers;
        roles?: Schemas.RelationshipToRoles;
    }
    /** Attributes of the edited user. */
    export interface UserUpdateAttributes {
        /** If the user is enabled or disabled. */
        disabled?: boolean;
        /** The email of the user. */
        email?: string;
        /** The name of the user. */
        name?: string;
    }
    /** Object to update a user. */
    export interface UserUpdateData {
        attributes: Schemas.UserUpdateAttributes;
        /** ID of the user. */
        id: string;
        type: Schemas.UsersType;
    }
    /** Update a user. */
    export interface UserUpdateRequest {
        data: Schemas.UserUpdateData;
    }
    /** Response containing information about multiple users. */
    export interface UsersResponse {
        /** Array of returned users. */
        data?: Schemas.User[];
        /** Array of objects related to the users. */
        included?: Schemas.UserResponseIncludedItem[];
        meta?: Schemas.ResponseMetaAttributes;
    }
    /** Users resource type. */
    export type UsersType = "users";
}
export namespace Headers { }
export namespace Responses {
    /** Bad Request */
    export namespace BadRequestResponse {
        export interface Content {
            "application/json": Schemas.APIErrorResponse;
        }
    }
    /** Concurrent Modification */
    export namespace ConcurrentModificationResponse {
        export interface Content {
            "application/json": Schemas.APIErrorResponse;
        }
    }
    /** Conflict */
    export namespace ConflictResponse {
        export interface Content {
            "application/json": Schemas.APIErrorResponse;
        }
    }
    /** Forbidden */
    export namespace ForbiddenResponse {
        export interface Content {
            "application/json": Schemas.APIErrorResponse;
        }
    }
    /** Not Authorized */
    export namespace NotAuthorizedResponse {
        export interface Content {
            "application/json": Schemas.APIErrorResponse;
        }
    }
    /** Not Found */
    export namespace NotFoundResponse {
        export interface Content {
            "application/json": Schemas.APIErrorResponse;
        }
    }
    /** Too many requests */
    export namespace TooManyRequestsResponse {
        export interface Content {
            "application/json": Schemas.APIErrorResponse;
        }
    }
    /** Unauthorized */
    export namespace UnauthorizedResponse {
        export interface Content {
            "application/json": Schemas.APIErrorResponse;
        }
    }
}
export namespace Parameters {
    /** Only include API keys created on or before the specified date. */
    export type APIKeyFilterCreatedAtEndParameter = string;
    /** Only include API keys created on or after the specified date. */
    export type APIKeyFilterCreatedAtStartParameter = string;
    /** Only include API keys modified on or before the specified date. */
    export type APIKeyFilterModifiedAtEndParameter = string;
    /** Only include API keys modified on or after the specified date. */
    export type APIKeyFilterModifiedAtStartParameter = string;
    /** Filter API keys by the specified string. */
    export type APIKeyFilterParameter = string;
    /** The ID of the API key. */
    export type APIKeyId = string;
    /** Comma separated list of resource paths for related resources to include in the response. Supported resource paths are `created_by` and `modified_by`. */
    export type APIKeyIncludeParameter = string;
    /**
     * API key attribute used to sort results. Sort order is ascending
     * by default. In order to specify a descending sort, prefix the
     * attribute with a minus sign.
     */
    export type APIKeysSortParameter = Schemas.APIKeysSort;
    /** Only include application keys created on or before the specified date. */
    export type ApplicationKeyFilterCreatedAtEndParameter = string;
    /** Only include application keys created on or after the specified date. */
    export type ApplicationKeyFilterCreatedAtStartParameter = string;
    /** Filter application keys by the specified string. */
    export type ApplicationKeyFilterParameter = string;
    /** The ID of the application key. */
    export type ApplicationKeyID = string;
    /** Resource path for related resources to include in the response. Only `owned_by` is supported. */
    export type ApplicationKeyIncludeParameter = string;
    /**
     * Application key attribute used to sort results. Sort order is ascending
     * by default. In order to specify a descending sort, prefix the
     * attribute with a minus sign.
     */
    export type ApplicationKeysSortParameter = Schemas.ApplicationKeysSort;
    /** The ID of the archive. */
    export type ArchiveID = string;
    /** The UUID of the AuthN Mapping. */
    export type AuthNMappingID = string;
    /** The ID of the Agent rule. */
    export type CloudWorkloadSecurityAgentRuleID = string;
    /** The UUID of the incident. */
    export type IncidentIDPathParameter = string;
    /** Specifies which types of related objects should be included in the response. */
    export type IncidentIncludeQueryParameter = Schemas.IncidentRelatedObject[];
    /** The ID of the incident service. */
    export type IncidentServiceIDPathParameter = string;
    /** Specifies which types of related objects should be included in the response. */
    export type IncidentServiceIncludeQueryParameter = Schemas.IncidentRelatedObject;
    /** A search query that filters services by name. */
    export type IncidentServiceSearchQueryParameter = string;
    /** The ID of the incident team. */
    export type IncidentTeamIDPathParameter = string;
    /** Specifies which types of related objects should be included in the response. */
    export type IncidentTeamIncludeQueryParameter = Schemas.IncidentRelatedObject;
    /** A search query that filters teams by name. */
    export type IncidentTeamSearchQueryParameter = string;
    /** The name of the log-based metric. */
    export type MetricID = string;
    /** The name of the metric. */
    export type MetricName = string;
    /** Specific page number to return. */
    export type PageNumber = number;
    /** Specific offset to use as the beginning of the returned page. */
    export type PageOffset = number;
    /** Size for a given page. */
    export type PageSize = number;
    /** The ID of the role. */
    export type RoleID = string;
    /** The ID of the security filter. */
    export type SecurityFilterID = string;
    /** The ID of the rule. */
    export type SecurityMonitoringRuleID = string;
    /** The ID of the service account. */
    export type ServiceAccountID = string;
    /** The ID of the user. */
    export type UserID = string;
}
export namespace RequestBodies { }
export interface Parameter$ListAPIKeys {
    /** Size for a given page. */
    "page[size]"?: Parameters.PageSize;
    /** Specific page number to return. */
    "page[number]"?: Parameters.PageNumber;
    /**
     * API key attribute used to sort results. Sort order is ascending
     * by default. In order to specify a descending sort, prefix the
     * attribute with a minus sign.
     */
    sort?: Parameters.APIKeysSortParameter;
    /** Filter API keys by the specified string. */
    filter?: Parameters.APIKeyFilterParameter;
    /** Only include API keys created on or after the specified date. */
    "filter[created_at][start]"?: Parameters.APIKeyFilterCreatedAtStartParameter;
    /** Only include API keys created on or before the specified date. */
    "filter[created_at][end]"?: Parameters.APIKeyFilterCreatedAtEndParameter;
    /** Only include API keys modified on or after the specified date. */
    "filter[modified_at][start]"?: Parameters.APIKeyFilterModifiedAtStartParameter;
    /** Only include API keys modified on or before the specified date. */
    "filter[modified_at][end]"?: Parameters.APIKeyFilterModifiedAtEndParameter;
    /** Comma separated list of resource paths for related resources to include in the response. Supported resource paths are `created_by` and `modified_by`. */
    include?: Parameters.APIKeyIncludeParameter;
}
export interface Response$ListAPIKeys$Status$200 {
    "application/json": Schemas.APIKeysResponse;
}
export interface Response$ListAPIKeys$Status$400 {
    "application/json": Schemas.APIErrorResponse;
}
export interface Response$ListAPIKeys$Status$403 {
    "application/json": Schemas.APIErrorResponse;
}
export type Response$ListAPIKeys$Status$429 = Responses.TooManyRequestsResponse.Content;
export interface RequestBody$CreateAPIKey {
    "application/json": Schemas.APIKeyCreateRequest;
}
export interface Response$CreateAPIKey$Status$201 {
    "application/json": Schemas.APIKeyResponse;
}
export interface Response$CreateAPIKey$Status$400 {
    "application/json": Schemas.APIErrorResponse;
}
export interface Response$CreateAPIKey$Status$403 {
    "application/json": Schemas.APIErrorResponse;
}
export type Response$CreateAPIKey$Status$429 = Responses.TooManyRequestsResponse.Content;
export interface Parameter$GetAPIKey {
    /** The ID of the API key. */
    api_key_id: Parameters.APIKeyId;
    /** Comma separated list of resource paths for related resources to include in the response. Supported resource paths are `created_by` and `modified_by`. */
    include?: Parameters.APIKeyIncludeParameter;
}
export interface Response$GetAPIKey$Status$200 {
    "application/json": Schemas.APIKeyResponse;
}
export interface Response$GetAPIKey$Status$403 {
    "application/json": Schemas.APIErrorResponse;
}
export interface Response$GetAPIKey$Status$404 {
    "application/json": Schemas.APIErrorResponse;
}
export type Response$GetAPIKey$Status$429 = Responses.TooManyRequestsResponse.Content;
export interface Parameter$DeleteAPIKey {
    /** The ID of the API key. */
    api_key_id: Parameters.APIKeyId;
}
export interface Response$DeleteAPIKey$Status$403 {
    "application/json": Schemas.APIErrorResponse;
}
export interface Response$DeleteAPIKey$Status$404 {
    "application/json": Schemas.APIErrorResponse;
}
export type Response$DeleteAPIKey$Status$429 = Responses.TooManyRequestsResponse.Content;
export interface Parameter$UpdateAPIKey {
    /** The ID of the API key. */
    api_key_id: Parameters.APIKeyId;
}
export interface RequestBody$UpdateAPIKey {
    "application/json": Schemas.APIKeyUpdateRequest;
}
export interface Response$UpdateAPIKey$Status$200 {
    "application/json": Schemas.APIKeyResponse;
}
export interface Response$UpdateAPIKey$Status$400 {
    "application/json": Schemas.APIErrorResponse;
}
export interface Response$UpdateAPIKey$Status$403 {
    "application/json": Schemas.APIErrorResponse;
}
export interface Response$UpdateAPIKey$Status$404 {
    "application/json": Schemas.APIErrorResponse;
}
export type Response$UpdateAPIKey$Status$429 = Responses.TooManyRequestsResponse.Content;
export interface Parameter$ListApplicationKeys {
    /** Size for a given page. */
    "page[size]"?: Parameters.PageSize;
    /** Specific page number to return. */
    "page[number]"?: Parameters.PageNumber;
    /**
     * Application key attribute used to sort results. Sort order is ascending
     * by default. In order to specify a descending sort, prefix the
     * attribute with a minus sign.
     */
    sort?: Parameters.ApplicationKeysSortParameter;
    /** Filter application keys by the specified string. */
    filter?: Parameters.ApplicationKeyFilterParameter;
    /** Only include application keys created on or after the specified date. */
    "filter[created_at][start]"?: Parameters.ApplicationKeyFilterCreatedAtStartParameter;
    /** Only include application keys created on or before the specified date. */
    "filter[created_at][end]"?: Parameters.ApplicationKeyFilterCreatedAtEndParameter;
}
export interface Response$ListApplicationKeys$Status$200 {
    "application/json": Schemas.ListApplicationKeysResponse;
}
export interface Response$ListApplicationKeys$Status$400 {
    "application/json": Schemas.APIErrorResponse;
}
export interface Response$ListApplicationKeys$Status$403 {
    "application/json": Schemas.APIErrorResponse;
}
export interface Response$ListApplicationKeys$Status$404 {
    "application/json": Schemas.APIErrorResponse;
}
export type Response$ListApplicationKeys$Status$429 = Responses.TooManyRequestsResponse.Content;
export interface Parameter$GetApplicationKey {
    /** The ID of the application key. */
    app_key_id: Parameters.ApplicationKeyID;
    /** Resource path for related resources to include in the response. Only `owned_by` is supported. */
    include?: Parameters.ApplicationKeyIncludeParameter;
}
export interface Response$GetApplicationKey$Status$200 {
    "application/json": Schemas.ApplicationKeyResponse;
}
export interface Response$GetApplicationKey$Status$400 {
    "application/json": Schemas.APIErrorResponse;
}
export interface Response$GetApplicationKey$Status$403 {
    "application/json": Schemas.APIErrorResponse;
}
export interface Response$GetApplicationKey$Status$404 {
    "application/json": Schemas.APIErrorResponse;
}
export type Response$GetApplicationKey$Status$429 = Responses.TooManyRequestsResponse.Content;
export interface Parameter$DeleteApplicationKey {
    /** The ID of the application key. */
    app_key_id: Parameters.ApplicationKeyID;
}
export interface Response$DeleteApplicationKey$Status$403 {
    "application/json": Schemas.APIErrorResponse;
}
export interface Response$DeleteApplicationKey$Status$404 {
    "application/json": Schemas.APIErrorResponse;
}
export type Response$DeleteApplicationKey$Status$429 = Responses.TooManyRequestsResponse.Content;
export interface Parameter$UpdateApplicationKey {
    /** The ID of the application key. */
    app_key_id: Parameters.ApplicationKeyID;
}
export interface RequestBody$UpdateApplicationKey {
    "application/json": Schemas.ApplicationKeyUpdateRequest;
}
export interface Response$UpdateApplicationKey$Status$200 {
    "application/json": Schemas.ApplicationKeyResponse;
}
export interface Response$UpdateApplicationKey$Status$400 {
    "application/json": Schemas.APIErrorResponse;
}
export interface Response$UpdateApplicationKey$Status$403 {
    "application/json": Schemas.APIErrorResponse;
}
export interface Response$UpdateApplicationKey$Status$404 {
    "application/json": Schemas.APIErrorResponse;
}
export type Response$UpdateApplicationKey$Status$429 = Responses.TooManyRequestsResponse.Content;
export interface Parameter$ListAuthNMappings {
    /** Size for a given page. */
    "page[size]"?: Parameters.PageSize;
    /** Specific page number to return. */
    "page[number]"?: Parameters.PageNumber;
    /** Sort AuthN Mappings depending on the given field. */
    sort?: Schemas.AuthNMappingsSort;
    /** Include additional information in the response. */
    include?: string[];
    /** Filter all mappings by the given string. */
    filter?: string;
}
export interface Response$ListAuthNMappings$Status$200 {
    "application/json": Schemas.AuthNMappingsResponse;
}
export interface Response$ListAuthNMappings$Status$403 {
    "application/json": Schemas.APIErrorResponse;
}
export type Response$ListAuthNMappings$Status$429 = Responses.TooManyRequestsResponse.Content;
export interface RequestBody$CreateAuthNMapping {
    "application/json": Schemas.AuthNMappingCreateRequest;
}
export interface Response$CreateAuthNMapping$Status$200 {
    "application/json": Schemas.AuthNMappingResponse;
}
export interface Response$CreateAuthNMapping$Status$400 {
    "application/json": Schemas.APIErrorResponse;
}
export interface Response$CreateAuthNMapping$Status$403 {
    "application/json": Schemas.APIErrorResponse;
}
export interface Response$CreateAuthNMapping$Status$404 {
    "application/json": Schemas.APIErrorResponse;
}
export type Response$CreateAuthNMapping$Status$429 = Responses.TooManyRequestsResponse.Content;
export interface Parameter$GetAuthNMapping {
    /** The UUID of the AuthN Mapping. */
    authn_mapping_id: Parameters.AuthNMappingID;
}
export interface Response$GetAuthNMapping$Status$200 {
    "application/json": Schemas.AuthNMappingResponse;
}
export interface Response$GetAuthNMapping$Status$403 {
    "application/json": Schemas.APIErrorResponse;
}
export interface Response$GetAuthNMapping$Status$404 {
    "application/json": Schemas.APIErrorResponse;
}
export type Response$GetAuthNMapping$Status$429 = Responses.TooManyRequestsResponse.Content;
export interface Parameter$DeleteAuthNMapping {
    /** The UUID of the AuthN Mapping. */
    authn_mapping_id: Parameters.AuthNMappingID;
}
export interface Response$DeleteAuthNMapping$Status$403 {
    "application/json": Schemas.APIErrorResponse;
}
export interface Response$DeleteAuthNMapping$Status$404 {
    "application/json": Schemas.APIErrorResponse;
}
export type Response$DeleteAuthNMapping$Status$429 = Responses.TooManyRequestsResponse.Content;
export interface Parameter$UpdateAuthNMapping {
    /** The UUID of the AuthN Mapping. */
    authn_mapping_id: Parameters.AuthNMappingID;
}
export interface RequestBody$UpdateAuthNMapping {
    "application/json": Schemas.AuthNMappingUpdateRequest;
}
export interface Response$UpdateAuthNMapping$Status$200 {
    "application/json": Schemas.AuthNMappingResponse;
}
export interface Response$UpdateAuthNMapping$Status$400 {
    "application/json": Schemas.APIErrorResponse;
}
export interface Response$UpdateAuthNMapping$Status$403 {
    "application/json": Schemas.APIErrorResponse;
}
export interface Response$UpdateAuthNMapping$Status$404 {
    "application/json": Schemas.APIErrorResponse;
}
export interface Response$UpdateAuthNMapping$Status$409 {
    "application/json": Schemas.APIErrorResponse;
}
export interface Response$UpdateAuthNMapping$Status$422 {
    "application/json": Schemas.APIErrorResponse;
}
export type Response$UpdateAuthNMapping$Status$429 = Responses.TooManyRequestsResponse.Content;
export interface Parameter$ListCurrentUserApplicationKeys {
    /** Size for a given page. */
    "page[size]"?: Parameters.PageSize;
    /** Specific page number to return. */
    "page[number]"?: Parameters.PageNumber;
    /**
     * Application key attribute used to sort results. Sort order is ascending
     * by default. In order to specify a descending sort, prefix the
     * attribute with a minus sign.
     */
    sort?: Parameters.ApplicationKeysSortParameter;
    /** Filter application keys by the specified string. */
    filter?: Parameters.ApplicationKeyFilterParameter;
    /** Only include application keys created on or after the specified date. */
    "filter[created_at][start]"?: Parameters.ApplicationKeyFilterCreatedAtStartParameter;
    /** Only include application keys created on or before the specified date. */
    "filter[created_at][end]"?: Parameters.ApplicationKeyFilterCreatedAtEndParameter;
}
export interface Response$ListCurrentUserApplicationKeys$Status$200 {
    "application/json": Schemas.ListApplicationKeysResponse;
}
export interface Response$ListCurrentUserApplicationKeys$Status$400 {
    "application/json": Schemas.APIErrorResponse;
}
export interface Response$ListCurrentUserApplicationKeys$Status$403 {
    "application/json": Schemas.APIErrorResponse;
}
export interface Response$ListCurrentUserApplicationKeys$Status$404 {
    "application/json": Schemas.APIErrorResponse;
}
export type Response$ListCurrentUserApplicationKeys$Status$429 = Responses.TooManyRequestsResponse.Content;
export interface RequestBody$CreateCurrentUserApplicationKey {
    "application/json": Schemas.ApplicationKeyCreateRequest;
}
export interface Response$CreateCurrentUserApplicationKey$Status$201 {
    "application/json": Schemas.ApplicationKeyResponse;
}
export interface Response$CreateCurrentUserApplicationKey$Status$400 {
    "application/json": Schemas.APIErrorResponse;
}
export interface Response$CreateCurrentUserApplicationKey$Status$403 {
    "application/json": Schemas.APIErrorResponse;
}
export type Response$CreateCurrentUserApplicationKey$Status$429 = Responses.TooManyRequestsResponse.Content;
export interface Parameter$GetCurrentUserApplicationKey {
    /** The ID of the application key. */
    app_key_id: Parameters.ApplicationKeyID;
}
export interface Response$GetCurrentUserApplicationKey$Status$200 {
    "application/json": Schemas.ApplicationKeyResponse;
}
export interface Response$GetCurrentUserApplicationKey$Status$403 {
    "application/json": Schemas.APIErrorResponse;
}
export interface Response$GetCurrentUserApplicationKey$Status$404 {
    "application/json": Schemas.APIErrorResponse;
}
export type Response$GetCurrentUserApplicationKey$Status$429 = Responses.TooManyRequestsResponse.Content;
export interface Parameter$DeleteCurrentUserApplicationKey {
    /** The ID of the application key. */
    app_key_id: Parameters.ApplicationKeyID;
}
export interface Response$DeleteCurrentUserApplicationKey$Status$403 {
    "application/json": Schemas.APIErrorResponse;
}
export interface Response$DeleteCurrentUserApplicationKey$Status$404 {
    "application/json": Schemas.APIErrorResponse;
}
export type Response$DeleteCurrentUserApplicationKey$Status$429 = Responses.TooManyRequestsResponse.Content;
export interface Parameter$UpdateCurrentUserApplicationKey {
    /** The ID of the application key. */
    app_key_id: Parameters.ApplicationKeyID;
}
export interface RequestBody$UpdateCurrentUserApplicationKey {
    "application/json": Schemas.ApplicationKeyUpdateRequest;
}
export interface Response$UpdateCurrentUserApplicationKey$Status$200 {
    "application/json": Schemas.ApplicationKeyResponse;
}
export interface Response$UpdateCurrentUserApplicationKey$Status$400 {
    "application/json": Schemas.APIErrorResponse;
}
export interface Response$UpdateCurrentUserApplicationKey$Status$403 {
    "application/json": Schemas.APIErrorResponse;
}
export interface Response$UpdateCurrentUserApplicationKey$Status$404 {
    "application/json": Schemas.APIErrorResponse;
}
export type Response$UpdateCurrentUserApplicationKey$Status$429 = Responses.TooManyRequestsResponse.Content;
export interface Parameter$GetDashboardListItems {
    /** ID of the dashboard list to get items from. */
    dashboard_list_id: number;
}
export interface Response$GetDashboardListItems$Status$200 {
    "application/json": Schemas.DashboardListItems;
}
export interface Response$GetDashboardListItems$Status$403 {
    "application/json": Schemas.APIErrorResponse;
}
export interface Response$GetDashboardListItems$Status$404 {
    "application/json": Schemas.APIErrorResponse;
}
export type Response$GetDashboardListItems$Status$429 = Responses.TooManyRequestsResponse.Content;
export interface Parameter$UpdateDashboardListItems {
    /** ID of the dashboard list to update items from. */
    dashboard_list_id: number;
}
export interface RequestBody$UpdateDashboardListItems {
    "application/json": Schemas.DashboardListUpdateItemsRequest;
}
export interface Response$UpdateDashboardListItems$Status$200 {
    "application/json": Schemas.DashboardListUpdateItemsResponse;
}
export interface Response$UpdateDashboardListItems$Status$400 {
    "application/json": Schemas.APIErrorResponse;
}
export interface Response$UpdateDashboardListItems$Status$403 {
    "application/json": Schemas.APIErrorResponse;
}
export interface Response$UpdateDashboardListItems$Status$404 {
    "application/json": Schemas.APIErrorResponse;
}
export type Response$UpdateDashboardListItems$Status$429 = Responses.TooManyRequestsResponse.Content;
export interface Parameter$CreateDashboardListItems {
    /** ID of the dashboard list to add items to. */
    dashboard_list_id: number;
}
export interface RequestBody$CreateDashboardListItems {
    "application/json": Schemas.DashboardListAddItemsRequest;
}
export interface Response$CreateDashboardListItems$Status$200 {
    "application/json": Schemas.DashboardListAddItemsResponse;
}
export interface Response$CreateDashboardListItems$Status$400 {
    "application/json": Schemas.APIErrorResponse;
}
export interface Response$CreateDashboardListItems$Status$403 {
    "application/json": Schemas.APIErrorResponse;
}
export interface Response$CreateDashboardListItems$Status$404 {
    "application/json": Schemas.APIErrorResponse;
}
export type Response$CreateDashboardListItems$Status$429 = Responses.TooManyRequestsResponse.Content;
export interface Parameter$DeleteDashboardListItems {
    /** ID of the dashboard list to delete items from. */
    dashboard_list_id: number;
}
export interface RequestBody$DeleteDashboardListItems {
    "application/json": Schemas.DashboardListDeleteItemsRequest;
}
export interface Response$DeleteDashboardListItems$Status$200 {
    "application/json": Schemas.DashboardListDeleteItemsResponse;
}
export interface Response$DeleteDashboardListItems$Status$400 {
    "application/json": Schemas.APIErrorResponse;
}
export interface Response$DeleteDashboardListItems$Status$403 {
    "application/json": Schemas.APIErrorResponse;
}
export interface Response$DeleteDashboardListItems$Status$404 {
    "application/json": Schemas.APIErrorResponse;
}
export type Response$DeleteDashboardListItems$Status$429 = Responses.TooManyRequestsResponse.Content;
export interface Parameter$ListIncidents {
    /** Specifies which types of related objects should be included in the response. */
    include?: Parameters.IncidentIncludeQueryParameter;
    /** Size for a given page. */
    "page[size]"?: Parameters.PageSize;
    /** Specific offset to use as the beginning of the returned page. */
    "page[offset]"?: Parameters.PageOffset;
}
export interface Response$ListIncidents$Status$200 {
    "application/json": Schemas.IncidentsResponse;
}
export type Response$ListIncidents$Status$400 = Responses.BadRequestResponse.Content;
export type Response$ListIncidents$Status$401 = Responses.UnauthorizedResponse.Content;
export type Response$ListIncidents$Status$403 = Responses.ForbiddenResponse.Content;
export type Response$ListIncidents$Status$404 = Responses.NotFoundResponse.Content;
export type Response$ListIncidents$Status$429 = Responses.TooManyRequestsResponse.Content;
export interface RequestBody$CreateIncident {
    "application/json": Schemas.IncidentCreateRequest;
}
export interface Response$CreateIncident$Status$201 {
    "application/json": Schemas.IncidentResponse;
}
export type Response$CreateIncident$Status$400 = Responses.BadRequestResponse.Content;
export type Response$CreateIncident$Status$401 = Responses.UnauthorizedResponse.Content;
export type Response$CreateIncident$Status$403 = Responses.ForbiddenResponse.Content;
export type Response$CreateIncident$Status$404 = Responses.NotFoundResponse.Content;
export type Response$CreateIncident$Status$429 = Responses.TooManyRequestsResponse.Content;
export interface Parameter$GetIncident {
    /** The UUID of the incident. */
    incident_id: Parameters.IncidentIDPathParameter;
    /** Specifies which types of related objects should be included in the response. */
    include?: Parameters.IncidentIncludeQueryParameter;
}
export interface Response$GetIncident$Status$200 {
    "application/json": Schemas.IncidentResponse;
}
export type Response$GetIncident$Status$400 = Responses.BadRequestResponse.Content;
export type Response$GetIncident$Status$401 = Responses.UnauthorizedResponse.Content;
export type Response$GetIncident$Status$403 = Responses.ForbiddenResponse.Content;
export type Response$GetIncident$Status$404 = Responses.NotFoundResponse.Content;
export type Response$GetIncident$Status$429 = Responses.TooManyRequestsResponse.Content;
export interface Parameter$DeleteIncident {
    /** The UUID of the incident. */
    incident_id: Parameters.IncidentIDPathParameter;
}
export type Response$DeleteIncident$Status$400 = Responses.BadRequestResponse.Content;
export type Response$DeleteIncident$Status$401 = Responses.UnauthorizedResponse.Content;
export type Response$DeleteIncident$Status$403 = Responses.ForbiddenResponse.Content;
export type Response$DeleteIncident$Status$404 = Responses.NotFoundResponse.Content;
export type Response$DeleteIncident$Status$429 = Responses.TooManyRequestsResponse.Content;
export interface Parameter$UpdateIncident {
    /** The UUID of the incident. */
    incident_id: Parameters.IncidentIDPathParameter;
    /** Specifies which types of related objects should be included in the response. */
    include?: Parameters.IncidentIncludeQueryParameter;
}
export interface RequestBody$UpdateIncident {
    "application/json": Schemas.IncidentUpdateRequest;
}
export interface Response$UpdateIncident$Status$200 {
    "application/json": Schemas.IncidentResponse;
}
export type Response$UpdateIncident$Status$400 = Responses.BadRequestResponse.Content;
export type Response$UpdateIncident$Status$401 = Responses.UnauthorizedResponse.Content;
export type Response$UpdateIncident$Status$403 = Responses.ForbiddenResponse.Content;
export type Response$UpdateIncident$Status$404 = Responses.NotFoundResponse.Content;
export type Response$UpdateIncident$Status$429 = Responses.TooManyRequestsResponse.Content;
export interface Parameter$SubmitLog {
    /** HTTP header used to compress the media-type. */
    "Content-Encoding"?: Schemas.ContentEncoding;
    /** Log tags can be passed as query parameters with `text/plain` content type. */
    ddtags?: string;
}
export interface RequestBody$SubmitLog {
    "application/json": Schemas.HTTPLog;
    "application/logplex-1": string;
    "text/plain": string;
}
export interface Response$SubmitLog$Status$202 {
    "application/json": {};
}
export interface Response$SubmitLog$Status$400 {
    "application/json": Schemas.HTTPLogErrors;
}
export interface Response$SubmitLog$Status$401 {
    "application/json": Schemas.HTTPLogErrors;
}
export interface Response$SubmitLog$Status$403 {
    "application/json": Schemas.HTTPLogErrors;
}
export interface Response$SubmitLog$Status$408 {
    "application/json": Schemas.HTTPLogErrors;
}
export interface Response$SubmitLog$Status$413 {
    "application/json": Schemas.HTTPLogErrors;
}
export interface Response$SubmitLog$Status$429 {
    "application/json": Schemas.HTTPLogErrors;
}
export interface Response$SubmitLog$Status$500 {
    "application/json": Schemas.HTTPLogErrors;
}
export interface Response$SubmitLog$Status$503 {
    "application/json": Schemas.HTTPLogErrors;
}
export interface RequestBody$AggregateLogs {
    "application/json": Schemas.LogsAggregateRequest;
}
export interface Response$AggregateLogs$Status$200 {
    "application/json": Schemas.LogsAggregateResponse;
}
export type Response$AggregateLogs$Status$400 = Responses.BadRequestResponse.Content;
export type Response$AggregateLogs$Status$403 = Responses.NotAuthorizedResponse.Content;
export type Response$AggregateLogs$Status$429 = Responses.TooManyRequestsResponse.Content;
export interface Response$GetLogsArchiveOrder$Status$200 {
    "application/json": Schemas.LogsArchiveOrder;
}
export interface Response$GetLogsArchiveOrder$Status$403 {
    "application/json": Schemas.APIErrorResponse;
}
export type Response$GetLogsArchiveOrder$Status$429 = Responses.TooManyRequestsResponse.Content;
export interface RequestBody$UpdateLogsArchiveOrder {
    "application/json": Schemas.LogsArchiveOrder;
}
export interface Response$UpdateLogsArchiveOrder$Status$200 {
    "application/json": Schemas.LogsArchiveOrder;
}
export interface Response$UpdateLogsArchiveOrder$Status$400 {
    "application/json": Schemas.APIErrorResponse;
}
export interface Response$UpdateLogsArchiveOrder$Status$403 {
    "application/json": Schemas.APIErrorResponse;
}
export interface Response$UpdateLogsArchiveOrder$Status$422 {
    "application/json": Schemas.APIErrorResponse;
}
export type Response$UpdateLogsArchiveOrder$Status$429 = Responses.TooManyRequestsResponse.Content;
export interface Response$ListLogsArchives$Status$200 {
    "application/json": Schemas.LogsArchives;
}
export interface Response$ListLogsArchives$Status$403 {
    "application/json": Schemas.APIErrorResponse;
}
export type Response$ListLogsArchives$Status$429 = Responses.TooManyRequestsResponse.Content;
export interface RequestBody$CreateLogsArchive {
    "application/json": Schemas.LogsArchiveCreateRequest;
}
export interface Response$CreateLogsArchive$Status$200 {
    "application/json": Schemas.LogsArchive;
}
export interface Response$CreateLogsArchive$Status$400 {
    "application/json": Schemas.APIErrorResponse;
}
export interface Response$CreateLogsArchive$Status$403 {
    "application/json": Schemas.APIErrorResponse;
}
export type Response$CreateLogsArchive$Status$429 = Responses.TooManyRequestsResponse.Content;
export interface Parameter$GetLogsArchive {
    /** The ID of the archive. */
    archive_id: Parameters.ArchiveID;
}
export interface Response$GetLogsArchive$Status$200 {
    "application/json": Schemas.LogsArchive;
}
export interface Response$GetLogsArchive$Status$400 {
    "application/json": Schemas.APIErrorResponse;
}
export interface Response$GetLogsArchive$Status$403 {
    "application/json": Schemas.APIErrorResponse;
}
export interface Response$GetLogsArchive$Status$404 {
    "application/json": Schemas.APIErrorResponse;
}
export type Response$GetLogsArchive$Status$429 = Responses.TooManyRequestsResponse.Content;
export interface Parameter$UpdateLogsArchive {
    /** The ID of the archive. */
    archive_id: Parameters.ArchiveID;
}
export interface RequestBody$UpdateLogsArchive {
    "application/json": Schemas.LogsArchiveCreateRequest;
}
export interface Response$UpdateLogsArchive$Status$200 {
    "application/json": Schemas.LogsArchive;
}
export interface Response$UpdateLogsArchive$Status$400 {
    "application/json": Schemas.APIErrorResponse;
}
export interface Response$UpdateLogsArchive$Status$403 {
    "application/json": Schemas.APIErrorResponse;
}
export interface Response$UpdateLogsArchive$Status$404 {
    "application/json": Schemas.APIErrorResponse;
}
export type Response$UpdateLogsArchive$Status$429 = Responses.TooManyRequestsResponse.Content;
export interface Parameter$DeleteLogsArchive {
    /** The ID of the archive. */
    archive_id: Parameters.ArchiveID;
}
export interface Response$DeleteLogsArchive$Status$400 {
    "application/json": Schemas.APIErrorResponse;
}
export interface Response$DeleteLogsArchive$Status$403 {
    "application/json": Schemas.APIErrorResponse;
}
export interface Response$DeleteLogsArchive$Status$404 {
    "application/json": Schemas.APIErrorResponse;
}
export type Response$DeleteLogsArchive$Status$429 = Responses.TooManyRequestsResponse.Content;
export interface Parameter$ListArchiveReadRoles {
    /** The ID of the archive. */
    archive_id: Parameters.ArchiveID;
}
export interface Response$ListArchiveReadRoles$Status$200 {
    "application/json": Schemas.RolesResponse;
}
export interface Response$ListArchiveReadRoles$Status$400 {
    "application/json": Schemas.APIErrorResponse;
}
export interface Response$ListArchiveReadRoles$Status$403 {
    "application/json": Schemas.APIErrorResponse;
}
export interface Response$ListArchiveReadRoles$Status$404 {
    "application/json": Schemas.APIErrorResponse;
}
export type Response$ListArchiveReadRoles$Status$429 = Responses.TooManyRequestsResponse.Content;
export interface Parameter$AddReadRoleToArchive {
    /** The ID of the archive. */
    archive_id: Parameters.ArchiveID;
}
export interface RequestBody$AddReadRoleToArchive {
    "application/json": Schemas.RelationshipToRole;
}
export interface Response$AddReadRoleToArchive$Status$400 {
    "application/json": Schemas.APIErrorResponse;
}
export interface Response$AddReadRoleToArchive$Status$403 {
    "application/json": Schemas.APIErrorResponse;
}
export interface Response$AddReadRoleToArchive$Status$404 {
    "application/json": Schemas.APIErrorResponse;
}
export type Response$AddReadRoleToArchive$Status$429 = Responses.TooManyRequestsResponse.Content;
export interface Parameter$RemoveRoleFromArchive {
    /** The ID of the archive. */
    archive_id: Parameters.ArchiveID;
}
export interface RequestBody$RemoveRoleFromArchive {
    "application/json": Schemas.RelationshipToRole;
}
export interface Response$RemoveRoleFromArchive$Status$400 {
    "application/json": Schemas.APIErrorResponse;
}
export interface Response$RemoveRoleFromArchive$Status$403 {
    "application/json": Schemas.APIErrorResponse;
}
export interface Response$RemoveRoleFromArchive$Status$404 {
    "application/json": Schemas.APIErrorResponse;
}
export type Response$RemoveRoleFromArchive$Status$429 = Responses.TooManyRequestsResponse.Content;
export interface Response$ListLogsMetrics$Status$200 {
    "application/json": Schemas.LogsMetricsResponse;
}
export type Response$ListLogsMetrics$Status$403 = Responses.NotAuthorizedResponse.Content;
export type Response$ListLogsMetrics$Status$429 = Responses.TooManyRequestsResponse.Content;
export interface RequestBody$CreateLogsMetric {
    "application/json": Schemas.LogsMetricCreateRequest;
}
export interface Response$CreateLogsMetric$Status$200 {
    "application/json": Schemas.LogsMetricResponse;
}
export type Response$CreateLogsMetric$Status$400 = Responses.BadRequestResponse.Content;
export type Response$CreateLogsMetric$Status$403 = Responses.NotAuthorizedResponse.Content;
export type Response$CreateLogsMetric$Status$409 = Responses.ConflictResponse.Content;
export type Response$CreateLogsMetric$Status$429 = Responses.TooManyRequestsResponse.Content;
export interface Parameter$GetLogsMetric {
    /** The name of the log-based metric. */
    metric_id: Parameters.MetricID;
}
export interface Response$GetLogsMetric$Status$200 {
    "application/json": Schemas.LogsMetricResponse;
}
export type Response$GetLogsMetric$Status$403 = Responses.NotAuthorizedResponse.Content;
export type Response$GetLogsMetric$Status$404 = Responses.NotFoundResponse.Content;
export type Response$GetLogsMetric$Status$429 = Responses.TooManyRequestsResponse.Content;
export interface Parameter$DeleteLogsMetric {
    /** The name of the log-based metric. */
    metric_id: Parameters.MetricID;
}
export type Response$DeleteLogsMetric$Status$403 = Responses.NotAuthorizedResponse.Content;
export type Response$DeleteLogsMetric$Status$404 = Responses.NotFoundResponse.Content;
export type Response$DeleteLogsMetric$Status$429 = Responses.TooManyRequestsResponse.Content;
export interface Parameter$UpdateLogsMetric {
    /** The name of the log-based metric. */
    metric_id: Parameters.MetricID;
}
export interface RequestBody$UpdateLogsMetric {
    "application/json": Schemas.LogsMetricUpdateRequest;
}
export interface Response$UpdateLogsMetric$Status$200 {
    "application/json": Schemas.LogsMetricResponse;
}
export type Response$UpdateLogsMetric$Status$400 = Responses.BadRequestResponse.Content;
export type Response$UpdateLogsMetric$Status$403 = Responses.NotAuthorizedResponse.Content;
export type Response$UpdateLogsMetric$Status$404 = Responses.NotFoundResponse.Content;
export type Response$UpdateLogsMetric$Status$429 = Responses.TooManyRequestsResponse.Content;
export interface Parameter$ListLogsGet {
    /** Search query following logs syntax. */
    "filter[query]"?: string;
    /**
     * For customers with multiple indexes, the indexes to search
     * Defaults to '*' which means all indexes
     */
    "filter[index]"?: string;
    /** Minimum timestamp for requested logs. */
    "filter[from]"?: string;
    /** Maximum timestamp for requested logs. */
    "filter[to]"?: string;
    /** Order of logs in results. */
    sort?: Schemas.LogsSort;
    /** List following results with a cursor provided in the previous query. */
    "page[cursor]"?: string;
    /** Maximum number of logs in the response. */
    "page[limit]"?: number;
}
export interface Response$ListLogsGet$Status$200 {
    "application/json": Schemas.LogsListResponse;
}
export type Response$ListLogsGet$Status$400 = Responses.BadRequestResponse.Content;
export type Response$ListLogsGet$Status$403 = Responses.NotAuthorizedResponse.Content;
export type Response$ListLogsGet$Status$429 = Responses.TooManyRequestsResponse.Content;
export interface RequestBody$ListLogs {
    "application/json": Schemas.LogsListRequest;
}
export interface Response$ListLogs$Status$200 {
    "application/json": Schemas.LogsListResponse;
}
export type Response$ListLogs$Status$400 = Responses.BadRequestResponse.Content;
export type Response$ListLogs$Status$403 = Responses.NotAuthorizedResponse.Content;
export type Response$ListLogs$Status$429 = Responses.TooManyRequestsResponse.Content;
export interface Parameter$ListTagConfigurations {
    /** Filter metrics that have configured tags. */
    "filter[configured]"?: boolean;
    /** Filter tag configurations by configured tags. */
    "filter[tags_configured]"?: string;
    /** Filter tag configurations by metric type. */
    "filter[metric_type]"?: Schemas.MetricTagConfigurationMetricTypes;
    /**
     * Filter distributions with additional percentile
     * aggregations enabled or disabled.
     */
    "filter[include_percentiles]"?: boolean;
    /**
     * Filter metrics that have been submitted with the given tags. Supports boolean and wildcard expressions.
     * Cannot be combined with other filters.
     */
    "filter[tags]"?: string;
    /**
     * The number of seconds of look back (from now) to apply to a filter[tag] query.
     * Defaults value is 3600 (1 hour), maximum value is 172,800 (2 days).
     */
    "window[seconds]"?: number;
}
export interface Response$ListTagConfigurations$Status$200 {
    "application/json": Schemas.MetricsAndMetricTagConfigurationsResponse;
}
export interface Response$ListTagConfigurations$Status$400 {
    "application/json": Schemas.APIErrorResponse;
}
export interface Response$ListTagConfigurations$Status$403 {
    "application/json": Schemas.APIErrorResponse;
}
export interface Response$ListTagConfigurations$Status$429 {
    "application/json": Schemas.APIErrorResponse;
}
export interface RequestBody$CreateBulkTagsMetricsConfiguration {
    "application/json": Schemas.MetricBulkTagConfigCreateRequest;
}
export interface Response$CreateBulkTagsMetricsConfiguration$Status$202 {
    "application/json": Schemas.MetricBulkTagConfigResponse;
}
export interface Response$CreateBulkTagsMetricsConfiguration$Status$400 {
    "application/json": Schemas.APIErrorResponse;
}
export interface Response$CreateBulkTagsMetricsConfiguration$Status$403 {
    "application/json": Schemas.APIErrorResponse;
}
export interface Response$CreateBulkTagsMetricsConfiguration$Status$404 {
    "application/json": Schemas.APIErrorResponse;
}
export interface Response$CreateBulkTagsMetricsConfiguration$Status$429 {
    "application/json": Schemas.APIErrorResponse;
}
export interface RequestBody$DeleteBulkTagsMetricsConfiguration {
    "application/json": Schemas.MetricBulkTagConfigDeleteRequest;
}
export interface Response$DeleteBulkTagsMetricsConfiguration$Status$202 {
    "application/json": Schemas.MetricBulkTagConfigResponse;
}
export interface Response$DeleteBulkTagsMetricsConfiguration$Status$400 {
    "application/json": Schemas.APIErrorResponse;
}
export interface Response$DeleteBulkTagsMetricsConfiguration$Status$403 {
    "application/json": Schemas.APIErrorResponse;
}
export interface Response$DeleteBulkTagsMetricsConfiguration$Status$404 {
    "application/json": Schemas.APIErrorResponse;
}
export interface Response$DeleteBulkTagsMetricsConfiguration$Status$429 {
    "application/json": Schemas.APIErrorResponse;
}
export interface Parameter$ListTagsByMetricName {
    /** The name of the metric. */
    metric_name: Parameters.MetricName;
}
export interface Response$ListTagsByMetricName$Status$200 {
    "application/json": Schemas.MetricAllTagsResponse;
}
export interface Response$ListTagsByMetricName$Status$400 {
    "application/json": Schemas.APIErrorResponse;
}
export interface Response$ListTagsByMetricName$Status$403 {
    "application/json": Schemas.APIErrorResponse;
}
export interface Response$ListTagsByMetricName$Status$404 {
    "application/json": Schemas.APIErrorResponse;
}
export interface Response$ListTagsByMetricName$Status$429 {
    "application/json": Schemas.APIErrorResponse;
}
export interface Parameter$ListTagConfigurationByName {
    /** The name of the metric. */
    metric_name: Parameters.MetricName;
}
export interface Response$ListTagConfigurationByName$Status$200 {
    "application/json": Schemas.MetricTagConfigurationResponse;
}
export interface Response$ListTagConfigurationByName$Status$403 {
    "application/json": Schemas.APIErrorResponse;
}
export interface Response$ListTagConfigurationByName$Status$404 {
    "application/json": Schemas.APIErrorResponse;
}
export interface Response$ListTagConfigurationByName$Status$429 {
    "application/json": Schemas.APIErrorResponse;
}
export interface Parameter$CreateTagConfiguration {
    /** The name of the metric. */
    metric_name: Parameters.MetricName;
}
export interface RequestBody$CreateTagConfiguration {
    "application/json": Schemas.MetricTagConfigurationCreateRequest;
}
export interface Response$CreateTagConfiguration$Status$201 {
    "application/json": Schemas.MetricTagConfigurationResponse;
}
export interface Response$CreateTagConfiguration$Status$400 {
    "application/json": Schemas.APIErrorResponse;
}
export interface Response$CreateTagConfiguration$Status$403 {
    "application/json": Schemas.APIErrorResponse;
}
export interface Response$CreateTagConfiguration$Status$409 {
    "application/json": Schemas.APIErrorResponse;
}
export interface Response$CreateTagConfiguration$Status$429 {
    "application/json": Schemas.APIErrorResponse;
}
export interface Parameter$DeleteTagConfiguration {
    /** The name of the metric. */
    metric_name: Parameters.MetricName;
}
export interface Response$DeleteTagConfiguration$Status$403 {
    "application/json": Schemas.APIErrorResponse;
}
export interface Response$DeleteTagConfiguration$Status$404 {
    "application/json": Schemas.APIErrorResponse;
}
export interface Response$DeleteTagConfiguration$Status$429 {
    "application/json": Schemas.APIErrorResponse;
}
export interface Parameter$UpdateTagConfiguration {
    /** The name of the metric. */
    metric_name: Parameters.MetricName;
}
export interface RequestBody$UpdateTagConfiguration {
    "application/json": Schemas.MetricTagConfigurationUpdateRequest;
}
export interface Response$UpdateTagConfiguration$Status$200 {
    "application/json": Schemas.MetricTagConfigurationResponse;
}
export interface Response$UpdateTagConfiguration$Status$400 {
    "application/json": Schemas.APIErrorResponse;
}
export interface Response$UpdateTagConfiguration$Status$403 {
    "application/json": Schemas.APIErrorResponse;
}
export interface Response$UpdateTagConfiguration$Status$422 {
    "application/json": Schemas.APIErrorResponse;
}
export interface Response$UpdateTagConfiguration$Status$429 {
    "application/json": Schemas.APIErrorResponse;
}
export interface Parameter$ListVolumesByMetricName {
    /** The name of the metric. */
    metric_name: Parameters.MetricName;
}
export interface Response$ListVolumesByMetricName$Status$200 {
    "application/json": Schemas.MetricVolumesResponse;
}
export interface Response$ListVolumesByMetricName$Status$400 {
    "application/json": Schemas.APIErrorResponse;
}
export interface Response$ListVolumesByMetricName$Status$403 {
    "application/json": Schemas.APIErrorResponse;
}
export interface Response$ListVolumesByMetricName$Status$404 {
    "application/json": Schemas.APIErrorResponse;
}
export interface Response$ListVolumesByMetricName$Status$429 {
    "application/json": Schemas.APIErrorResponse;
}
export interface Response$ListPermissions$Status$200 {
    "application/json": Schemas.PermissionsResponse;
}
export interface Response$ListPermissions$Status$400 {
    "application/json": Schemas.APIErrorResponse;
}
export interface Response$ListPermissions$Status$403 {
    "application/json": Schemas.APIErrorResponse;
}
export type Response$ListPermissions$Status$429 = Responses.TooManyRequestsResponse.Content;
export interface Parameter$ListProcesses {
    /** String to search processes by. */
    search?: string;
    /** Comma-separated list of tags to filter processes by. */
    tags?: string;
    /**
     * Unix timestamp (number of seconds since epoch) of the start of the query window.
     * If not provided, the start of the query window will be 15 minutes before the `to` timestamp. If neither
     * `from` nor `to` are provided, the query window will be `[now - 15m, now]`.
     */
    from?: number;
    /**
     * Unix timestamp (number of seconds since epoch) of the end of the query window.
     * If not provided, the end of the query window will be 15 minutes after the `from` timestamp. If neither
     * `from` nor `to` are provided, the query window will be `[now - 15m, now]`.
     */
    to?: number;
    /** Maximum number of results returned. */
    "page[limit]"?: number;
    /**
     * String to query the next page of results.
     * This key is provided with each valid response from the API in `meta.page.after`.
     */
    "page[cursor]"?: string;
}
export interface Response$ListProcesses$Status$200 {
    "application/json": Schemas.ProcessSummariesResponse;
}
export interface Response$ListProcesses$Status$400 {
    "application/json": Schemas.APIErrorResponse;
}
export interface Response$ListProcesses$Status$403 {
    "application/json": Schemas.APIErrorResponse;
}
export type Response$ListProcesses$Status$429 = Responses.TooManyRequestsResponse.Content;
export interface Parameter$ListRoles {
    /** Size for a given page. */
    "page[size]"?: Parameters.PageSize;
    /** Specific page number to return. */
    "page[number]"?: Parameters.PageNumber;
    /**
     * Sort roles depending on the given field. Sort order is **ascending** by default.
     * Sort order is **descending** if the field is prefixed by a negative sign, for example:
     * `sort=-name`.
     */
    sort?: Schemas.RolesSort;
    /** Filter all roles by the given string. */
    filter?: string;
}
export interface Response$ListRoles$Status$200 {
    "application/json": Schemas.RolesResponse;
}
export interface Response$ListRoles$Status$403 {
    "application/json": Schemas.APIErrorResponse;
}
export type Response$ListRoles$Status$429 = Responses.TooManyRequestsResponse.Content;
export interface RequestBody$CreateRole {
    "application/json": Schemas.RoleCreateRequest;
}
export interface Response$CreateRole$Status$200 {
    "application/json": Schemas.RoleCreateResponse;
}
export interface Response$CreateRole$Status$400 {
    "application/json": Schemas.APIErrorResponse;
}
export interface Response$CreateRole$Status$403 {
    "application/json": Schemas.APIErrorResponse;
}
export type Response$CreateRole$Status$429 = Responses.TooManyRequestsResponse.Content;
export interface Parameter$GetRole {
    /** The ID of the role. */
    role_id: Parameters.RoleID;
}
export interface Response$GetRole$Status$200 {
    "application/json": Schemas.RoleResponse;
}
export interface Response$GetRole$Status$403 {
    "application/json": Schemas.APIErrorResponse;
}
export interface Response$GetRole$Status$404 {
    "application/json": Schemas.APIErrorResponse;
}
export type Response$GetRole$Status$429 = Responses.TooManyRequestsResponse.Content;
export interface Parameter$DeleteRole {
    /** The ID of the role. */
    role_id: Parameters.RoleID;
}
export interface Response$DeleteRole$Status$403 {
    "application/json": Schemas.APIErrorResponse;
}
export interface Response$DeleteRole$Status$404 {
    "application/json": Schemas.APIErrorResponse;
}
export type Response$DeleteRole$Status$429 = Responses.TooManyRequestsResponse.Content;
export interface Parameter$UpdateRole {
    /** The ID of the role. */
    role_id: Parameters.RoleID;
}
export interface RequestBody$UpdateRole {
    "application/json": Schemas.RoleUpdateRequest;
}
export interface Response$UpdateRole$Status$200 {
    "application/json": Schemas.RoleUpdateResponse;
}
export interface Response$UpdateRole$Status$400 {
    "application/json": Schemas.APIErrorResponse;
}
export interface Response$UpdateRole$Status$403 {
    "application/json": Schemas.APIErrorResponse;
}
export interface Response$UpdateRole$Status$404 {
    "application/json": Schemas.APIErrorResponse;
}
export interface Response$UpdateRole$Status$422 {
    "application/json": Schemas.APIErrorResponse;
}
export type Response$UpdateRole$Status$429 = Responses.TooManyRequestsResponse.Content;
export interface Parameter$CloneRole {
    /** The ID of the role. */
    role_id: Parameters.RoleID;
}
export interface RequestBody$CloneRole {
    "application/json": Schemas.RoleCloneRequest;
}
export interface Response$CloneRole$Status$200 {
    "application/json": Schemas.RoleResponse;
}
export interface Response$CloneRole$Status$400 {
    "application/json": Schemas.APIErrorResponse;
}
export interface Response$CloneRole$Status$403 {
    "application/json": Schemas.APIErrorResponse;
}
export interface Response$CloneRole$Status$404 {
    "application/json": Schemas.APIErrorResponse;
}
export interface Response$CloneRole$Status$409 {
    "application/json": Schemas.APIErrorResponse;
}
export type Response$CloneRole$Status$429 = Responses.TooManyRequestsResponse.Content;
export interface Parameter$ListRolePermissions {
    /** The ID of the role. */
    role_id: Parameters.RoleID;
}
export interface Response$ListRolePermissions$Status$200 {
    "application/json": Schemas.PermissionsResponse;
}
export interface Response$ListRolePermissions$Status$403 {
    "application/json": Schemas.APIErrorResponse;
}
export interface Response$ListRolePermissions$Status$404 {
    "application/json": Schemas.APIErrorResponse;
}
export type Response$ListRolePermissions$Status$429 = Responses.TooManyRequestsResponse.Content;
export interface Parameter$AddPermissionToRole {
    /** The ID of the role. */
    role_id: Parameters.RoleID;
}
export interface RequestBody$AddPermissionToRole {
    "application/json": Schemas.RelationshipToPermission;
}
export interface Response$AddPermissionToRole$Status$200 {
    "application/json": Schemas.PermissionsResponse;
}
export interface Response$AddPermissionToRole$Status$400 {
    "application/json": Schemas.APIErrorResponse;
}
export interface Response$AddPermissionToRole$Status$403 {
    "application/json": Schemas.APIErrorResponse;
}
export interface Response$AddPermissionToRole$Status$404 {
    "application/json": Schemas.APIErrorResponse;
}
export type Response$AddPermissionToRole$Status$429 = Responses.TooManyRequestsResponse.Content;
export interface Parameter$RemovePermissionFromRole {
    /** The ID of the role. */
    role_id: Parameters.RoleID;
}
export interface RequestBody$RemovePermissionFromRole {
    "application/json": Schemas.RelationshipToPermission;
}
export interface Response$RemovePermissionFromRole$Status$200 {
    "application/json": Schemas.PermissionsResponse;
}
export interface Response$RemovePermissionFromRole$Status$400 {
    "application/json": Schemas.APIErrorResponse;
}
export interface Response$RemovePermissionFromRole$Status$403 {
    "application/json": Schemas.APIErrorResponse;
}
export interface Response$RemovePermissionFromRole$Status$404 {
    "application/json": Schemas.APIErrorResponse;
}
export type Response$RemovePermissionFromRole$Status$429 = Responses.TooManyRequestsResponse.Content;
export interface Parameter$ListRoleUsers {
    /** The ID of the role. */
    role_id: Parameters.RoleID;
    /** Size for a given page. */
    "page[size]"?: Parameters.PageSize;
    /** Specific page number to return. */
    "page[number]"?: Parameters.PageNumber;
    /**
     * User attribute to order results by. Sort order is **ascending** by default.
     * Sort order is **descending** if the field is prefixed by a negative sign,
     * for example `sort=-name`. Options: `name`, `email`, `status`.
     */
    sort?: string;
    /** Filter all users by the given string. Defaults to no filtering. */
    filter?: string;
}
export interface Response$ListRoleUsers$Status$200 {
    "application/json": Schemas.UsersResponse;
}
export interface Response$ListRoleUsers$Status$403 {
    "application/json": Schemas.APIErrorResponse;
}
export interface Response$ListRoleUsers$Status$404 {
    "application/json": Schemas.APIErrorResponse;
}
export type Response$ListRoleUsers$Status$429 = Responses.TooManyRequestsResponse.Content;
export interface Parameter$AddUserToRole {
    /** The ID of the role. */
    role_id: Parameters.RoleID;
}
export interface RequestBody$AddUserToRole {
    "application/json": Schemas.RelationshipToUser;
}
export interface Response$AddUserToRole$Status$200 {
    "application/json": Schemas.UsersResponse;
}
export interface Response$AddUserToRole$Status$400 {
    "application/json": Schemas.APIErrorResponse;
}
export interface Response$AddUserToRole$Status$403 {
    "application/json": Schemas.APIErrorResponse;
}
export interface Response$AddUserToRole$Status$404 {
    "application/json": Schemas.APIErrorResponse;
}
export type Response$AddUserToRole$Status$429 = Responses.TooManyRequestsResponse.Content;
export interface Parameter$RemoveUserFromRole {
    /** The ID of the role. */
    role_id: Parameters.RoleID;
}
export interface RequestBody$RemoveUserFromRole {
    "application/json": Schemas.RelationshipToUser;
}
export interface Response$RemoveUserFromRole$Status$200 {
    "application/json": Schemas.UsersResponse;
}
export interface Response$RemoveUserFromRole$Status$400 {
    "application/json": Schemas.APIErrorResponse;
}
export interface Response$RemoveUserFromRole$Status$403 {
    "application/json": Schemas.APIErrorResponse;
}
export interface Response$RemoveUserFromRole$Status$404 {
    "application/json": Schemas.APIErrorResponse;
}
export type Response$RemoveUserFromRole$Status$429 = Responses.TooManyRequestsResponse.Content;
export interface Response$DownloadCloudWorkloadPolicyFile$Status$200 {
    "application/yaml": string;
}
export type Response$DownloadCloudWorkloadPolicyFile$Status$403 = Responses.NotAuthorizedResponse.Content;
export type Response$DownloadCloudWorkloadPolicyFile$Status$429 = Responses.TooManyRequestsResponse.Content;
export interface Response$ListCloudWorkloadSecurityAgentRules$Status$200 {
    "application/json": Schemas.CloudWorkloadSecurityAgentRulesListResponse;
}
export type Response$ListCloudWorkloadSecurityAgentRules$Status$403 = Responses.NotAuthorizedResponse.Content;
export type Response$ListCloudWorkloadSecurityAgentRules$Status$429 = Responses.TooManyRequestsResponse.Content;
export interface RequestBody$CreateCloudWorkloadSecurityAgentRule {
    "application/json": Schemas.CloudWorkloadSecurityAgentRuleCreateRequest;
}
export interface Response$CreateCloudWorkloadSecurityAgentRule$Status$200 {
    "application/json": Schemas.CloudWorkloadSecurityAgentRuleResponse;
}
export type Response$CreateCloudWorkloadSecurityAgentRule$Status$400 = Responses.BadRequestResponse.Content;
export type Response$CreateCloudWorkloadSecurityAgentRule$Status$403 = Responses.NotAuthorizedResponse.Content;
export type Response$CreateCloudWorkloadSecurityAgentRule$Status$409 = Responses.ConflictResponse.Content;
export type Response$CreateCloudWorkloadSecurityAgentRule$Status$429 = Responses.TooManyRequestsResponse.Content;
export interface Parameter$GetCloudWorkloadSecurityAgentRule {
    /** The ID of the Agent rule. */
    agent_rule_id: Parameters.CloudWorkloadSecurityAgentRuleID;
}
export interface Response$GetCloudWorkloadSecurityAgentRule$Status$200 {
    "application/json": Schemas.CloudWorkloadSecurityAgentRuleResponse;
}
export type Response$GetCloudWorkloadSecurityAgentRule$Status$403 = Responses.NotAuthorizedResponse.Content;
export type Response$GetCloudWorkloadSecurityAgentRule$Status$404 = Responses.NotFoundResponse.Content;
export type Response$GetCloudWorkloadSecurityAgentRule$Status$429 = Responses.TooManyRequestsResponse.Content;
export interface Parameter$DeleteCloudWorkloadSecurityAgentRule {
    /** The ID of the Agent rule. */
    agent_rule_id: Parameters.CloudWorkloadSecurityAgentRuleID;
}
export type Response$DeleteCloudWorkloadSecurityAgentRule$Status$403 = Responses.NotAuthorizedResponse.Content;
export type Response$DeleteCloudWorkloadSecurityAgentRule$Status$404 = Responses.NotFoundResponse.Content;
export type Response$DeleteCloudWorkloadSecurityAgentRule$Status$429 = Responses.TooManyRequestsResponse.Content;
export interface Parameter$UpdateCloudWorkloadSecurityAgentRule {
    /** The ID of the Agent rule. */
    agent_rule_id: Parameters.CloudWorkloadSecurityAgentRuleID;
}
export interface RequestBody$UpdateCloudWorkloadSecurityAgentRule {
    "application/json": Schemas.CloudWorkloadSecurityAgentRuleUpdateRequest;
}
export interface Response$UpdateCloudWorkloadSecurityAgentRule$Status$200 {
    "application/json": Schemas.CloudWorkloadSecurityAgentRuleResponse;
}
export type Response$UpdateCloudWorkloadSecurityAgentRule$Status$400 = Responses.BadRequestResponse.Content;
export type Response$UpdateCloudWorkloadSecurityAgentRule$Status$403 = Responses.NotAuthorizedResponse.Content;
export type Response$UpdateCloudWorkloadSecurityAgentRule$Status$404 = Responses.NotFoundResponse.Content;
export type Response$UpdateCloudWorkloadSecurityAgentRule$Status$409 = Responses.ConcurrentModificationResponse.Content;
export type Response$UpdateCloudWorkloadSecurityAgentRule$Status$429 = Responses.TooManyRequestsResponse.Content;
export interface Response$ListSecurityFilters$Status$200 {
    "application/json": Schemas.SecurityFiltersResponse;
}
export type Response$ListSecurityFilters$Status$403 = Responses.NotAuthorizedResponse.Content;
export type Response$ListSecurityFilters$Status$429 = Responses.TooManyRequestsResponse.Content;
export interface RequestBody$CreateSecurityFilter {
    "application/json": Schemas.SecurityFilterCreateRequest;
}
export interface Response$CreateSecurityFilter$Status$200 {
    "application/json": Schemas.SecurityFilterResponse;
}
export type Response$CreateSecurityFilter$Status$400 = Responses.BadRequestResponse.Content;
export type Response$CreateSecurityFilter$Status$403 = Responses.NotAuthorizedResponse.Content;
export type Response$CreateSecurityFilter$Status$409 = Responses.ConflictResponse.Content;
export type Response$CreateSecurityFilter$Status$429 = Responses.TooManyRequestsResponse.Content;
export interface Parameter$GetSecurityFilter {
    /** The ID of the security filter. */
    security_filter_id: Parameters.SecurityFilterID;
}
export interface Response$GetSecurityFilter$Status$200 {
    "application/json": Schemas.SecurityFilterResponse;
}
export type Response$GetSecurityFilter$Status$403 = Responses.NotAuthorizedResponse.Content;
export type Response$GetSecurityFilter$Status$404 = Responses.NotFoundResponse.Content;
export type Response$GetSecurityFilter$Status$429 = Responses.TooManyRequestsResponse.Content;
export interface Parameter$DeleteSecurityFilter {
    /** The ID of the security filter. */
    security_filter_id: Parameters.SecurityFilterID;
}
export type Response$DeleteSecurityFilter$Status$403 = Responses.NotAuthorizedResponse.Content;
export type Response$DeleteSecurityFilter$Status$404 = Responses.NotFoundResponse.Content;
export type Response$DeleteSecurityFilter$Status$429 = Responses.TooManyRequestsResponse.Content;
export interface Parameter$UpdateSecurityFilter {
    /** The ID of the security filter. */
    security_filter_id: Parameters.SecurityFilterID;
}
export interface RequestBody$UpdateSecurityFilter {
    "application/json": Schemas.SecurityFilterUpdateRequest;
}
export interface Response$UpdateSecurityFilter$Status$200 {
    "application/json": Schemas.SecurityFilterResponse;
}
export type Response$UpdateSecurityFilter$Status$400 = Responses.BadRequestResponse.Content;
export type Response$UpdateSecurityFilter$Status$403 = Responses.NotAuthorizedResponse.Content;
export type Response$UpdateSecurityFilter$Status$404 = Responses.NotFoundResponse.Content;
export type Response$UpdateSecurityFilter$Status$409 = Responses.ConcurrentModificationResponse.Content;
export type Response$UpdateSecurityFilter$Status$429 = Responses.TooManyRequestsResponse.Content;
export interface Parameter$ListSecurityMonitoringRules {
    /** Size for a given page. */
    "page[size]"?: Parameters.PageSize;
    /** Specific page number to return. */
    "page[number]"?: Parameters.PageNumber;
}
export interface Response$ListSecurityMonitoringRules$Status$200 {
    "application/json": Schemas.SecurityMonitoringListRulesResponse;
}
export type Response$ListSecurityMonitoringRules$Status$400 = Responses.BadRequestResponse.Content;
export type Response$ListSecurityMonitoringRules$Status$429 = Responses.TooManyRequestsResponse.Content;
export interface RequestBody$CreateSecurityMonitoringRule {
    "application/json": Schemas.SecurityMonitoringRuleCreatePayload;
}
export interface Response$CreateSecurityMonitoringRule$Status$200 {
    "application/json": Schemas.SecurityMonitoringRuleResponse;
}
export type Response$CreateSecurityMonitoringRule$Status$400 = Responses.BadRequestResponse.Content;
export type Response$CreateSecurityMonitoringRule$Status$403 = Responses.NotAuthorizedResponse.Content;
export type Response$CreateSecurityMonitoringRule$Status$429 = Responses.TooManyRequestsResponse.Content;
export interface Parameter$GetSecurityMonitoringRule {
    /** The ID of the rule. */
    rule_id: Parameters.SecurityMonitoringRuleID;
}
export interface Response$GetSecurityMonitoringRule$Status$200 {
    "application/json": Schemas.SecurityMonitoringRuleResponse;
}
export type Response$GetSecurityMonitoringRule$Status$404 = Responses.NotFoundResponse.Content;
export type Response$GetSecurityMonitoringRule$Status$429 = Responses.TooManyRequestsResponse.Content;
export interface Parameter$UpdateSecurityMonitoringRule {
    /** The ID of the rule. */
    rule_id: Parameters.SecurityMonitoringRuleID;
}
export interface RequestBody$UpdateSecurityMonitoringRule {
    "application/json": Schemas.SecurityMonitoringRuleUpdatePayload;
}
export interface Response$UpdateSecurityMonitoringRule$Status$200 {
    "application/json": Schemas.SecurityMonitoringRuleResponse;
}
export type Response$UpdateSecurityMonitoringRule$Status$400 = Responses.BadRequestResponse.Content;
export type Response$UpdateSecurityMonitoringRule$Status$401 = Responses.ConcurrentModificationResponse.Content;
export type Response$UpdateSecurityMonitoringRule$Status$403 = Responses.NotAuthorizedResponse.Content;
export type Response$UpdateSecurityMonitoringRule$Status$404 = Responses.NotFoundResponse.Content;
export type Response$UpdateSecurityMonitoringRule$Status$429 = Responses.TooManyRequestsResponse.Content;
export interface Parameter$DeleteSecurityMonitoringRule {
    /** The ID of the rule. */
    rule_id: Parameters.SecurityMonitoringRuleID;
}
export type Response$DeleteSecurityMonitoringRule$Status$403 = Responses.NotAuthorizedResponse.Content;
export type Response$DeleteSecurityMonitoringRule$Status$404 = Responses.NotFoundResponse.Content;
export type Response$DeleteSecurityMonitoringRule$Status$429 = Responses.TooManyRequestsResponse.Content;
export interface Parameter$ListSecurityMonitoringSignals {
    /** The search query for security signals. */
    "filter[query]"?: string;
    /** The minimum timestamp for requested security signals. */
    "filter[from]"?: string;
    /** The maximum timestamp for requested security signals. */
    "filter[to]"?: string;
    /** The order of the security signals in results. */
    sort?: Schemas.SecurityMonitoringSignalsSort;
    /** A list of results using the cursor provided in the previous query. */
    "page[cursor]"?: string;
    /** The maximum number of security signals in the response. */
    "page[limit]"?: number;
}
export interface Response$ListSecurityMonitoringSignals$Status$200 {
    "application/json": Schemas.SecurityMonitoringSignalsListResponse;
}
export type Response$ListSecurityMonitoringSignals$Status$400 = Responses.BadRequestResponse.Content;
export type Response$ListSecurityMonitoringSignals$Status$403 = Responses.NotAuthorizedResponse.Content;
export type Response$ListSecurityMonitoringSignals$Status$429 = Responses.TooManyRequestsResponse.Content;
export interface RequestBody$SearchSecurityMonitoringSignals {
    "application/json": Schemas.SecurityMonitoringSignalListRequest;
}
export interface Response$SearchSecurityMonitoringSignals$Status$200 {
    "application/json": Schemas.SecurityMonitoringSignalsListResponse;
}
export type Response$SearchSecurityMonitoringSignals$Status$400 = Responses.BadRequestResponse.Content;
export type Response$SearchSecurityMonitoringSignals$Status$403 = Responses.NotAuthorizedResponse.Content;
export type Response$SearchSecurityMonitoringSignals$Status$429 = Responses.TooManyRequestsResponse.Content;
export interface RequestBody$CreateServiceAccount {
    "application/json": Schemas.ServiceAccountCreateRequest;
}
export interface Response$CreateServiceAccount$Status$201 {
    "application/json": Schemas.UserResponse;
}
export interface Response$CreateServiceAccount$Status$400 {
    "application/json": Schemas.APIErrorResponse;
}
export interface Response$CreateServiceAccount$Status$403 {
    "application/json": Schemas.APIErrorResponse;
}
export type Response$CreateServiceAccount$Status$429 = Responses.TooManyRequestsResponse.Content;
export interface Parameter$ListServiceAccountApplicationKeys {
    /** The ID of the service account. */
    service_account_id: Parameters.ServiceAccountID;
    /** Size for a given page. */
    "page[size]"?: Parameters.PageSize;
    /** Specific page number to return. */
    "page[number]"?: Parameters.PageNumber;
    /**
     * Application key attribute used to sort results. Sort order is ascending
     * by default. In order to specify a descending sort, prefix the
     * attribute with a minus sign.
     */
    sort?: Parameters.ApplicationKeysSortParameter;
    /** Filter application keys by the specified string. */
    filter?: Parameters.ApplicationKeyFilterParameter;
    /** Only include application keys created on or after the specified date. */
    "filter[created_at][start]"?: Parameters.ApplicationKeyFilterCreatedAtStartParameter;
    /** Only include application keys created on or before the specified date. */
    "filter[created_at][end]"?: Parameters.ApplicationKeyFilterCreatedAtEndParameter;
}
export interface Response$ListServiceAccountApplicationKeys$Status$200 {
    "application/json": Schemas.ListApplicationKeysResponse;
}
export interface Response$ListServiceAccountApplicationKeys$Status$400 {
    "application/json": Schemas.APIErrorResponse;
}
export interface Response$ListServiceAccountApplicationKeys$Status$403 {
    "application/json": Schemas.APIErrorResponse;
}
export interface Response$ListServiceAccountApplicationKeys$Status$404 {
    "application/json": Schemas.APIErrorResponse;
}
export type Response$ListServiceAccountApplicationKeys$Status$429 = Responses.TooManyRequestsResponse.Content;
export interface Parameter$CreateServiceAccountApplicationKey {
    /** The ID of the service account. */
    service_account_id: Parameters.ServiceAccountID;
}
export interface RequestBody$CreateServiceAccountApplicationKey {
    "application/json": Schemas.ApplicationKeyCreateRequest;
}
export interface Response$CreateServiceAccountApplicationKey$Status$201 {
    "application/json": Schemas.ApplicationKeyResponse;
}
export interface Response$CreateServiceAccountApplicationKey$Status$400 {
    "application/json": Schemas.APIErrorResponse;
}
export interface Response$CreateServiceAccountApplicationKey$Status$403 {
    "application/json": Schemas.APIErrorResponse;
}
export type Response$CreateServiceAccountApplicationKey$Status$429 = Responses.TooManyRequestsResponse.Content;
export interface Parameter$GetServiceAccountApplicationKey {
    /** The ID of the service account. */
    service_account_id: Parameters.ServiceAccountID;
    /** The ID of the application key. */
    app_key_id: Parameters.ApplicationKeyID;
}
export interface Response$GetServiceAccountApplicationKey$Status$200 {
    "application/json": Schemas.PartialApplicationKeyResponse;
}
export interface Response$GetServiceAccountApplicationKey$Status$403 {
    "application/json": Schemas.APIErrorResponse;
}
export interface Response$GetServiceAccountApplicationKey$Status$404 {
    "application/json": Schemas.APIErrorResponse;
}
export type Response$GetServiceAccountApplicationKey$Status$429 = Responses.TooManyRequestsResponse.Content;
export interface Parameter$DeleteServiceAccountApplicationKey {
    /** The ID of the service account. */
    service_account_id: Parameters.ServiceAccountID;
    /** The ID of the application key. */
    app_key_id: Parameters.ApplicationKeyID;
}
export interface Response$DeleteServiceAccountApplicationKey$Status$403 {
    "application/json": Schemas.APIErrorResponse;
}
export interface Response$DeleteServiceAccountApplicationKey$Status$404 {
    "application/json": Schemas.APIErrorResponse;
}
export type Response$DeleteServiceAccountApplicationKey$Status$429 = Responses.TooManyRequestsResponse.Content;
export interface Parameter$UpdateServiceAccountApplicationKey {
    /** The ID of the service account. */
    service_account_id: Parameters.ServiceAccountID;
    /** The ID of the application key. */
    app_key_id: Parameters.ApplicationKeyID;
}
export interface RequestBody$UpdateServiceAccountApplicationKey {
    "application/json": Schemas.ApplicationKeyUpdateRequest;
}
export interface Response$UpdateServiceAccountApplicationKey$Status$200 {
    "application/json": Schemas.PartialApplicationKeyResponse;
}
export interface Response$UpdateServiceAccountApplicationKey$Status$400 {
    "application/json": Schemas.APIErrorResponse;
}
export interface Response$UpdateServiceAccountApplicationKey$Status$403 {
    "application/json": Schemas.APIErrorResponse;
}
export interface Response$UpdateServiceAccountApplicationKey$Status$404 {
    "application/json": Schemas.APIErrorResponse;
}
export type Response$UpdateServiceAccountApplicationKey$Status$429 = Responses.TooManyRequestsResponse.Content;
export interface Parameter$ListIncidentServices {
    /** Specifies which types of related objects should be included in the response. */
    include?: Parameters.IncidentServiceIncludeQueryParameter;
    /** Size for a given page. */
    "page[size]"?: Parameters.PageSize;
    /** Specific offset to use as the beginning of the returned page. */
    "page[offset]"?: Parameters.PageOffset;
    /** A search query that filters services by name. */
    filter?: Parameters.IncidentServiceSearchQueryParameter;
}
export interface Response$ListIncidentServices$Status$200 {
    "application/json": Schemas.IncidentServicesResponse;
}
export type Response$ListIncidentServices$Status$400 = Responses.BadRequestResponse.Content;
export type Response$ListIncidentServices$Status$401 = Responses.UnauthorizedResponse.Content;
export type Response$ListIncidentServices$Status$403 = Responses.ForbiddenResponse.Content;
export type Response$ListIncidentServices$Status$404 = Responses.NotFoundResponse.Content;
export type Response$ListIncidentServices$Status$429 = Responses.TooManyRequestsResponse.Content;
export interface RequestBody$CreateIncidentService {
    "application/json": Schemas.IncidentServiceCreateRequest;
}
export interface Response$CreateIncidentService$Status$201 {
    "application/json": Schemas.IncidentServiceResponse;
}
export type Response$CreateIncidentService$Status$400 = Responses.BadRequestResponse.Content;
export type Response$CreateIncidentService$Status$401 = Responses.UnauthorizedResponse.Content;
export type Response$CreateIncidentService$Status$403 = Responses.ForbiddenResponse.Content;
export type Response$CreateIncidentService$Status$404 = Responses.NotFoundResponse.Content;
export type Response$CreateIncidentService$Status$429 = Responses.TooManyRequestsResponse.Content;
export interface Parameter$GetIncidentService {
    /** The ID of the incident service. */
    service_id: Parameters.IncidentServiceIDPathParameter;
    /** Specifies which types of related objects should be included in the response. */
    include?: Parameters.IncidentServiceIncludeQueryParameter;
}
export interface Response$GetIncidentService$Status$200 {
    "application/json": Schemas.IncidentServiceResponse;
}
export type Response$GetIncidentService$Status$400 = Responses.BadRequestResponse.Content;
export type Response$GetIncidentService$Status$401 = Responses.UnauthorizedResponse.Content;
export type Response$GetIncidentService$Status$403 = Responses.ForbiddenResponse.Content;
export type Response$GetIncidentService$Status$404 = Responses.NotFoundResponse.Content;
export type Response$GetIncidentService$Status$429 = Responses.TooManyRequestsResponse.Content;
export interface Parameter$DeleteIncidentService {
    /** The ID of the incident service. */
    service_id: Parameters.IncidentServiceIDPathParameter;
}
export type Response$DeleteIncidentService$Status$400 = Responses.BadRequestResponse.Content;
export type Response$DeleteIncidentService$Status$401 = Responses.UnauthorizedResponse.Content;
export type Response$DeleteIncidentService$Status$403 = Responses.ForbiddenResponse.Content;
export type Response$DeleteIncidentService$Status$404 = Responses.NotFoundResponse.Content;
export type Response$DeleteIncidentService$Status$429 = Responses.TooManyRequestsResponse.Content;
export interface Parameter$UpdateIncidentService {
    /** The ID of the incident service. */
    service_id: Parameters.IncidentServiceIDPathParameter;
}
export interface RequestBody$UpdateIncidentService {
    "application/json": Schemas.IncidentServiceUpdateRequest;
}
export interface Response$UpdateIncidentService$Status$200 {
    "application/json": Schemas.IncidentServiceResponse;
}
export type Response$UpdateIncidentService$Status$400 = Responses.BadRequestResponse.Content;
export type Response$UpdateIncidentService$Status$401 = Responses.UnauthorizedResponse.Content;
export type Response$UpdateIncidentService$Status$403 = Responses.ForbiddenResponse.Content;
export type Response$UpdateIncidentService$Status$404 = Responses.NotFoundResponse.Content;
export type Response$UpdateIncidentService$Status$429 = Responses.TooManyRequestsResponse.Content;
export interface Parameter$ListIncidentTeams {
    /** Specifies which types of related objects should be included in the response. */
    include?: Parameters.IncidentTeamIncludeQueryParameter;
    /** Size for a given page. */
    "page[size]"?: Parameters.PageSize;
    /** Specific offset to use as the beginning of the returned page. */
    "page[offset]"?: Parameters.PageOffset;
    /** A search query that filters teams by name. */
    filter?: Parameters.IncidentTeamSearchQueryParameter;
}
export interface Response$ListIncidentTeams$Status$200 {
    "application/json": Schemas.IncidentTeamsResponse;
}
export type Response$ListIncidentTeams$Status$400 = Responses.BadRequestResponse.Content;
export type Response$ListIncidentTeams$Status$401 = Responses.UnauthorizedResponse.Content;
export type Response$ListIncidentTeams$Status$403 = Responses.ForbiddenResponse.Content;
export type Response$ListIncidentTeams$Status$404 = Responses.NotFoundResponse.Content;
export type Response$ListIncidentTeams$Status$429 = Responses.TooManyRequestsResponse.Content;
export interface RequestBody$CreateIncidentTeam {
    "application/json": Schemas.IncidentTeamCreateRequest;
}
export interface Response$CreateIncidentTeam$Status$201 {
    "application/json": Schemas.IncidentTeamResponse;
}
export type Response$CreateIncidentTeam$Status$400 = Responses.BadRequestResponse.Content;
export type Response$CreateIncidentTeam$Status$401 = Responses.UnauthorizedResponse.Content;
export type Response$CreateIncidentTeam$Status$403 = Responses.ForbiddenResponse.Content;
export type Response$CreateIncidentTeam$Status$404 = Responses.NotFoundResponse.Content;
export type Response$CreateIncidentTeam$Status$429 = Responses.TooManyRequestsResponse.Content;
export interface Parameter$GetIncidentTeam {
    /** The ID of the incident team. */
    team_id: Parameters.IncidentTeamIDPathParameter;
    /** Specifies which types of related objects should be included in the response. */
    include?: Parameters.IncidentTeamIncludeQueryParameter;
}
export interface Response$GetIncidentTeam$Status$200 {
    "application/json": Schemas.IncidentTeamResponse;
}
export type Response$GetIncidentTeam$Status$400 = Responses.BadRequestResponse.Content;
export type Response$GetIncidentTeam$Status$401 = Responses.UnauthorizedResponse.Content;
export type Response$GetIncidentTeam$Status$403 = Responses.ForbiddenResponse.Content;
export type Response$GetIncidentTeam$Status$404 = Responses.NotFoundResponse.Content;
export type Response$GetIncidentTeam$Status$429 = Responses.TooManyRequestsResponse.Content;
export interface Parameter$DeleteIncidentTeam {
    /** The ID of the incident team. */
    team_id: Parameters.IncidentTeamIDPathParameter;
}
export type Response$DeleteIncidentTeam$Status$400 = Responses.BadRequestResponse.Content;
export type Response$DeleteIncidentTeam$Status$401 = Responses.UnauthorizedResponse.Content;
export type Response$DeleteIncidentTeam$Status$403 = Responses.ForbiddenResponse.Content;
export type Response$DeleteIncidentTeam$Status$404 = Responses.NotFoundResponse.Content;
export type Response$DeleteIncidentTeam$Status$429 = Responses.TooManyRequestsResponse.Content;
export interface Parameter$UpdateIncidentTeam {
    /** The ID of the incident team. */
    team_id: Parameters.IncidentTeamIDPathParameter;
}
export interface RequestBody$UpdateIncidentTeam {
    "application/json": Schemas.IncidentTeamUpdateRequest;
}
export interface Response$UpdateIncidentTeam$Status$200 {
    "application/json": Schemas.IncidentTeamResponse;
}
export type Response$UpdateIncidentTeam$Status$400 = Responses.BadRequestResponse.Content;
export type Response$UpdateIncidentTeam$Status$401 = Responses.UnauthorizedResponse.Content;
export type Response$UpdateIncidentTeam$Status$403 = Responses.ForbiddenResponse.Content;
export type Response$UpdateIncidentTeam$Status$404 = Responses.NotFoundResponse.Content;
export type Response$UpdateIncidentTeam$Status$429 = Responses.TooManyRequestsResponse.Content;
export interface RequestBody$SendInvitations {
    "application/json": Schemas.UserInvitationsRequest;
}
export interface Response$SendInvitations$Status$201 {
    "application/json": Schemas.UserInvitationsResponse;
}
export interface Response$SendInvitations$Status$400 {
    "application/json": Schemas.APIErrorResponse;
}
export interface Response$SendInvitations$Status$403 {
    "application/json": Schemas.APIErrorResponse;
}
export type Response$SendInvitations$Status$429 = Responses.TooManyRequestsResponse.Content;
export interface Parameter$GetInvitation {
    /** The UUID of the user invitation. */
    user_invitation_uuid: string;
}
export interface Response$GetInvitation$Status$200 {
    "application/json": Schemas.UserInvitationResponse;
}
export interface Response$GetInvitation$Status$403 {
    "application/json": Schemas.APIErrorResponse;
}
export interface Response$GetInvitation$Status$404 {
    "application/json": Schemas.APIErrorResponse;
}
export type Response$GetInvitation$Status$429 = Responses.TooManyRequestsResponse.Content;
export interface Parameter$ListUsers {
    /** Size for a given page. */
    "page[size]"?: Parameters.PageSize;
    /** Specific page number to return. */
    "page[number]"?: Parameters.PageNumber;
    /**
     * User attribute to order results by. Sort order is ascending by default.
     * Sort order is descending if the field
     * is prefixed by a negative sign, for example `sort=-name`. Options: `name`,
     * `modified_at`, `user_count`.
     */
    sort?: string;
    /** Direction of sort. Options: `asc`, `desc`. */
    sort_dir?: Schemas.QuerySortOrder;
    /** Filter all users by the given string. Defaults to no filtering. */
    filter?: string;
    /**
     * Filter on status attribute.
     * Comma separated list, with possible values `Active`, `Pending`, and `Disabled`.
     * Defaults to no filtering.
     */
    "filter[status]"?: string;
}
export interface Response$ListUsers$Status$200 {
    "application/json": Schemas.UsersResponse;
}
export interface Response$ListUsers$Status$400 {
    "application/json": Schemas.APIErrorResponse;
}
export interface Response$ListUsers$Status$403 {
    "application/json": Schemas.APIErrorResponse;
}
export type Response$ListUsers$Status$429 = Responses.TooManyRequestsResponse.Content;
export interface RequestBody$CreateUser {
    "application/json": Schemas.UserCreateRequest;
}
export interface Response$CreateUser$Status$201 {
    "application/json": Schemas.UserResponse;
}
export interface Response$CreateUser$Status$400 {
    "application/json": Schemas.APIErrorResponse;
}
export interface Response$CreateUser$Status$403 {
    "application/json": Schemas.APIErrorResponse;
}
export type Response$CreateUser$Status$429 = Responses.TooManyRequestsResponse.Content;
export interface Parameter$GetUser {
    /** The ID of the user. */
    user_id: Parameters.UserID;
}
export interface Response$GetUser$Status$200 {
    "application/json": Schemas.UserResponse;
}
export interface Response$GetUser$Status$403 {
    "application/json": Schemas.APIErrorResponse;
}
export interface Response$GetUser$Status$404 {
    "application/json": Schemas.APIErrorResponse;
}
export type Response$GetUser$Status$429 = Responses.TooManyRequestsResponse.Content;
export interface Parameter$DisableUser {
    /** The ID of the user. */
    user_id: Parameters.UserID;
}
export interface Response$DisableUser$Status$403 {
    "application/json": Schemas.APIErrorResponse;
}
export interface Response$DisableUser$Status$404 {
    "application/json": Schemas.APIErrorResponse;
}
export type Response$DisableUser$Status$429 = Responses.TooManyRequestsResponse.Content;
export interface Parameter$UpdateUser {
    /** The ID of the user. */
    user_id: Parameters.UserID;
}
export interface RequestBody$UpdateUser {
    "application/json": Schemas.UserUpdateRequest;
}
export interface Response$UpdateUser$Status$200 {
    "application/json": Schemas.UserResponse;
}
export interface Response$UpdateUser$Status$400 {
    "application/json": Schemas.APIErrorResponse;
}
export interface Response$UpdateUser$Status$403 {
    "application/json": Schemas.APIErrorResponse;
}
export interface Response$UpdateUser$Status$404 {
    "application/json": Schemas.APIErrorResponse;
}
export interface Response$UpdateUser$Status$422 {
    "application/json": Schemas.APIErrorResponse;
}
export type Response$UpdateUser$Status$429 = Responses.TooManyRequestsResponse.Content;
export interface Parameter$ListUserOrganizations {
    /** The ID of the user. */
    user_id: Parameters.UserID;
}
export interface Response$ListUserOrganizations$Status$200 {
    "application/json": Schemas.UserResponse;
}
export interface Response$ListUserOrganizations$Status$403 {
    "application/json": Schemas.APIErrorResponse;
}
export interface Response$ListUserOrganizations$Status$404 {
    "application/json": Schemas.APIErrorResponse;
}
export type Response$ListUserOrganizations$Status$429 = Responses.TooManyRequestsResponse.Content;
export interface Parameter$ListUserPermissions {
    /** The ID of the user. */
    user_id: Parameters.UserID;
}
export interface Response$ListUserPermissions$Status$200 {
    "application/json": Schemas.PermissionsResponse;
}
export interface Response$ListUserPermissions$Status$403 {
    "application/json": Schemas.APIErrorResponse;
}
export interface Response$ListUserPermissions$Status$404 {
    "application/json": Schemas.APIErrorResponse;
}
export type Response$ListUserPermissions$Status$429 = Responses.TooManyRequestsResponse.Content;
export type ResponseContentType$ListAPIKeys = keyof Response$ListAPIKeys$Status$200;
export interface Params$ListAPIKeys {
    parameter: Parameter$ListAPIKeys;
}
export type RequestContentType$CreateAPIKey = keyof RequestBody$CreateAPIKey;
export type ResponseContentType$CreateAPIKey = keyof Response$CreateAPIKey$Status$201;
export interface Params$CreateAPIKey {
    requestBody: RequestBody$CreateAPIKey["application/json"];
}
export type ResponseContentType$GetAPIKey = keyof Response$GetAPIKey$Status$200;
export interface Params$GetAPIKey {
    parameter: Parameter$GetAPIKey;
}
export interface Params$DeleteAPIKey {
    parameter: Parameter$DeleteAPIKey;
}
export type RequestContentType$UpdateAPIKey = keyof RequestBody$UpdateAPIKey;
export type ResponseContentType$UpdateAPIKey = keyof Response$UpdateAPIKey$Status$200;
export interface Params$UpdateAPIKey {
    parameter: Parameter$UpdateAPIKey;
    requestBody: RequestBody$UpdateAPIKey["application/json"];
}
export type ResponseContentType$ListApplicationKeys = keyof Response$ListApplicationKeys$Status$200;
export interface Params$ListApplicationKeys {
    parameter: Parameter$ListApplicationKeys;
}
export type ResponseContentType$GetApplicationKey = keyof Response$GetApplicationKey$Status$200;
export interface Params$GetApplicationKey {
    parameter: Parameter$GetApplicationKey;
}
export interface Params$DeleteApplicationKey {
    parameter: Parameter$DeleteApplicationKey;
}
export type RequestContentType$UpdateApplicationKey = keyof RequestBody$UpdateApplicationKey;
export type ResponseContentType$UpdateApplicationKey = keyof Response$UpdateApplicationKey$Status$200;
export interface Params$UpdateApplicationKey {
    parameter: Parameter$UpdateApplicationKey;
    requestBody: RequestBody$UpdateApplicationKey["application/json"];
}
export type ResponseContentType$ListAuthNMappings = keyof Response$ListAuthNMappings$Status$200;
export interface Params$ListAuthNMappings {
    parameter: Parameter$ListAuthNMappings;
}
export type RequestContentType$CreateAuthNMapping = keyof RequestBody$CreateAuthNMapping;
export type ResponseContentType$CreateAuthNMapping = keyof Response$CreateAuthNMapping$Status$200;
export interface Params$CreateAuthNMapping {
    requestBody: RequestBody$CreateAuthNMapping["application/json"];
}
export type ResponseContentType$GetAuthNMapping = keyof Response$GetAuthNMapping$Status$200;
export interface Params$GetAuthNMapping {
    parameter: Parameter$GetAuthNMapping;
}
export interface Params$DeleteAuthNMapping {
    parameter: Parameter$DeleteAuthNMapping;
}
export type RequestContentType$UpdateAuthNMapping = keyof RequestBody$UpdateAuthNMapping;
export type ResponseContentType$UpdateAuthNMapping = keyof Response$UpdateAuthNMapping$Status$200;
export interface Params$UpdateAuthNMapping {
    parameter: Parameter$UpdateAuthNMapping;
    requestBody: RequestBody$UpdateAuthNMapping["application/json"];
}
export type ResponseContentType$ListCurrentUserApplicationKeys = keyof Response$ListCurrentUserApplicationKeys$Status$200;
export interface Params$ListCurrentUserApplicationKeys {
    parameter: Parameter$ListCurrentUserApplicationKeys;
}
export type RequestContentType$CreateCurrentUserApplicationKey = keyof RequestBody$CreateCurrentUserApplicationKey;
export type ResponseContentType$CreateCurrentUserApplicationKey = keyof Response$CreateCurrentUserApplicationKey$Status$201;
export interface Params$CreateCurrentUserApplicationKey {
    requestBody: RequestBody$CreateCurrentUserApplicationKey["application/json"];
}
export type ResponseContentType$GetCurrentUserApplicationKey = keyof Response$GetCurrentUserApplicationKey$Status$200;
export interface Params$GetCurrentUserApplicationKey {
    parameter: Parameter$GetCurrentUserApplicationKey;
}
export interface Params$DeleteCurrentUserApplicationKey {
    parameter: Parameter$DeleteCurrentUserApplicationKey;
}
export type RequestContentType$UpdateCurrentUserApplicationKey = keyof RequestBody$UpdateCurrentUserApplicationKey;
export type ResponseContentType$UpdateCurrentUserApplicationKey = keyof Response$UpdateCurrentUserApplicationKey$Status$200;
export interface Params$UpdateCurrentUserApplicationKey {
    parameter: Parameter$UpdateCurrentUserApplicationKey;
    requestBody: RequestBody$UpdateCurrentUserApplicationKey["application/json"];
}
export type ResponseContentType$GetDashboardListItems = keyof Response$GetDashboardListItems$Status$200;
export interface Params$GetDashboardListItems {
    parameter: Parameter$GetDashboardListItems;
}
export type RequestContentType$UpdateDashboardListItems = keyof RequestBody$UpdateDashboardListItems;
export type ResponseContentType$UpdateDashboardListItems = keyof Response$UpdateDashboardListItems$Status$200;
export interface Params$UpdateDashboardListItems {
    parameter: Parameter$UpdateDashboardListItems;
    requestBody: RequestBody$UpdateDashboardListItems["application/json"];
}
export type RequestContentType$CreateDashboardListItems = keyof RequestBody$CreateDashboardListItems;
export type ResponseContentType$CreateDashboardListItems = keyof Response$CreateDashboardListItems$Status$200;
export interface Params$CreateDashboardListItems {
    parameter: Parameter$CreateDashboardListItems;
    requestBody: RequestBody$CreateDashboardListItems["application/json"];
}
export type RequestContentType$DeleteDashboardListItems = keyof RequestBody$DeleteDashboardListItems;
export type ResponseContentType$DeleteDashboardListItems = keyof Response$DeleteDashboardListItems$Status$200;
export interface Params$DeleteDashboardListItems {
    parameter: Parameter$DeleteDashboardListItems;
    requestBody: RequestBody$DeleteDashboardListItems["application/json"];
}
export type ResponseContentType$ListIncidents = keyof Response$ListIncidents$Status$200;
export interface Params$ListIncidents {
    parameter: Parameter$ListIncidents;
}
export type RequestContentType$CreateIncident = keyof RequestBody$CreateIncident;
export type ResponseContentType$CreateIncident = keyof Response$CreateIncident$Status$201;
export interface Params$CreateIncident {
    requestBody: RequestBody$CreateIncident["application/json"];
}
export type ResponseContentType$GetIncident = keyof Response$GetIncident$Status$200;
export interface Params$GetIncident {
    parameter: Parameter$GetIncident;
}
export interface Params$DeleteIncident {
    parameter: Parameter$DeleteIncident;
}
export type RequestContentType$UpdateIncident = keyof RequestBody$UpdateIncident;
export type ResponseContentType$UpdateIncident = keyof Response$UpdateIncident$Status$200;
export interface Params$UpdateIncident {
    parameter: Parameter$UpdateIncident;
    requestBody: RequestBody$UpdateIncident["application/json"];
}
export type RequestContentType$SubmitLog = keyof RequestBody$SubmitLog;
export type ResponseContentType$SubmitLog = keyof Response$SubmitLog$Status$202;
export interface Params$SubmitLog<T extends RequestContentType$SubmitLog> {
    headers: {
        "Content-Type": T;
    };
    parameter: Parameter$SubmitLog;
    requestBody: RequestBody$SubmitLog[T];
}
export type RequestContentType$AggregateLogs = keyof RequestBody$AggregateLogs;
export type ResponseContentType$AggregateLogs = keyof Response$AggregateLogs$Status$200;
export interface Params$AggregateLogs {
    requestBody: RequestBody$AggregateLogs["application/json"];
}
export type ResponseContentType$GetLogsArchiveOrder = keyof Response$GetLogsArchiveOrder$Status$200;
export type RequestContentType$UpdateLogsArchiveOrder = keyof RequestBody$UpdateLogsArchiveOrder;
export type ResponseContentType$UpdateLogsArchiveOrder = keyof Response$UpdateLogsArchiveOrder$Status$200;
export interface Params$UpdateLogsArchiveOrder {
    requestBody: RequestBody$UpdateLogsArchiveOrder["application/json"];
}
export type ResponseContentType$ListLogsArchives = keyof Response$ListLogsArchives$Status$200;
export type RequestContentType$CreateLogsArchive = keyof RequestBody$CreateLogsArchive;
export type ResponseContentType$CreateLogsArchive = keyof Response$CreateLogsArchive$Status$200;
export interface Params$CreateLogsArchive {
    requestBody: RequestBody$CreateLogsArchive["application/json"];
}
export type ResponseContentType$GetLogsArchive = keyof Response$GetLogsArchive$Status$200;
export interface Params$GetLogsArchive {
    parameter: Parameter$GetLogsArchive;
}
export type RequestContentType$UpdateLogsArchive = keyof RequestBody$UpdateLogsArchive;
export type ResponseContentType$UpdateLogsArchive = keyof Response$UpdateLogsArchive$Status$200;
export interface Params$UpdateLogsArchive {
    parameter: Parameter$UpdateLogsArchive;
    requestBody: RequestBody$UpdateLogsArchive["application/json"];
}
export interface Params$DeleteLogsArchive {
    parameter: Parameter$DeleteLogsArchive;
}
export type ResponseContentType$ListArchiveReadRoles = keyof Response$ListArchiveReadRoles$Status$200;
export interface Params$ListArchiveReadRoles {
    parameter: Parameter$ListArchiveReadRoles;
}
export type RequestContentType$AddReadRoleToArchive = keyof RequestBody$AddReadRoleToArchive;
export interface Params$AddReadRoleToArchive {
    parameter: Parameter$AddReadRoleToArchive;
    requestBody: RequestBody$AddReadRoleToArchive["application/json"];
}
export type RequestContentType$RemoveRoleFromArchive = keyof RequestBody$RemoveRoleFromArchive;
export interface Params$RemoveRoleFromArchive {
    parameter: Parameter$RemoveRoleFromArchive;
    requestBody: RequestBody$RemoveRoleFromArchive["application/json"];
}
export type ResponseContentType$ListLogsMetrics = keyof Response$ListLogsMetrics$Status$200;
export type RequestContentType$CreateLogsMetric = keyof RequestBody$CreateLogsMetric;
export type ResponseContentType$CreateLogsMetric = keyof Response$CreateLogsMetric$Status$200;
export interface Params$CreateLogsMetric {
    requestBody: RequestBody$CreateLogsMetric["application/json"];
}
export type ResponseContentType$GetLogsMetric = keyof Response$GetLogsMetric$Status$200;
export interface Params$GetLogsMetric {
    parameter: Parameter$GetLogsMetric;
}
export interface Params$DeleteLogsMetric {
    parameter: Parameter$DeleteLogsMetric;
}
export type RequestContentType$UpdateLogsMetric = keyof RequestBody$UpdateLogsMetric;
export type ResponseContentType$UpdateLogsMetric = keyof Response$UpdateLogsMetric$Status$200;
export interface Params$UpdateLogsMetric {
    parameter: Parameter$UpdateLogsMetric;
    requestBody: RequestBody$UpdateLogsMetric["application/json"];
}
export type ResponseContentType$ListLogsGet = keyof Response$ListLogsGet$Status$200;
export interface Params$ListLogsGet {
    parameter: Parameter$ListLogsGet;
}
export type RequestContentType$ListLogs = keyof RequestBody$ListLogs;
export type ResponseContentType$ListLogs = keyof Response$ListLogs$Status$200;
export interface Params$ListLogs {
    requestBody: RequestBody$ListLogs["application/json"];
}
export type ResponseContentType$ListTagConfigurations = keyof Response$ListTagConfigurations$Status$200;
export interface Params$ListTagConfigurations {
    parameter: Parameter$ListTagConfigurations;
}
export type RequestContentType$CreateBulkTagsMetricsConfiguration = keyof RequestBody$CreateBulkTagsMetricsConfiguration;
export type ResponseContentType$CreateBulkTagsMetricsConfiguration = keyof Response$CreateBulkTagsMetricsConfiguration$Status$202;
export interface Params$CreateBulkTagsMetricsConfiguration {
    requestBody: RequestBody$CreateBulkTagsMetricsConfiguration["application/json"];
}
export type RequestContentType$DeleteBulkTagsMetricsConfiguration = keyof RequestBody$DeleteBulkTagsMetricsConfiguration;
export type ResponseContentType$DeleteBulkTagsMetricsConfiguration = keyof Response$DeleteBulkTagsMetricsConfiguration$Status$202;
export interface Params$DeleteBulkTagsMetricsConfiguration {
    requestBody: RequestBody$DeleteBulkTagsMetricsConfiguration["application/json"];
}
export type ResponseContentType$ListTagsByMetricName = keyof Response$ListTagsByMetricName$Status$200;
export interface Params$ListTagsByMetricName {
    parameter: Parameter$ListTagsByMetricName;
}
export type ResponseContentType$ListTagConfigurationByName = keyof Response$ListTagConfigurationByName$Status$200;
export interface Params$ListTagConfigurationByName {
    parameter: Parameter$ListTagConfigurationByName;
}
export type RequestContentType$CreateTagConfiguration = keyof RequestBody$CreateTagConfiguration;
export type ResponseContentType$CreateTagConfiguration = keyof Response$CreateTagConfiguration$Status$201;
export interface Params$CreateTagConfiguration {
    parameter: Parameter$CreateTagConfiguration;
    requestBody: RequestBody$CreateTagConfiguration["application/json"];
}
export interface Params$DeleteTagConfiguration {
    parameter: Parameter$DeleteTagConfiguration;
}
export type RequestContentType$UpdateTagConfiguration = keyof RequestBody$UpdateTagConfiguration;
export type ResponseContentType$UpdateTagConfiguration = keyof Response$UpdateTagConfiguration$Status$200;
export interface Params$UpdateTagConfiguration {
    parameter: Parameter$UpdateTagConfiguration;
    requestBody: RequestBody$UpdateTagConfiguration["application/json"];
}
export type ResponseContentType$ListVolumesByMetricName = keyof Response$ListVolumesByMetricName$Status$200;
export interface Params$ListVolumesByMetricName {
    parameter: Parameter$ListVolumesByMetricName;
}
export type ResponseContentType$ListPermissions = keyof Response$ListPermissions$Status$200;
export type ResponseContentType$ListProcesses = keyof Response$ListProcesses$Status$200;
export interface Params$ListProcesses {
    parameter: Parameter$ListProcesses;
}
export type ResponseContentType$ListRoles = keyof Response$ListRoles$Status$200;
export interface Params$ListRoles {
    parameter: Parameter$ListRoles;
}
export type RequestContentType$CreateRole = keyof RequestBody$CreateRole;
export type ResponseContentType$CreateRole = keyof Response$CreateRole$Status$200;
export interface Params$CreateRole {
    requestBody: RequestBody$CreateRole["application/json"];
}
export type ResponseContentType$GetRole = keyof Response$GetRole$Status$200;
export interface Params$GetRole {
    parameter: Parameter$GetRole;
}
export interface Params$DeleteRole {
    parameter: Parameter$DeleteRole;
}
export type RequestContentType$UpdateRole = keyof RequestBody$UpdateRole;
export type ResponseContentType$UpdateRole = keyof Response$UpdateRole$Status$200;
export interface Params$UpdateRole {
    parameter: Parameter$UpdateRole;
    requestBody: RequestBody$UpdateRole["application/json"];
}
export type RequestContentType$CloneRole = keyof RequestBody$CloneRole;
export type ResponseContentType$CloneRole = keyof Response$CloneRole$Status$200;
export interface Params$CloneRole {
    parameter: Parameter$CloneRole;
    requestBody: RequestBody$CloneRole["application/json"];
}
export type ResponseContentType$ListRolePermissions = keyof Response$ListRolePermissions$Status$200;
export interface Params$ListRolePermissions {
    parameter: Parameter$ListRolePermissions;
}
export type RequestContentType$AddPermissionToRole = keyof RequestBody$AddPermissionToRole;
export type ResponseContentType$AddPermissionToRole = keyof Response$AddPermissionToRole$Status$200;
export interface Params$AddPermissionToRole {
    parameter: Parameter$AddPermissionToRole;
    requestBody: RequestBody$AddPermissionToRole["application/json"];
}
export type RequestContentType$RemovePermissionFromRole = keyof RequestBody$RemovePermissionFromRole;
export type ResponseContentType$RemovePermissionFromRole = keyof Response$RemovePermissionFromRole$Status$200;
export interface Params$RemovePermissionFromRole {
    parameter: Parameter$RemovePermissionFromRole;
    requestBody: RequestBody$RemovePermissionFromRole["application/json"];
}
export type ResponseContentType$ListRoleUsers = keyof Response$ListRoleUsers$Status$200;
export interface Params$ListRoleUsers {
    parameter: Parameter$ListRoleUsers;
}
export type RequestContentType$AddUserToRole = keyof RequestBody$AddUserToRole;
export type ResponseContentType$AddUserToRole = keyof Response$AddUserToRole$Status$200;
export interface Params$AddUserToRole {
    parameter: Parameter$AddUserToRole;
    requestBody: RequestBody$AddUserToRole["application/json"];
}
export type RequestContentType$RemoveUserFromRole = keyof RequestBody$RemoveUserFromRole;
export type ResponseContentType$RemoveUserFromRole = keyof Response$RemoveUserFromRole$Status$200;
export interface Params$RemoveUserFromRole {
    parameter: Parameter$RemoveUserFromRole;
    requestBody: RequestBody$RemoveUserFromRole["application/json"];
}
export type ResponseContentType$DownloadCloudWorkloadPolicyFile = keyof Response$DownloadCloudWorkloadPolicyFile$Status$200;
export type ResponseContentType$ListCloudWorkloadSecurityAgentRules = keyof Response$ListCloudWorkloadSecurityAgentRules$Status$200;
export type RequestContentType$CreateCloudWorkloadSecurityAgentRule = keyof RequestBody$CreateCloudWorkloadSecurityAgentRule;
export type ResponseContentType$CreateCloudWorkloadSecurityAgentRule = keyof Response$CreateCloudWorkloadSecurityAgentRule$Status$200;
export interface Params$CreateCloudWorkloadSecurityAgentRule {
    requestBody: RequestBody$CreateCloudWorkloadSecurityAgentRule["application/json"];
}
export type ResponseContentType$GetCloudWorkloadSecurityAgentRule = keyof Response$GetCloudWorkloadSecurityAgentRule$Status$200;
export interface Params$GetCloudWorkloadSecurityAgentRule {
    parameter: Parameter$GetCloudWorkloadSecurityAgentRule;
}
export interface Params$DeleteCloudWorkloadSecurityAgentRule {
    parameter: Parameter$DeleteCloudWorkloadSecurityAgentRule;
}
export type RequestContentType$UpdateCloudWorkloadSecurityAgentRule = keyof RequestBody$UpdateCloudWorkloadSecurityAgentRule;
export type ResponseContentType$UpdateCloudWorkloadSecurityAgentRule = keyof Response$UpdateCloudWorkloadSecurityAgentRule$Status$200;
export interface Params$UpdateCloudWorkloadSecurityAgentRule {
    parameter: Parameter$UpdateCloudWorkloadSecurityAgentRule;
    requestBody: RequestBody$UpdateCloudWorkloadSecurityAgentRule["application/json"];
}
export type ResponseContentType$ListSecurityFilters = keyof Response$ListSecurityFilters$Status$200;
export type RequestContentType$CreateSecurityFilter = keyof RequestBody$CreateSecurityFilter;
export type ResponseContentType$CreateSecurityFilter = keyof Response$CreateSecurityFilter$Status$200;
export interface Params$CreateSecurityFilter {
    requestBody: RequestBody$CreateSecurityFilter["application/json"];
}
export type ResponseContentType$GetSecurityFilter = keyof Response$GetSecurityFilter$Status$200;
export interface Params$GetSecurityFilter {
    parameter: Parameter$GetSecurityFilter;
}
export interface Params$DeleteSecurityFilter {
    parameter: Parameter$DeleteSecurityFilter;
}
export type RequestContentType$UpdateSecurityFilter = keyof RequestBody$UpdateSecurityFilter;
export type ResponseContentType$UpdateSecurityFilter = keyof Response$UpdateSecurityFilter$Status$200;
export interface Params$UpdateSecurityFilter {
    parameter: Parameter$UpdateSecurityFilter;
    requestBody: RequestBody$UpdateSecurityFilter["application/json"];
}
export type ResponseContentType$ListSecurityMonitoringRules = keyof Response$ListSecurityMonitoringRules$Status$200;
export interface Params$ListSecurityMonitoringRules {
    parameter: Parameter$ListSecurityMonitoringRules;
}
export type RequestContentType$CreateSecurityMonitoringRule = keyof RequestBody$CreateSecurityMonitoringRule;
export type ResponseContentType$CreateSecurityMonitoringRule = keyof Response$CreateSecurityMonitoringRule$Status$200;
export interface Params$CreateSecurityMonitoringRule {
    requestBody: RequestBody$CreateSecurityMonitoringRule["application/json"];
}
export type ResponseContentType$GetSecurityMonitoringRule = keyof Response$GetSecurityMonitoringRule$Status$200;
export interface Params$GetSecurityMonitoringRule {
    parameter: Parameter$GetSecurityMonitoringRule;
}
export type RequestContentType$UpdateSecurityMonitoringRule = keyof RequestBody$UpdateSecurityMonitoringRule;
export type ResponseContentType$UpdateSecurityMonitoringRule = keyof Response$UpdateSecurityMonitoringRule$Status$200;
export interface Params$UpdateSecurityMonitoringRule {
    parameter: Parameter$UpdateSecurityMonitoringRule;
    requestBody: RequestBody$UpdateSecurityMonitoringRule["application/json"];
}
export interface Params$DeleteSecurityMonitoringRule {
    parameter: Parameter$DeleteSecurityMonitoringRule;
}
export type ResponseContentType$ListSecurityMonitoringSignals = keyof Response$ListSecurityMonitoringSignals$Status$200;
export interface Params$ListSecurityMonitoringSignals {
    parameter: Parameter$ListSecurityMonitoringSignals;
}
export type RequestContentType$SearchSecurityMonitoringSignals = keyof RequestBody$SearchSecurityMonitoringSignals;
export type ResponseContentType$SearchSecurityMonitoringSignals = keyof Response$SearchSecurityMonitoringSignals$Status$200;
export interface Params$SearchSecurityMonitoringSignals {
    requestBody: RequestBody$SearchSecurityMonitoringSignals["application/json"];
}
export type RequestContentType$CreateServiceAccount = keyof RequestBody$CreateServiceAccount;
export type ResponseContentType$CreateServiceAccount = keyof Response$CreateServiceAccount$Status$201;
export interface Params$CreateServiceAccount {
    requestBody: RequestBody$CreateServiceAccount["application/json"];
}
export type ResponseContentType$ListServiceAccountApplicationKeys = keyof Response$ListServiceAccountApplicationKeys$Status$200;
export interface Params$ListServiceAccountApplicationKeys {
    parameter: Parameter$ListServiceAccountApplicationKeys;
}
export type RequestContentType$CreateServiceAccountApplicationKey = keyof RequestBody$CreateServiceAccountApplicationKey;
export type ResponseContentType$CreateServiceAccountApplicationKey = keyof Response$CreateServiceAccountApplicationKey$Status$201;
export interface Params$CreateServiceAccountApplicationKey {
    parameter: Parameter$CreateServiceAccountApplicationKey;
    requestBody: RequestBody$CreateServiceAccountApplicationKey["application/json"];
}
export type ResponseContentType$GetServiceAccountApplicationKey = keyof Response$GetServiceAccountApplicationKey$Status$200;
export interface Params$GetServiceAccountApplicationKey {
    parameter: Parameter$GetServiceAccountApplicationKey;
}
export interface Params$DeleteServiceAccountApplicationKey {
    parameter: Parameter$DeleteServiceAccountApplicationKey;
}
export type RequestContentType$UpdateServiceAccountApplicationKey = keyof RequestBody$UpdateServiceAccountApplicationKey;
export type ResponseContentType$UpdateServiceAccountApplicationKey = keyof Response$UpdateServiceAccountApplicationKey$Status$200;
export interface Params$UpdateServiceAccountApplicationKey {
    parameter: Parameter$UpdateServiceAccountApplicationKey;
    requestBody: RequestBody$UpdateServiceAccountApplicationKey["application/json"];
}
export type ResponseContentType$ListIncidentServices = keyof Response$ListIncidentServices$Status$200;
export interface Params$ListIncidentServices {
    parameter: Parameter$ListIncidentServices;
}
export type RequestContentType$CreateIncidentService = keyof RequestBody$CreateIncidentService;
export type ResponseContentType$CreateIncidentService = keyof Response$CreateIncidentService$Status$201;
export interface Params$CreateIncidentService {
    requestBody: RequestBody$CreateIncidentService["application/json"];
}
export type ResponseContentType$GetIncidentService = keyof Response$GetIncidentService$Status$200;
export interface Params$GetIncidentService {
    parameter: Parameter$GetIncidentService;
}
export interface Params$DeleteIncidentService {
    parameter: Parameter$DeleteIncidentService;
}
export type RequestContentType$UpdateIncidentService = keyof RequestBody$UpdateIncidentService;
export type ResponseContentType$UpdateIncidentService = keyof Response$UpdateIncidentService$Status$200;
export interface Params$UpdateIncidentService {
    parameter: Parameter$UpdateIncidentService;
    requestBody: RequestBody$UpdateIncidentService["application/json"];
}
export type ResponseContentType$ListIncidentTeams = keyof Response$ListIncidentTeams$Status$200;
export interface Params$ListIncidentTeams {
    parameter: Parameter$ListIncidentTeams;
}
export type RequestContentType$CreateIncidentTeam = keyof RequestBody$CreateIncidentTeam;
export type ResponseContentType$CreateIncidentTeam = keyof Response$CreateIncidentTeam$Status$201;
export interface Params$CreateIncidentTeam {
    requestBody: RequestBody$CreateIncidentTeam["application/json"];
}
export type ResponseContentType$GetIncidentTeam = keyof Response$GetIncidentTeam$Status$200;
export interface Params$GetIncidentTeam {
    parameter: Parameter$GetIncidentTeam;
}
export interface Params$DeleteIncidentTeam {
    parameter: Parameter$DeleteIncidentTeam;
}
export type RequestContentType$UpdateIncidentTeam = keyof RequestBody$UpdateIncidentTeam;
export type ResponseContentType$UpdateIncidentTeam = keyof Response$UpdateIncidentTeam$Status$200;
export interface Params$UpdateIncidentTeam {
    parameter: Parameter$UpdateIncidentTeam;
    requestBody: RequestBody$UpdateIncidentTeam["application/json"];
}
export type RequestContentType$SendInvitations = keyof RequestBody$SendInvitations;
export type ResponseContentType$SendInvitations = keyof Response$SendInvitations$Status$201;
export interface Params$SendInvitations {
    requestBody: RequestBody$SendInvitations["application/json"];
}
export type ResponseContentType$GetInvitation = keyof Response$GetInvitation$Status$200;
export interface Params$GetInvitation {
    parameter: Parameter$GetInvitation;
}
export type ResponseContentType$ListUsers = keyof Response$ListUsers$Status$200;
export interface Params$ListUsers {
    parameter: Parameter$ListUsers;
}
export type RequestContentType$CreateUser = keyof RequestBody$CreateUser;
export type ResponseContentType$CreateUser = keyof Response$CreateUser$Status$201;
export interface Params$CreateUser {
    requestBody: RequestBody$CreateUser["application/json"];
}
export type ResponseContentType$GetUser = keyof Response$GetUser$Status$200;
export interface Params$GetUser {
    parameter: Parameter$GetUser;
}
export interface Params$DisableUser {
    parameter: Parameter$DisableUser;
}
export type RequestContentType$UpdateUser = keyof RequestBody$UpdateUser;
export type ResponseContentType$UpdateUser = keyof Response$UpdateUser$Status$200;
export interface Params$UpdateUser {
    parameter: Parameter$UpdateUser;
    requestBody: RequestBody$UpdateUser["application/json"];
}
export type ResponseContentType$ListUserOrganizations = keyof Response$ListUserOrganizations$Status$200;
export interface Params$ListUserOrganizations {
    parameter: Parameter$ListUserOrganizations;
}
export type ResponseContentType$ListUserPermissions = keyof Response$ListUserPermissions$Status$200;
export interface Params$ListUserPermissions {
    parameter: Parameter$ListUserPermissions;
}
export type HttpMethod = "GET" | "PUT" | "POST" | "DELETE" | "OPTIONS" | "HEAD" | "PATCH" | "TRACE";
export interface ObjectLike {
    [key: string]: any;
}
export interface QueryParameter {
    value: any;
    style?: "form" | "spaceDelimited" | "pipeDelimited" | "deepObject";
    explode: boolean;
}
export interface QueryParameters {
    [key: string]: QueryParameter;
}
export type SuccessResponses = Response$ListAPIKeys$Status$200 | Response$CreateAPIKey$Status$201 | Response$GetAPIKey$Status$200 | Response$UpdateAPIKey$Status$200 | Response$ListApplicationKeys$Status$200 | Response$GetApplicationKey$Status$200 | Response$UpdateApplicationKey$Status$200 | Response$ListAuthNMappings$Status$200 | Response$CreateAuthNMapping$Status$200 | Response$GetAuthNMapping$Status$200 | Response$UpdateAuthNMapping$Status$200 | Response$ListCurrentUserApplicationKeys$Status$200 | Response$CreateCurrentUserApplicationKey$Status$201 | Response$GetCurrentUserApplicationKey$Status$200 | Response$UpdateCurrentUserApplicationKey$Status$200 | Response$GetDashboardListItems$Status$200 | Response$UpdateDashboardListItems$Status$200 | Response$CreateDashboardListItems$Status$200 | Response$DeleteDashboardListItems$Status$200 | Response$ListIncidents$Status$200 | Response$CreateIncident$Status$201 | Response$GetIncident$Status$200 | Response$UpdateIncident$Status$200 | Response$SubmitLog$Status$202 | Response$AggregateLogs$Status$200 | Response$GetLogsArchiveOrder$Status$200 | Response$UpdateLogsArchiveOrder$Status$200 | Response$ListLogsArchives$Status$200 | Response$CreateLogsArchive$Status$200 | Response$GetLogsArchive$Status$200 | Response$UpdateLogsArchive$Status$200 | Response$ListArchiveReadRoles$Status$200 | Response$ListLogsMetrics$Status$200 | Response$CreateLogsMetric$Status$200 | Response$GetLogsMetric$Status$200 | Response$UpdateLogsMetric$Status$200 | Response$ListLogsGet$Status$200 | Response$ListLogs$Status$200 | Response$ListTagConfigurations$Status$200 | Response$CreateBulkTagsMetricsConfiguration$Status$202 | Response$DeleteBulkTagsMetricsConfiguration$Status$202 | Response$ListTagsByMetricName$Status$200 | Response$ListTagConfigurationByName$Status$200 | Response$CreateTagConfiguration$Status$201 | Response$UpdateTagConfiguration$Status$200 | Response$ListVolumesByMetricName$Status$200 | Response$ListPermissions$Status$200 | Response$ListProcesses$Status$200 | Response$ListRoles$Status$200 | Response$CreateRole$Status$200 | Response$GetRole$Status$200 | Response$UpdateRole$Status$200 | Response$CloneRole$Status$200 | Response$ListRolePermissions$Status$200 | Response$AddPermissionToRole$Status$200 | Response$RemovePermissionFromRole$Status$200 | Response$ListRoleUsers$Status$200 | Response$AddUserToRole$Status$200 | Response$RemoveUserFromRole$Status$200 | Response$DownloadCloudWorkloadPolicyFile$Status$200 | Response$ListCloudWorkloadSecurityAgentRules$Status$200 | Response$CreateCloudWorkloadSecurityAgentRule$Status$200 | Response$GetCloudWorkloadSecurityAgentRule$Status$200 | Response$UpdateCloudWorkloadSecurityAgentRule$Status$200 | Response$ListSecurityFilters$Status$200 | Response$CreateSecurityFilter$Status$200 | Response$GetSecurityFilter$Status$200 | Response$UpdateSecurityFilter$Status$200 | Response$ListSecurityMonitoringRules$Status$200 | Response$CreateSecurityMonitoringRule$Status$200 | Response$GetSecurityMonitoringRule$Status$200 | Response$UpdateSecurityMonitoringRule$Status$200 | Response$ListSecurityMonitoringSignals$Status$200 | Response$SearchSecurityMonitoringSignals$Status$200 | Response$CreateServiceAccount$Status$201 | Response$ListServiceAccountApplicationKeys$Status$200 | Response$CreateServiceAccountApplicationKey$Status$201 | Response$GetServiceAccountApplicationKey$Status$200 | Response$UpdateServiceAccountApplicationKey$Status$200 | Response$ListIncidentServices$Status$200 | Response$CreateIncidentService$Status$201 | Response$GetIncidentService$Status$200 | Response$UpdateIncidentService$Status$200 | Response$ListIncidentTeams$Status$200 | Response$CreateIncidentTeam$Status$201 | Response$GetIncidentTeam$Status$200 | Response$UpdateIncidentTeam$Status$200 | Response$SendInvitations$Status$201 | Response$GetInvitation$Status$200 | Response$ListUsers$Status$200 | Response$CreateUser$Status$201 | Response$GetUser$Status$200 | Response$UpdateUser$Status$200 | Response$ListUserOrganizations$Status$200 | Response$ListUserPermissions$Status$200;
export namespace ErrorResponse {
    export type ListAPIKeys = Response$ListAPIKeys$Status$400 | Response$ListAPIKeys$Status$403 | Response$ListAPIKeys$Status$429;
    export type CreateAPIKey = Response$CreateAPIKey$Status$400 | Response$CreateAPIKey$Status$403 | Response$CreateAPIKey$Status$429;
    export type GetAPIKey = Response$GetAPIKey$Status$403 | Response$GetAPIKey$Status$404 | Response$GetAPIKey$Status$429;
    export type DeleteAPIKey = Response$DeleteAPIKey$Status$403 | Response$DeleteAPIKey$Status$404 | Response$DeleteAPIKey$Status$429;
    export type UpdateAPIKey = Response$UpdateAPIKey$Status$400 | Response$UpdateAPIKey$Status$403 | Response$UpdateAPIKey$Status$404 | Response$UpdateAPIKey$Status$429;
    export type ListApplicationKeys = Response$ListApplicationKeys$Status$400 | Response$ListApplicationKeys$Status$403 | Response$ListApplicationKeys$Status$404 | Response$ListApplicationKeys$Status$429;
    export type GetApplicationKey = Response$GetApplicationKey$Status$400 | Response$GetApplicationKey$Status$403 | Response$GetApplicationKey$Status$404 | Response$GetApplicationKey$Status$429;
    export type DeleteApplicationKey = Response$DeleteApplicationKey$Status$403 | Response$DeleteApplicationKey$Status$404 | Response$DeleteApplicationKey$Status$429;
    export type UpdateApplicationKey = Response$UpdateApplicationKey$Status$400 | Response$UpdateApplicationKey$Status$403 | Response$UpdateApplicationKey$Status$404 | Response$UpdateApplicationKey$Status$429;
    export type ListAuthNMappings = Response$ListAuthNMappings$Status$403 | Response$ListAuthNMappings$Status$429;
    export type CreateAuthNMapping = Response$CreateAuthNMapping$Status$400 | Response$CreateAuthNMapping$Status$403 | Response$CreateAuthNMapping$Status$404 | Response$CreateAuthNMapping$Status$429;
    export type GetAuthNMapping = Response$GetAuthNMapping$Status$403 | Response$GetAuthNMapping$Status$404 | Response$GetAuthNMapping$Status$429;
    export type DeleteAuthNMapping = Response$DeleteAuthNMapping$Status$403 | Response$DeleteAuthNMapping$Status$404 | Response$DeleteAuthNMapping$Status$429;
    export type UpdateAuthNMapping = Response$UpdateAuthNMapping$Status$400 | Response$UpdateAuthNMapping$Status$403 | Response$UpdateAuthNMapping$Status$404 | Response$UpdateAuthNMapping$Status$409 | Response$UpdateAuthNMapping$Status$422 | Response$UpdateAuthNMapping$Status$429;
    export type ListCurrentUserApplicationKeys = Response$ListCurrentUserApplicationKeys$Status$400 | Response$ListCurrentUserApplicationKeys$Status$403 | Response$ListCurrentUserApplicationKeys$Status$404 | Response$ListCurrentUserApplicationKeys$Status$429;
    export type CreateCurrentUserApplicationKey = Response$CreateCurrentUserApplicationKey$Status$400 | Response$CreateCurrentUserApplicationKey$Status$403 | Response$CreateCurrentUserApplicationKey$Status$429;
    export type GetCurrentUserApplicationKey = Response$GetCurrentUserApplicationKey$Status$403 | Response$GetCurrentUserApplicationKey$Status$404 | Response$GetCurrentUserApplicationKey$Status$429;
    export type DeleteCurrentUserApplicationKey = Response$DeleteCurrentUserApplicationKey$Status$403 | Response$DeleteCurrentUserApplicationKey$Status$404 | Response$DeleteCurrentUserApplicationKey$Status$429;
    export type UpdateCurrentUserApplicationKey = Response$UpdateCurrentUserApplicationKey$Status$400 | Response$UpdateCurrentUserApplicationKey$Status$403 | Response$UpdateCurrentUserApplicationKey$Status$404 | Response$UpdateCurrentUserApplicationKey$Status$429;
    export type GetDashboardListItems = Response$GetDashboardListItems$Status$403 | Response$GetDashboardListItems$Status$404 | Response$GetDashboardListItems$Status$429;
    export type UpdateDashboardListItems = Response$UpdateDashboardListItems$Status$400 | Response$UpdateDashboardListItems$Status$403 | Response$UpdateDashboardListItems$Status$404 | Response$UpdateDashboardListItems$Status$429;
    export type CreateDashboardListItems = Response$CreateDashboardListItems$Status$400 | Response$CreateDashboardListItems$Status$403 | Response$CreateDashboardListItems$Status$404 | Response$CreateDashboardListItems$Status$429;
    export type DeleteDashboardListItems = Response$DeleteDashboardListItems$Status$400 | Response$DeleteDashboardListItems$Status$403 | Response$DeleteDashboardListItems$Status$404 | Response$DeleteDashboardListItems$Status$429;
    export type ListIncidents = Response$ListIncidents$Status$400 | Response$ListIncidents$Status$401 | Response$ListIncidents$Status$403 | Response$ListIncidents$Status$404 | Response$ListIncidents$Status$429;
    export type CreateIncident = Response$CreateIncident$Status$400 | Response$CreateIncident$Status$401 | Response$CreateIncident$Status$403 | Response$CreateIncident$Status$404 | Response$CreateIncident$Status$429;
    export type GetIncident = Response$GetIncident$Status$400 | Response$GetIncident$Status$401 | Response$GetIncident$Status$403 | Response$GetIncident$Status$404 | Response$GetIncident$Status$429;
    export type DeleteIncident = Response$DeleteIncident$Status$400 | Response$DeleteIncident$Status$401 | Response$DeleteIncident$Status$403 | Response$DeleteIncident$Status$404 | Response$DeleteIncident$Status$429;
    export type UpdateIncident = Response$UpdateIncident$Status$400 | Response$UpdateIncident$Status$401 | Response$UpdateIncident$Status$403 | Response$UpdateIncident$Status$404 | Response$UpdateIncident$Status$429;
    export type SubmitLog = Response$SubmitLog$Status$400 | Response$SubmitLog$Status$401 | Response$SubmitLog$Status$403 | Response$SubmitLog$Status$408 | Response$SubmitLog$Status$413 | Response$SubmitLog$Status$429 | Response$SubmitLog$Status$500 | Response$SubmitLog$Status$503;
    export type AggregateLogs = Response$AggregateLogs$Status$400 | Response$AggregateLogs$Status$403 | Response$AggregateLogs$Status$429;
    export type GetLogsArchiveOrder = Response$GetLogsArchiveOrder$Status$403 | Response$GetLogsArchiveOrder$Status$429;
    export type UpdateLogsArchiveOrder = Response$UpdateLogsArchiveOrder$Status$400 | Response$UpdateLogsArchiveOrder$Status$403 | Response$UpdateLogsArchiveOrder$Status$422 | Response$UpdateLogsArchiveOrder$Status$429;
    export type ListLogsArchives = Response$ListLogsArchives$Status$403 | Response$ListLogsArchives$Status$429;
    export type CreateLogsArchive = Response$CreateLogsArchive$Status$400 | Response$CreateLogsArchive$Status$403 | Response$CreateLogsArchive$Status$429;
    export type GetLogsArchive = Response$GetLogsArchive$Status$400 | Response$GetLogsArchive$Status$403 | Response$GetLogsArchive$Status$404 | Response$GetLogsArchive$Status$429;
    export type UpdateLogsArchive = Response$UpdateLogsArchive$Status$400 | Response$UpdateLogsArchive$Status$403 | Response$UpdateLogsArchive$Status$404 | Response$UpdateLogsArchive$Status$429;
    export type DeleteLogsArchive = Response$DeleteLogsArchive$Status$400 | Response$DeleteLogsArchive$Status$403 | Response$DeleteLogsArchive$Status$404 | Response$DeleteLogsArchive$Status$429;
    export type ListArchiveReadRoles = Response$ListArchiveReadRoles$Status$400 | Response$ListArchiveReadRoles$Status$403 | Response$ListArchiveReadRoles$Status$404 | Response$ListArchiveReadRoles$Status$429;
    export type AddReadRoleToArchive = Response$AddReadRoleToArchive$Status$400 | Response$AddReadRoleToArchive$Status$403 | Response$AddReadRoleToArchive$Status$404 | Response$AddReadRoleToArchive$Status$429;
    export type RemoveRoleFromArchive = Response$RemoveRoleFromArchive$Status$400 | Response$RemoveRoleFromArchive$Status$403 | Response$RemoveRoleFromArchive$Status$404 | Response$RemoveRoleFromArchive$Status$429;
    export type ListLogsMetrics = Response$ListLogsMetrics$Status$403 | Response$ListLogsMetrics$Status$429;
    export type CreateLogsMetric = Response$CreateLogsMetric$Status$400 | Response$CreateLogsMetric$Status$403 | Response$CreateLogsMetric$Status$409 | Response$CreateLogsMetric$Status$429;
    export type GetLogsMetric = Response$GetLogsMetric$Status$403 | Response$GetLogsMetric$Status$404 | Response$GetLogsMetric$Status$429;
    export type DeleteLogsMetric = Response$DeleteLogsMetric$Status$403 | Response$DeleteLogsMetric$Status$404 | Response$DeleteLogsMetric$Status$429;
    export type UpdateLogsMetric = Response$UpdateLogsMetric$Status$400 | Response$UpdateLogsMetric$Status$403 | Response$UpdateLogsMetric$Status$404 | Response$UpdateLogsMetric$Status$429;
    export type ListLogsGet = Response$ListLogsGet$Status$400 | Response$ListLogsGet$Status$403 | Response$ListLogsGet$Status$429;
    export type ListLogs = Response$ListLogs$Status$400 | Response$ListLogs$Status$403 | Response$ListLogs$Status$429;
    export type ListTagConfigurations = Response$ListTagConfigurations$Status$400 | Response$ListTagConfigurations$Status$403 | Response$ListTagConfigurations$Status$429;
    export type CreateBulkTagsMetricsConfiguration = Response$CreateBulkTagsMetricsConfiguration$Status$400 | Response$CreateBulkTagsMetricsConfiguration$Status$403 | Response$CreateBulkTagsMetricsConfiguration$Status$404 | Response$CreateBulkTagsMetricsConfiguration$Status$429;
    export type DeleteBulkTagsMetricsConfiguration = Response$DeleteBulkTagsMetricsConfiguration$Status$400 | Response$DeleteBulkTagsMetricsConfiguration$Status$403 | Response$DeleteBulkTagsMetricsConfiguration$Status$404 | Response$DeleteBulkTagsMetricsConfiguration$Status$429;
    export type ListTagsByMetricName = Response$ListTagsByMetricName$Status$400 | Response$ListTagsByMetricName$Status$403 | Response$ListTagsByMetricName$Status$404 | Response$ListTagsByMetricName$Status$429;
    export type ListTagConfigurationByName = Response$ListTagConfigurationByName$Status$403 | Response$ListTagConfigurationByName$Status$404 | Response$ListTagConfigurationByName$Status$429;
    export type CreateTagConfiguration = Response$CreateTagConfiguration$Status$400 | Response$CreateTagConfiguration$Status$403 | Response$CreateTagConfiguration$Status$409 | Response$CreateTagConfiguration$Status$429;
    export type DeleteTagConfiguration = Response$DeleteTagConfiguration$Status$403 | Response$DeleteTagConfiguration$Status$404 | Response$DeleteTagConfiguration$Status$429;
    export type UpdateTagConfiguration = Response$UpdateTagConfiguration$Status$400 | Response$UpdateTagConfiguration$Status$403 | Response$UpdateTagConfiguration$Status$422 | Response$UpdateTagConfiguration$Status$429;
    export type ListVolumesByMetricName = Response$ListVolumesByMetricName$Status$400 | Response$ListVolumesByMetricName$Status$403 | Response$ListVolumesByMetricName$Status$404 | Response$ListVolumesByMetricName$Status$429;
    export type ListPermissions = Response$ListPermissions$Status$400 | Response$ListPermissions$Status$403 | Response$ListPermissions$Status$429;
    export type ListProcesses = Response$ListProcesses$Status$400 | Response$ListProcesses$Status$403 | Response$ListProcesses$Status$429;
    export type ListRoles = Response$ListRoles$Status$403 | Response$ListRoles$Status$429;
    export type CreateRole = Response$CreateRole$Status$400 | Response$CreateRole$Status$403 | Response$CreateRole$Status$429;
    export type GetRole = Response$GetRole$Status$403 | Response$GetRole$Status$404 | Response$GetRole$Status$429;
    export type DeleteRole = Response$DeleteRole$Status$403 | Response$DeleteRole$Status$404 | Response$DeleteRole$Status$429;
    export type UpdateRole = Response$UpdateRole$Status$400 | Response$UpdateRole$Status$403 | Response$UpdateRole$Status$404 | Response$UpdateRole$Status$422 | Response$UpdateRole$Status$429;
    export type CloneRole = Response$CloneRole$Status$400 | Response$CloneRole$Status$403 | Response$CloneRole$Status$404 | Response$CloneRole$Status$409 | Response$CloneRole$Status$429;
    export type ListRolePermissions = Response$ListRolePermissions$Status$403 | Response$ListRolePermissions$Status$404 | Response$ListRolePermissions$Status$429;
    export type AddPermissionToRole = Response$AddPermissionToRole$Status$400 | Response$AddPermissionToRole$Status$403 | Response$AddPermissionToRole$Status$404 | Response$AddPermissionToRole$Status$429;
    export type RemovePermissionFromRole = Response$RemovePermissionFromRole$Status$400 | Response$RemovePermissionFromRole$Status$403 | Response$RemovePermissionFromRole$Status$404 | Response$RemovePermissionFromRole$Status$429;
    export type ListRoleUsers = Response$ListRoleUsers$Status$403 | Response$ListRoleUsers$Status$404 | Response$ListRoleUsers$Status$429;
    export type AddUserToRole = Response$AddUserToRole$Status$400 | Response$AddUserToRole$Status$403 | Response$AddUserToRole$Status$404 | Response$AddUserToRole$Status$429;
    export type RemoveUserFromRole = Response$RemoveUserFromRole$Status$400 | Response$RemoveUserFromRole$Status$403 | Response$RemoveUserFromRole$Status$404 | Response$RemoveUserFromRole$Status$429;
    export type DownloadCloudWorkloadPolicyFile = Response$DownloadCloudWorkloadPolicyFile$Status$403 | Response$DownloadCloudWorkloadPolicyFile$Status$429;
    export type ListCloudWorkloadSecurityAgentRules = Response$ListCloudWorkloadSecurityAgentRules$Status$403 | Response$ListCloudWorkloadSecurityAgentRules$Status$429;
    export type CreateCloudWorkloadSecurityAgentRule = Response$CreateCloudWorkloadSecurityAgentRule$Status$400 | Response$CreateCloudWorkloadSecurityAgentRule$Status$403 | Response$CreateCloudWorkloadSecurityAgentRule$Status$409 | Response$CreateCloudWorkloadSecurityAgentRule$Status$429;
    export type GetCloudWorkloadSecurityAgentRule = Response$GetCloudWorkloadSecurityAgentRule$Status$403 | Response$GetCloudWorkloadSecurityAgentRule$Status$404 | Response$GetCloudWorkloadSecurityAgentRule$Status$429;
    export type DeleteCloudWorkloadSecurityAgentRule = Response$DeleteCloudWorkloadSecurityAgentRule$Status$403 | Response$DeleteCloudWorkloadSecurityAgentRule$Status$404 | Response$DeleteCloudWorkloadSecurityAgentRule$Status$429;
    export type UpdateCloudWorkloadSecurityAgentRule = Response$UpdateCloudWorkloadSecurityAgentRule$Status$400 | Response$UpdateCloudWorkloadSecurityAgentRule$Status$403 | Response$UpdateCloudWorkloadSecurityAgentRule$Status$404 | Response$UpdateCloudWorkloadSecurityAgentRule$Status$409 | Response$UpdateCloudWorkloadSecurityAgentRule$Status$429;
    export type ListSecurityFilters = Response$ListSecurityFilters$Status$403 | Response$ListSecurityFilters$Status$429;
    export type CreateSecurityFilter = Response$CreateSecurityFilter$Status$400 | Response$CreateSecurityFilter$Status$403 | Response$CreateSecurityFilter$Status$409 | Response$CreateSecurityFilter$Status$429;
    export type GetSecurityFilter = Response$GetSecurityFilter$Status$403 | Response$GetSecurityFilter$Status$404 | Response$GetSecurityFilter$Status$429;
    export type DeleteSecurityFilter = Response$DeleteSecurityFilter$Status$403 | Response$DeleteSecurityFilter$Status$404 | Response$DeleteSecurityFilter$Status$429;
    export type UpdateSecurityFilter = Response$UpdateSecurityFilter$Status$400 | Response$UpdateSecurityFilter$Status$403 | Response$UpdateSecurityFilter$Status$404 | Response$UpdateSecurityFilter$Status$409 | Response$UpdateSecurityFilter$Status$429;
    export type ListSecurityMonitoringRules = Response$ListSecurityMonitoringRules$Status$400 | Response$ListSecurityMonitoringRules$Status$429;
    export type CreateSecurityMonitoringRule = Response$CreateSecurityMonitoringRule$Status$400 | Response$CreateSecurityMonitoringRule$Status$403 | Response$CreateSecurityMonitoringRule$Status$429;
    export type GetSecurityMonitoringRule = Response$GetSecurityMonitoringRule$Status$404 | Response$GetSecurityMonitoringRule$Status$429;
    export type UpdateSecurityMonitoringRule = Response$UpdateSecurityMonitoringRule$Status$400 | Response$UpdateSecurityMonitoringRule$Status$401 | Response$UpdateSecurityMonitoringRule$Status$403 | Response$UpdateSecurityMonitoringRule$Status$404 | Response$UpdateSecurityMonitoringRule$Status$429;
    export type DeleteSecurityMonitoringRule = Response$DeleteSecurityMonitoringRule$Status$403 | Response$DeleteSecurityMonitoringRule$Status$404 | Response$DeleteSecurityMonitoringRule$Status$429;
    export type ListSecurityMonitoringSignals = Response$ListSecurityMonitoringSignals$Status$400 | Response$ListSecurityMonitoringSignals$Status$403 | Response$ListSecurityMonitoringSignals$Status$429;
    export type SearchSecurityMonitoringSignals = Response$SearchSecurityMonitoringSignals$Status$400 | Response$SearchSecurityMonitoringSignals$Status$403 | Response$SearchSecurityMonitoringSignals$Status$429;
    export type CreateServiceAccount = Response$CreateServiceAccount$Status$400 | Response$CreateServiceAccount$Status$403 | Response$CreateServiceAccount$Status$429;
    export type ListServiceAccountApplicationKeys = Response$ListServiceAccountApplicationKeys$Status$400 | Response$ListServiceAccountApplicationKeys$Status$403 | Response$ListServiceAccountApplicationKeys$Status$404 | Response$ListServiceAccountApplicationKeys$Status$429;
    export type CreateServiceAccountApplicationKey = Response$CreateServiceAccountApplicationKey$Status$400 | Response$CreateServiceAccountApplicationKey$Status$403 | Response$CreateServiceAccountApplicationKey$Status$429;
    export type GetServiceAccountApplicationKey = Response$GetServiceAccountApplicationKey$Status$403 | Response$GetServiceAccountApplicationKey$Status$404 | Response$GetServiceAccountApplicationKey$Status$429;
    export type DeleteServiceAccountApplicationKey = Response$DeleteServiceAccountApplicationKey$Status$403 | Response$DeleteServiceAccountApplicationKey$Status$404 | Response$DeleteServiceAccountApplicationKey$Status$429;
    export type UpdateServiceAccountApplicationKey = Response$UpdateServiceAccountApplicationKey$Status$400 | Response$UpdateServiceAccountApplicationKey$Status$403 | Response$UpdateServiceAccountApplicationKey$Status$404 | Response$UpdateServiceAccountApplicationKey$Status$429;
    export type ListIncidentServices = Response$ListIncidentServices$Status$400 | Response$ListIncidentServices$Status$401 | Response$ListIncidentServices$Status$403 | Response$ListIncidentServices$Status$404 | Response$ListIncidentServices$Status$429;
    export type CreateIncidentService = Response$CreateIncidentService$Status$400 | Response$CreateIncidentService$Status$401 | Response$CreateIncidentService$Status$403 | Response$CreateIncidentService$Status$404 | Response$CreateIncidentService$Status$429;
    export type GetIncidentService = Response$GetIncidentService$Status$400 | Response$GetIncidentService$Status$401 | Response$GetIncidentService$Status$403 | Response$GetIncidentService$Status$404 | Response$GetIncidentService$Status$429;
    export type DeleteIncidentService = Response$DeleteIncidentService$Status$400 | Response$DeleteIncidentService$Status$401 | Response$DeleteIncidentService$Status$403 | Response$DeleteIncidentService$Status$404 | Response$DeleteIncidentService$Status$429;
    export type UpdateIncidentService = Response$UpdateIncidentService$Status$400 | Response$UpdateIncidentService$Status$401 | Response$UpdateIncidentService$Status$403 | Response$UpdateIncidentService$Status$404 | Response$UpdateIncidentService$Status$429;
    export type ListIncidentTeams = Response$ListIncidentTeams$Status$400 | Response$ListIncidentTeams$Status$401 | Response$ListIncidentTeams$Status$403 | Response$ListIncidentTeams$Status$404 | Response$ListIncidentTeams$Status$429;
    export type CreateIncidentTeam = Response$CreateIncidentTeam$Status$400 | Response$CreateIncidentTeam$Status$401 | Response$CreateIncidentTeam$Status$403 | Response$CreateIncidentTeam$Status$404 | Response$CreateIncidentTeam$Status$429;
    export type GetIncidentTeam = Response$GetIncidentTeam$Status$400 | Response$GetIncidentTeam$Status$401 | Response$GetIncidentTeam$Status$403 | Response$GetIncidentTeam$Status$404 | Response$GetIncidentTeam$Status$429;
    export type DeleteIncidentTeam = Response$DeleteIncidentTeam$Status$400 | Response$DeleteIncidentTeam$Status$401 | Response$DeleteIncidentTeam$Status$403 | Response$DeleteIncidentTeam$Status$404 | Response$DeleteIncidentTeam$Status$429;
    export type UpdateIncidentTeam = Response$UpdateIncidentTeam$Status$400 | Response$UpdateIncidentTeam$Status$401 | Response$UpdateIncidentTeam$Status$403 | Response$UpdateIncidentTeam$Status$404 | Response$UpdateIncidentTeam$Status$429;
    export type SendInvitations = Response$SendInvitations$Status$400 | Response$SendInvitations$Status$403 | Response$SendInvitations$Status$429;
    export type GetInvitation = Response$GetInvitation$Status$403 | Response$GetInvitation$Status$404 | Response$GetInvitation$Status$429;
    export type ListUsers = Response$ListUsers$Status$400 | Response$ListUsers$Status$403 | Response$ListUsers$Status$429;
    export type CreateUser = Response$CreateUser$Status$400 | Response$CreateUser$Status$403 | Response$CreateUser$Status$429;
    export type GetUser = Response$GetUser$Status$403 | Response$GetUser$Status$404 | Response$GetUser$Status$429;
    export type DisableUser = Response$DisableUser$Status$403 | Response$DisableUser$Status$404 | Response$DisableUser$Status$429;
    export type UpdateUser = Response$UpdateUser$Status$400 | Response$UpdateUser$Status$403 | Response$UpdateUser$Status$404 | Response$UpdateUser$Status$422 | Response$UpdateUser$Status$429;
    export type ListUserOrganizations = Response$ListUserOrganizations$Status$403 | Response$ListUserOrganizations$Status$404 | Response$ListUserOrganizations$Status$429;
    export type ListUserPermissions = Response$ListUserPermissions$Status$403 | Response$ListUserPermissions$Status$404 | Response$ListUserPermissions$Status$429;
}
export interface ApiClient<RequestOption> {
    request: <T = SuccessResponses>(httpMethod: HttpMethod, url: string, headers: ObjectLike | any, requestBody: ObjectLike | any, queryParameters: QueryParameters | undefined, options?: RequestOption) => Promise<T>;
}
export class Client<RequestOption> {
    private baseUrl: string;
    constructor(private apiClient: ApiClient<RequestOption>, baseUrl: string) { this.baseUrl = baseUrl.replace(/\/$/, ""); }
    /**
     * Get all API keys
     * List all API keys available for your account.
     * operationId: ListAPIKeys
     * Request URI: /api/v2/api_keys
     */
    public async ListAPIKeys(params: Params$ListAPIKeys, option?: RequestOption): Promise<Response$ListAPIKeys$Status$200["application/json"]> {
        const url = this.baseUrl + `/api/v2/api_keys`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            "page[size]": { value: params.parameter["page[size]"], explode: false },
            "page[number]": { value: params.parameter["page[number]"], explode: false },
            sort: { value: params.parameter.sort, explode: false },
            filter: { value: params.parameter.filter, explode: false },
            "filter[created_at][start]": { value: params.parameter["filter[created_at][start]"], explode: false },
            "filter[created_at][end]": { value: params.parameter["filter[created_at][end]"], explode: false },
            "filter[modified_at][start]": { value: params.parameter["filter[modified_at][start]"], explode: false },
            "filter[modified_at][end]": { value: params.parameter["filter[modified_at][end]"], explode: false },
            include: { value: params.parameter.include, explode: false }
        };
        return this.apiClient.request("GET", url, headers, undefined, queryParameters, option);
    }
    /**
     * Create an API key
     * Create an API key.
     * operationId: CreateAPIKey
     * Request URI: /api/v2/api_keys
     */
    public async CreateAPIKey(params: Params$CreateAPIKey, option?: RequestOption): Promise<Response$CreateAPIKey$Status$201["application/json"]> {
        const url = this.baseUrl + `/api/v2/api_keys`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request("POST", url, headers, params.requestBody, undefined, option);
    }
    /**
     * Get API key
     * Get an API key.
     * operationId: GetAPIKey
     * Request URI: /api/v2/api_keys/{api_key_id}
     */
    public async GetAPIKey(params: Params$GetAPIKey, option?: RequestOption): Promise<Response$GetAPIKey$Status$200["application/json"]> {
        const url = this.baseUrl + `/api/v2/api_keys/${params.parameter.api_key_id}`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            include: { value: params.parameter.include, explode: false }
        };
        return this.apiClient.request("GET", url, headers, undefined, queryParameters, option);
    }
    /**
     * Delete an API key
     * Delete an API key.
     * operationId: DeleteAPIKey
     * Request URI: /api/v2/api_keys/{api_key_id}
     */
    public async DeleteAPIKey(params: Params$DeleteAPIKey, option?: RequestOption): Promise<void> {
        const url = this.baseUrl + `/api/v2/api_keys/${params.parameter.api_key_id}`;
        const headers = {};
        return this.apiClient.request("DELETE", url, headers, undefined, undefined, option);
    }
    /**
     * Edit an API key
     * Update an API key.
     * operationId: UpdateAPIKey
     * Request URI: /api/v2/api_keys/{api_key_id}
     */
    public async UpdateAPIKey(params: Params$UpdateAPIKey, option?: RequestOption): Promise<Response$UpdateAPIKey$Status$200["application/json"]> {
        const url = this.baseUrl + `/api/v2/api_keys/${params.parameter.api_key_id}`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request("PATCH", url, headers, params.requestBody, undefined, option);
    }
    /**
     * Get all application keys
     * List all application keys available for your org
     * operationId: ListApplicationKeys
     * Request URI: /api/v2/application_keys
     */
    public async ListApplicationKeys(params: Params$ListApplicationKeys, option?: RequestOption): Promise<Response$ListApplicationKeys$Status$200["application/json"]> {
        const url = this.baseUrl + `/api/v2/application_keys`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            "page[size]": { value: params.parameter["page[size]"], explode: false },
            "page[number]": { value: params.parameter["page[number]"], explode: false },
            sort: { value: params.parameter.sort, explode: false },
            filter: { value: params.parameter.filter, explode: false },
            "filter[created_at][start]": { value: params.parameter["filter[created_at][start]"], explode: false },
            "filter[created_at][end]": { value: params.parameter["filter[created_at][end]"], explode: false }
        };
        return this.apiClient.request("GET", url, headers, undefined, queryParameters, option);
    }
    /**
     * Get an application key
     * Get an application key for your org.
     * operationId: GetApplicationKey
     * Request URI: /api/v2/application_keys/{app_key_id}
     */
    public async GetApplicationKey(params: Params$GetApplicationKey, option?: RequestOption): Promise<Response$GetApplicationKey$Status$200["application/json"]> {
        const url = this.baseUrl + `/api/v2/application_keys/${params.parameter.app_key_id}`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            include: { value: params.parameter.include, explode: false }
        };
        return this.apiClient.request("GET", url, headers, undefined, queryParameters, option);
    }
    /**
     * Delete an application key
     * Delete an application key
     * operationId: DeleteApplicationKey
     * Request URI: /api/v2/application_keys/{app_key_id}
     */
    public async DeleteApplicationKey(params: Params$DeleteApplicationKey, option?: RequestOption): Promise<void> {
        const url = this.baseUrl + `/api/v2/application_keys/${params.parameter.app_key_id}`;
        const headers = {};
        return this.apiClient.request("DELETE", url, headers, undefined, undefined, option);
    }
    /**
     * Edit an application key
     * Edit an application key
     * operationId: UpdateApplicationKey
     * Request URI: /api/v2/application_keys/{app_key_id}
     */
    public async UpdateApplicationKey(params: Params$UpdateApplicationKey, option?: RequestOption): Promise<Response$UpdateApplicationKey$Status$200["application/json"]> {
        const url = this.baseUrl + `/api/v2/application_keys/${params.parameter.app_key_id}`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request("PATCH", url, headers, params.requestBody, undefined, option);
    }
    /**
     * List all AuthN Mappings
     * List all AuthN Mappings in the org.
     * operationId: ListAuthNMappings
     * Request URI: /api/v2/authn_mappings
     */
    public async ListAuthNMappings(params: Params$ListAuthNMappings, option?: RequestOption): Promise<Response$ListAuthNMappings$Status$200["application/json"]> {
        const url = this.baseUrl + `/api/v2/authn_mappings`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            "page[size]": { value: params.parameter["page[size]"], explode: false },
            "page[number]": { value: params.parameter["page[number]"], explode: false },
            sort: { value: params.parameter.sort, explode: false },
            include: { value: params.parameter.include, explode: false },
            filter: { value: params.parameter.filter, explode: false }
        };
        return this.apiClient.request("GET", url, headers, undefined, queryParameters, option);
    }
    /**
     * Create an AuthN Mapping
     * Create an AuthN Mapping.
     * operationId: CreateAuthNMapping
     * Request URI: /api/v2/authn_mappings
     */
    public async CreateAuthNMapping(params: Params$CreateAuthNMapping, option?: RequestOption): Promise<Response$CreateAuthNMapping$Status$200["application/json"]> {
        const url = this.baseUrl + `/api/v2/authn_mappings`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request("POST", url, headers, params.requestBody, undefined, option);
    }
    /**
     * Get an AuthN Mapping by UUID
     * Get an AuthN Mapping specified by the AuthN Mapping UUID.
     * operationId: GetAuthNMapping
     * Request URI: /api/v2/authn_mappings/{authn_mapping_id}
     */
    public async GetAuthNMapping(params: Params$GetAuthNMapping, option?: RequestOption): Promise<Response$GetAuthNMapping$Status$200["application/json"]> {
        const url = this.baseUrl + `/api/v2/authn_mappings/${params.parameter.authn_mapping_id}`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request("GET", url, headers, undefined, undefined, option);
    }
    /**
     * Delete an AuthN Mapping
     * Delete an AuthN Mapping specified by AuthN Mapping UUID.
     * operationId: DeleteAuthNMapping
     * Request URI: /api/v2/authn_mappings/{authn_mapping_id}
     */
    public async DeleteAuthNMapping(params: Params$DeleteAuthNMapping, option?: RequestOption): Promise<void> {
        const url = this.baseUrl + `/api/v2/authn_mappings/${params.parameter.authn_mapping_id}`;
        const headers = {};
        return this.apiClient.request("DELETE", url, headers, undefined, undefined, option);
    }
    /**
     * Edit an AuthN Mapping
     * Edit an AuthN Mapping.
     * operationId: UpdateAuthNMapping
     * Request URI: /api/v2/authn_mappings/{authn_mapping_id}
     */
    public async UpdateAuthNMapping(params: Params$UpdateAuthNMapping, option?: RequestOption): Promise<Response$UpdateAuthNMapping$Status$200["application/json"]> {
        const url = this.baseUrl + `/api/v2/authn_mappings/${params.parameter.authn_mapping_id}`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request("PATCH", url, headers, params.requestBody, undefined, option);
    }
    /**
     * Get all application keys owned by current user
     * List all application keys available for current user
     * operationId: ListCurrentUserApplicationKeys
     * Request URI: /api/v2/current_user/application_keys
     */
    public async ListCurrentUserApplicationKeys(params: Params$ListCurrentUserApplicationKeys, option?: RequestOption): Promise<Response$ListCurrentUserApplicationKeys$Status$200["application/json"]> {
        const url = this.baseUrl + `/api/v2/current_user/application_keys`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            "page[size]": { value: params.parameter["page[size]"], explode: false },
            "page[number]": { value: params.parameter["page[number]"], explode: false },
            sort: { value: params.parameter.sort, explode: false },
            filter: { value: params.parameter.filter, explode: false },
            "filter[created_at][start]": { value: params.parameter["filter[created_at][start]"], explode: false },
            "filter[created_at][end]": { value: params.parameter["filter[created_at][end]"], explode: false }
        };
        return this.apiClient.request("GET", url, headers, undefined, queryParameters, option);
    }
    /**
     * Create an application key for current user
     * Create an application key for current user
     * operationId: CreateCurrentUserApplicationKey
     * Request URI: /api/v2/current_user/application_keys
     */
    public async CreateCurrentUserApplicationKey(params: Params$CreateCurrentUserApplicationKey, option?: RequestOption): Promise<Response$CreateCurrentUserApplicationKey$Status$201["application/json"]> {
        const url = this.baseUrl + `/api/v2/current_user/application_keys`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request("POST", url, headers, params.requestBody, undefined, option);
    }
    /**
     * Get one application key owned by current user
     * Get an application key owned by current user
     * operationId: GetCurrentUserApplicationKey
     * Request URI: /api/v2/current_user/application_keys/{app_key_id}
     */
    public async GetCurrentUserApplicationKey(params: Params$GetCurrentUserApplicationKey, option?: RequestOption): Promise<Response$GetCurrentUserApplicationKey$Status$200["application/json"]> {
        const url = this.baseUrl + `/api/v2/current_user/application_keys/${params.parameter.app_key_id}`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request("GET", url, headers, undefined, undefined, option);
    }
    /**
     * Delete an application key owned by current user
     * Delete an application key owned by current user
     * operationId: DeleteCurrentUserApplicationKey
     * Request URI: /api/v2/current_user/application_keys/{app_key_id}
     */
    public async DeleteCurrentUserApplicationKey(params: Params$DeleteCurrentUserApplicationKey, option?: RequestOption): Promise<void> {
        const url = this.baseUrl + `/api/v2/current_user/application_keys/${params.parameter.app_key_id}`;
        const headers = {};
        return this.apiClient.request("DELETE", url, headers, undefined, undefined, option);
    }
    /**
     * Edit an application key owned by current user
     * Edit an application key owned by current user
     * operationId: UpdateCurrentUserApplicationKey
     * Request URI: /api/v2/current_user/application_keys/{app_key_id}
     */
    public async UpdateCurrentUserApplicationKey(params: Params$UpdateCurrentUserApplicationKey, option?: RequestOption): Promise<Response$UpdateCurrentUserApplicationKey$Status$200["application/json"]> {
        const url = this.baseUrl + `/api/v2/current_user/application_keys/${params.parameter.app_key_id}`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request("PATCH", url, headers, params.requestBody, undefined, option);
    }
    /**
     * Get items of a Dashboard List
     * Fetch the dashboard lists dashboard definitions.
     * operationId: GetDashboardListItems
     * Request URI: /api/v2/dashboard/lists/manual/{dashboard_list_id}/dashboards
     */
    public async GetDashboardListItems(params: Params$GetDashboardListItems, option?: RequestOption): Promise<Response$GetDashboardListItems$Status$200["application/json"]> {
        const url = this.baseUrl + `/api/v2/dashboard/lists/manual/${params.parameter.dashboard_list_id}/dashboards`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request("GET", url, headers, undefined, undefined, option);
    }
    /**
     * Update items of a dashboard list
     * Update dashboards of an existing dashboard list.
     * operationId: UpdateDashboardListItems
     * Request URI: /api/v2/dashboard/lists/manual/{dashboard_list_id}/dashboards
     */
    public async UpdateDashboardListItems(params: Params$UpdateDashboardListItems, option?: RequestOption): Promise<Response$UpdateDashboardListItems$Status$200["application/json"]> {
        const url = this.baseUrl + `/api/v2/dashboard/lists/manual/${params.parameter.dashboard_list_id}/dashboards`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request("PUT", url, headers, params.requestBody, undefined, option);
    }
    /**
     * Add Items to a Dashboard List
     * Add dashboards to an existing dashboard list.
     * operationId: CreateDashboardListItems
     * Request URI: /api/v2/dashboard/lists/manual/{dashboard_list_id}/dashboards
     */
    public async CreateDashboardListItems(params: Params$CreateDashboardListItems, option?: RequestOption): Promise<Response$CreateDashboardListItems$Status$200["application/json"]> {
        const url = this.baseUrl + `/api/v2/dashboard/lists/manual/${params.parameter.dashboard_list_id}/dashboards`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request("POST", url, headers, params.requestBody, undefined, option);
    }
    /**
     * Delete items from a dashboard list
     * Delete dashboards from an existing dashboard list.
     * operationId: DeleteDashboardListItems
     * Request URI: /api/v2/dashboard/lists/manual/{dashboard_list_id}/dashboards
     */
    public async DeleteDashboardListItems(params: Params$DeleteDashboardListItems, option?: RequestOption): Promise<Response$DeleteDashboardListItems$Status$200["application/json"]> {
        const url = this.baseUrl + `/api/v2/dashboard/lists/manual/${params.parameter.dashboard_list_id}/dashboards`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request("DELETE", url, headers, params.requestBody, undefined, option);
    }
    /**
     * Get a list of incidents
     * Get all incidents for the user's organization.
     * operationId: ListIncidents
     * Request URI: /api/v2/incidents
     */
    public async ListIncidents(params: Params$ListIncidents, option?: RequestOption): Promise<Response$ListIncidents$Status$200["application/json"]> {
        const url = this.baseUrl + `/api/v2/incidents`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            include: { value: params.parameter.include, explode: false },
            "page[size]": { value: params.parameter["page[size]"], explode: false },
            "page[offset]": { value: params.parameter["page[offset]"], explode: false }
        };
        return this.apiClient.request("GET", url, headers, undefined, queryParameters, option);
    }
    /**
     * Create an incident
     * Create an incident.
     * operationId: CreateIncident
     * Request URI: /api/v2/incidents
     */
    public async CreateIncident(params: Params$CreateIncident, option?: RequestOption): Promise<Response$CreateIncident$Status$201["application/json"]> {
        const url = this.baseUrl + `/api/v2/incidents`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request("POST", url, headers, params.requestBody, undefined, option);
    }
    /**
     * Get the details of an incident
     * Get the details of an incident by `incident_id`.
     * operationId: GetIncident
     * Request URI: /api/v2/incidents/{incident_id}
     */
    public async GetIncident(params: Params$GetIncident, option?: RequestOption): Promise<Response$GetIncident$Status$200["application/json"]> {
        const url = this.baseUrl + `/api/v2/incidents/${params.parameter.incident_id}`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            include: { value: params.parameter.include, explode: false }
        };
        return this.apiClient.request("GET", url, headers, undefined, queryParameters, option);
    }
    /**
     * Delete an existing incident
     * Deletes an existing incident from the users organization.
     * operationId: DeleteIncident
     * Request URI: /api/v2/incidents/{incident_id}
     */
    public async DeleteIncident(params: Params$DeleteIncident, option?: RequestOption): Promise<void> {
        const url = this.baseUrl + `/api/v2/incidents/${params.parameter.incident_id}`;
        const headers = {};
        return this.apiClient.request("DELETE", url, headers, undefined, undefined, option);
    }
    /**
     * Update an existing incident
     * Updates an incident. Provide only the attributes that should be updated as this request is a partial update.
     * operationId: UpdateIncident
     * Request URI: /api/v2/incidents/{incident_id}
     */
    public async UpdateIncident(params: Params$UpdateIncident, option?: RequestOption): Promise<Response$UpdateIncident$Status$200["application/json"]> {
        const url = this.baseUrl + `/api/v2/incidents/${params.parameter.incident_id}`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            include: { value: params.parameter.include, explode: false }
        };
        return this.apiClient.request("PATCH", url, headers, params.requestBody, queryParameters, option);
    }
    /**
     * Send logs
     * Send your logs to your Datadog platform over HTTP. Limits per HTTP request are:
     *
     * - Maximum content size per payload (uncompressed): 5MB
     * - Maximum size for a single log: 1MB
     * - Maximum array size if sending multiple logs in an array: 1000 entries
     *
     * Any log exceeding 1MB is accepted and truncated by Datadog:
     * - For a single log request, the API truncates the log at 1MB and returns a 2xx.
     * - For a multi-logs request, the API processes all logs, truncates only logs larger than 1MB, and returns a 2xx.
     *
     * Datadog recommends sending your logs compressed.
     * Add the `Content-Encoding: gzip` header to the request when sending compressed logs.
     *
     * The status codes answered by the HTTP API are:
     * - 202: Accepted: the request has been accepted for processing
     * - 400: Bad request (likely an issue in the payload formatting)
     * - 401: Unauthorized (likely a missing API Key)
     * - 403: Permission issue (likely using an invalid API Key)
     * - 408: Request Timeout, request should be retried after some time
     * - 413: Payload too large (batch is above 5MB uncompressed)
     * - 429: Too Many Requests, request should be retried after some time
     * - 500: Internal Server Error, the server encountered an unexpected condition that prevented it from fulfilling the request, request should be retried after some time
     * - 503: Service Unavailable, the server is not ready to handle the request probably because it is overloaded, request should be retried after some time
     * operationId: SubmitLog
     * Request URI: /api/v2/logs
     */
    public async SubmitLog<RequestContentType extends RequestContentType$SubmitLog>(params: Params$SubmitLog<RequestContentType>, option?: RequestOption): Promise<Response$SubmitLog$Status$202["application/json"]> {
        const url = this.baseUrl + `/api/v2/logs`;
        const headers = {
            "Content-Type": params.headers["Content-Type"],
            Accept: "application/json",
            "Content-Encoding": params.parameter["Content-Encoding"]
        };
        const queryParameters: QueryParameters = {
            ddtags: { value: params.parameter.ddtags, explode: false }
        };
        return this.apiClient.request("POST", url, headers, params.requestBody, queryParameters, option);
    }
    /**
     * Aggregate events
     * The API endpoint to aggregate events into buckets and compute metrics and timeseries.
     * operationId: AggregateLogs
     * Request URI: /api/v2/logs/analytics/aggregate
     */
    public async AggregateLogs(params: Params$AggregateLogs, option?: RequestOption): Promise<Response$AggregateLogs$Status$200["application/json"]> {
        const url = this.baseUrl + `/api/v2/logs/analytics/aggregate`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request("POST", url, headers, params.requestBody, undefined, option);
    }
    /**
     * Get archive order
     * Get the current order of your archives.
     * This endpoint takes no JSON arguments.
     * operationId: GetLogsArchiveOrder
     * Request URI: /api/v2/logs/config/archive-order
     */
    public async GetLogsArchiveOrder(option?: RequestOption): Promise<Response$GetLogsArchiveOrder$Status$200["application/json"]> {
        const url = this.baseUrl + `/api/v2/logs/config/archive-order`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request("GET", url, headers, undefined, undefined, option);
    }
    /**
     * Update archive order
     * Update the order of your archives. Since logs are processed sequentially, reordering an archive may change
     * the structure and content of the data processed by other archives.
     *
     * **Note**: Using the `PUT` method updates your archive's order by replacing the current order
     * with the new one.
     * operationId: UpdateLogsArchiveOrder
     * Request URI: /api/v2/logs/config/archive-order
     */
    public async UpdateLogsArchiveOrder(params: Params$UpdateLogsArchiveOrder, option?: RequestOption): Promise<Response$UpdateLogsArchiveOrder$Status$200["application/json"]> {
        const url = this.baseUrl + `/api/v2/logs/config/archive-order`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request("PUT", url, headers, params.requestBody, undefined, option);
    }
    /**
     * Get all archives
     * Get the list of configured logs archives with their definitions.
     * operationId: ListLogsArchives
     * Request URI: /api/v2/logs/config/archives
     */
    public async ListLogsArchives(option?: RequestOption): Promise<Response$ListLogsArchives$Status$200["application/json"]> {
        const url = this.baseUrl + `/api/v2/logs/config/archives`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request("GET", url, headers, undefined, undefined, option);
    }
    /**
     * Create an archive
     * Create an archive in your organization.
     * operationId: CreateLogsArchive
     * Request URI: /api/v2/logs/config/archives
     */
    public async CreateLogsArchive(params: Params$CreateLogsArchive, option?: RequestOption): Promise<Response$CreateLogsArchive$Status$200["application/json"]> {
        const url = this.baseUrl + `/api/v2/logs/config/archives`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request("POST", url, headers, params.requestBody, undefined, option);
    }
    /**
     * Get an archive
     * Get a specific archive from your organization.
     * operationId: GetLogsArchive
     * Request URI: /api/v2/logs/config/archives/{archive_id}
     */
    public async GetLogsArchive(params: Params$GetLogsArchive, option?: RequestOption): Promise<Response$GetLogsArchive$Status$200["application/json"]> {
        const url = this.baseUrl + `/api/v2/logs/config/archives/${params.parameter.archive_id}`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request("GET", url, headers, undefined, undefined, option);
    }
    /**
     * Update an archive
     * Update a given archive configuration.
     *
     * **Note**: Using this method updates your archive configuration by **replacing**
     * your current configuration with the new one sent to your Datadog organization.
     * operationId: UpdateLogsArchive
     * Request URI: /api/v2/logs/config/archives/{archive_id}
     */
    public async UpdateLogsArchive(params: Params$UpdateLogsArchive, option?: RequestOption): Promise<Response$UpdateLogsArchive$Status$200["application/json"]> {
        const url = this.baseUrl + `/api/v2/logs/config/archives/${params.parameter.archive_id}`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request("PUT", url, headers, params.requestBody, undefined, option);
    }
    /**
     * Delete an archive
     * Delete a given archive from your organization.
     * operationId: DeleteLogsArchive
     * Request URI: /api/v2/logs/config/archives/{archive_id}
     */
    public async DeleteLogsArchive(params: Params$DeleteLogsArchive, option?: RequestOption): Promise<void> {
        const url = this.baseUrl + `/api/v2/logs/config/archives/${params.parameter.archive_id}`;
        const headers = {};
        return this.apiClient.request("DELETE", url, headers, undefined, undefined, option);
    }
    /**
     * List read roles for an archive
     * Returns all read roles a given archive is restricted to.
     * operationId: ListArchiveReadRoles
     * Request URI: /api/v2/logs/config/archives/{archive_id}/readers
     */
    public async ListArchiveReadRoles(params: Params$ListArchiveReadRoles, option?: RequestOption): Promise<Response$ListArchiveReadRoles$Status$200["application/json"]> {
        const url = this.baseUrl + `/api/v2/logs/config/archives/${params.parameter.archive_id}/readers`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request("GET", url, headers, undefined, undefined, option);
    }
    /**
     * Grant role to an archive
     * Adds a read role to an archive. ([Roles API](https://docs.datadoghq.com/api/v2/roles/))
     * operationId: AddReadRoleToArchive
     * Request URI: /api/v2/logs/config/archives/{archive_id}/readers
     */
    public async AddReadRoleToArchive(params: Params$AddReadRoleToArchive, option?: RequestOption): Promise<void> {
        const url = this.baseUrl + `/api/v2/logs/config/archives/${params.parameter.archive_id}/readers`;
        const headers = {
            "Content-Type": "application/json"
        };
        return this.apiClient.request("POST", url, headers, params.requestBody, undefined, option);
    }
    /**
     * Revoke role from an archive
     * Removes a role from an archive. ([Roles API](https://docs.datadoghq.com/api/v2/roles/))
     * operationId: RemoveRoleFromArchive
     * Request URI: /api/v2/logs/config/archives/{archive_id}/readers
     */
    public async RemoveRoleFromArchive(params: Params$RemoveRoleFromArchive, option?: RequestOption): Promise<void> {
        const url = this.baseUrl + `/api/v2/logs/config/archives/${params.parameter.archive_id}/readers`;
        const headers = {
            "Content-Type": "application/json"
        };
        return this.apiClient.request("DELETE", url, headers, params.requestBody, undefined, option);
    }
    /**
     * Get all log-based metrics
     * Get the list of configured log-based metrics with their definitions.
     * operationId: ListLogsMetrics
     * Request URI: /api/v2/logs/config/metrics
     */
    public async ListLogsMetrics(option?: RequestOption): Promise<Response$ListLogsMetrics$Status$200["application/json"]> {
        const url = this.baseUrl + `/api/v2/logs/config/metrics`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request("GET", url, headers, undefined, undefined, option);
    }
    /**
     * Create a log-based metric
     * Create a metric based on your ingested logs in your organization.
     * Returns the log-based metric object from the request body when the request is successful.
     * operationId: CreateLogsMetric
     * Request URI: /api/v2/logs/config/metrics
     */
    public async CreateLogsMetric(params: Params$CreateLogsMetric, option?: RequestOption): Promise<Response$CreateLogsMetric$Status$200["application/json"]> {
        const url = this.baseUrl + `/api/v2/logs/config/metrics`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request("POST", url, headers, params.requestBody, undefined, option);
    }
    /**
     * Get a log-based metric
     * Get a specific log-based metric from your organization.
     * operationId: GetLogsMetric
     * Request URI: /api/v2/logs/config/metrics/{metric_id}
     */
    public async GetLogsMetric(params: Params$GetLogsMetric, option?: RequestOption): Promise<Response$GetLogsMetric$Status$200["application/json"]> {
        const url = this.baseUrl + `/api/v2/logs/config/metrics/${params.parameter.metric_id}`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request("GET", url, headers, undefined, undefined, option);
    }
    /**
     * Delete a log-based metric
     * Delete a specific log-based metric from your organization.
     * operationId: DeleteLogsMetric
     * Request URI: /api/v2/logs/config/metrics/{metric_id}
     */
    public async DeleteLogsMetric(params: Params$DeleteLogsMetric, option?: RequestOption): Promise<void> {
        const url = this.baseUrl + `/api/v2/logs/config/metrics/${params.parameter.metric_id}`;
        const headers = {};
        return this.apiClient.request("DELETE", url, headers, undefined, undefined, option);
    }
    /**
     * Update a log-based metric
     * Update a specific log-based metric from your organization.
     * Returns the log-based metric object from the request body when the request is successful.
     * operationId: UpdateLogsMetric
     * Request URI: /api/v2/logs/config/metrics/{metric_id}
     */
    public async UpdateLogsMetric(params: Params$UpdateLogsMetric, option?: RequestOption): Promise<Response$UpdateLogsMetric$Status$200["application/json"]> {
        const url = this.baseUrl + `/api/v2/logs/config/metrics/${params.parameter.metric_id}`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request("PATCH", url, headers, params.requestBody, undefined, option);
    }
    /**
     * Get a list of logs
     * List endpoint returns logs that match a log search query.
     * [Results are paginated][1].
     *
     * Use this endpoint to see your latest logs.
     *
     * **If you are considering archiving logs for your organization,
     * consider use of the Datadog archive capabilities instead of the log list API.
     * See [Datadog Logs Archive documentation][2].**
     *
     * [1]: /logs/guide/collect-multiple-logs-with-pagination
     * [2]: https://docs.datadoghq.com/logs/archives
     * operationId: ListLogsGet
     * Request URI: /api/v2/logs/events
     */
    public async ListLogsGet(params: Params$ListLogsGet, option?: RequestOption): Promise<Response$ListLogsGet$Status$200["application/json"]> {
        const url = this.baseUrl + `/api/v2/logs/events`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            "filter[query]": { value: params.parameter["filter[query]"], explode: false },
            "filter[index]": { value: params.parameter["filter[index]"], explode: false },
            "filter[from]": { value: params.parameter["filter[from]"], explode: false },
            "filter[to]": { value: params.parameter["filter[to]"], explode: false },
            sort: { value: params.parameter.sort, explode: false },
            "page[cursor]": { value: params.parameter["page[cursor]"], explode: false },
            "page[limit]": { value: params.parameter["page[limit]"], explode: false }
        };
        return this.apiClient.request("GET", url, headers, undefined, queryParameters, option);
    }
    /**
     * Search logs
     * List endpoint returns logs that match a log search query.
     * [Results are paginated][1].
     *
     * Use this endpoint to build complex logs filtering and search.
     *
     * **If you are considering archiving logs for your organization,
     * consider use of the Datadog archive capabilities instead of the log list API.
     * See [Datadog Logs Archive documentation][2].**
     *
     * [1]: /logs/guide/collect-multiple-logs-with-pagination
     * [2]: https://docs.datadoghq.com/logs/archives
     * operationId: ListLogs
     * Request URI: /api/v2/logs/events/search
     */
    public async ListLogs(params: Params$ListLogs, option?: RequestOption): Promise<Response$ListLogs$Status$200["application/json"]> {
        const url = this.baseUrl + `/api/v2/logs/events/search`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request("POST", url, headers, params.requestBody, undefined, option);
    }
    /**
     * List tag configurations
     * Returns all configured count/gauge/rate/distribution metric names
     * (with additional filters if specified).
     * operationId: ListTagConfigurations
     * Request URI: /api/v2/metrics
     */
    public async ListTagConfigurations(params: Params$ListTagConfigurations, option?: RequestOption): Promise<Response$ListTagConfigurations$Status$200["application/json"]> {
        const url = this.baseUrl + `/api/v2/metrics`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            "filter[configured]": { value: params.parameter["filter[configured]"], explode: false },
            "filter[tags_configured]": { value: params.parameter["filter[tags_configured]"], explode: false },
            "filter[metric_type]": { value: params.parameter["filter[metric_type]"], explode: false },
            "filter[include_percentiles]": { value: params.parameter["filter[include_percentiles]"], explode: false },
            "filter[tags]": { value: params.parameter["filter[tags]"], explode: false },
            "window[seconds]": { value: params.parameter["window[seconds]"], explode: false }
        };
        return this.apiClient.request("GET", url, headers, undefined, queryParameters, option);
    }
    /**
     * Configure tags for multiple metrics
     * Create and define a list of queryable tag keys for a set of existing count, gauge, rate, and distribution metrics.
     * Metrics are selected by passing a metric name prefix. Use the Delete method of this API path to remove tag configurations.
     * Results can be sent to a set of account email addresses, just like the same operation in the Datadog web app.
     * If multiple calls include the same metric, the last configuration applied (not by submit order) is used, do not
     * expect deterministic ordering of concurrent calls.
     * Can only be used with application keys of users with the `Manage Tags for Metrics` permission.
     * operationId: CreateBulkTagsMetricsConfiguration
     * Request URI: /api/v2/metrics/config/bulk-tags
     */
    public async CreateBulkTagsMetricsConfiguration(params: Params$CreateBulkTagsMetricsConfiguration, option?: RequestOption): Promise<Response$CreateBulkTagsMetricsConfiguration$Status$202["application/json"]> {
        const url = this.baseUrl + `/api/v2/metrics/config/bulk-tags`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request("POST", url, headers, params.requestBody, undefined, option);
    }
    /**
     * Configure tags for multiple metrics
     * Delete all custom lists of queryable tag keys for a set of existing count, gauge, rate, and distribution metrics.
     * Metrics are selected by passing a metric name prefix.
     * Results can be sent to a set of account email addresses, just like the same operation in the Datadog web app.
     * Can only be used with application keys of users with the `Manage Tags for Metrics` permission.
     * operationId: DeleteBulkTagsMetricsConfiguration
     * Request URI: /api/v2/metrics/config/bulk-tags
     */
    public async DeleteBulkTagsMetricsConfiguration(params: Params$DeleteBulkTagsMetricsConfiguration, option?: RequestOption): Promise<Response$DeleteBulkTagsMetricsConfiguration$Status$202["application/json"]> {
        const url = this.baseUrl + `/api/v2/metrics/config/bulk-tags`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request("DELETE", url, headers, params.requestBody, undefined, option);
    }
    /**
     * List tags by metric name
     * View indexed tag key-value pairs for a given metric name.
     * operationId: ListTagsByMetricName
     * Request URI: /api/v2/metrics/{metric_name}/all-tags
     */
    public async ListTagsByMetricName(params: Params$ListTagsByMetricName, option?: RequestOption): Promise<Response$ListTagsByMetricName$Status$200["application/json"]> {
        const url = this.baseUrl + `/api/v2/metrics/${params.parameter.metric_name}/all-tags`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request("GET", url, headers, undefined, undefined, option);
    }
    /**
     * List tag configuration by name
     * Returns the tag configuration for the given metric name.
     * operationId: ListTagConfigurationByName
     * Request URI: /api/v2/metrics/{metric_name}/tags
     */
    public async ListTagConfigurationByName(params: Params$ListTagConfigurationByName, option?: RequestOption): Promise<Response$ListTagConfigurationByName$Status$200["application/json"]> {
        const url = this.baseUrl + `/api/v2/metrics/${params.parameter.metric_name}/tags`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request("GET", url, headers, undefined, undefined, option);
    }
    /**
     * Create a tag configuration
     * Create and define a list of queryable tag keys for an existing count/gauge/rate/distribution metric.
     * Optionally, include percentile aggregations on any distribution metric or configure custom aggregations
     * on any count, rate, or gauge metric.
     * Can only be used with application keys of users with the `Manage Tags for Metrics` permission.
     * operationId: CreateTagConfiguration
     * Request URI: /api/v2/metrics/{metric_name}/tags
     */
    public async CreateTagConfiguration(params: Params$CreateTagConfiguration, option?: RequestOption): Promise<Response$CreateTagConfiguration$Status$201["application/json"]> {
        const url = this.baseUrl + `/api/v2/metrics/${params.parameter.metric_name}/tags`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request("POST", url, headers, params.requestBody, undefined, option);
    }
    /**
     * Delete a tag configuration
     * Deletes a metric's tag configuration. Can only be used with application
     * keys from users with the `Manage Tags for Metrics` permission.
     * operationId: DeleteTagConfiguration
     * Request URI: /api/v2/metrics/{metric_name}/tags
     */
    public async DeleteTagConfiguration(params: Params$DeleteTagConfiguration, option?: RequestOption): Promise<void> {
        const url = this.baseUrl + `/api/v2/metrics/${params.parameter.metric_name}/tags`;
        const headers = {};
        return this.apiClient.request("DELETE", url, headers, undefined, undefined, option);
    }
    /**
     * Update a tag configuration
     * Update the tag configuration of a metric or percentile aggregations of a distribution metric or custom aggregations
     * of a count, rate, or gauge metric.
     * Can only be used with application keys from users with the `Manage Tags for Metrics` permission.
     * operationId: UpdateTagConfiguration
     * Request URI: /api/v2/metrics/{metric_name}/tags
     */
    public async UpdateTagConfiguration(params: Params$UpdateTagConfiguration, option?: RequestOption): Promise<Response$UpdateTagConfiguration$Status$200["application/json"]> {
        const url = this.baseUrl + `/api/v2/metrics/${params.parameter.metric_name}/tags`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request("PATCH", url, headers, params.requestBody, undefined, option);
    }
    /**
     * List distinct metric volumes by metric name
     * View distinct metrics volumes for the given metric name.
     *
     * Custom distribution metrics will return both ingested and indexed custom metric volumes.
     * For Metrics without Limits&trade; beta customers, all metrics will return both ingested/indexed volumes.
     * Custom metrics generated in-app from other products will return `null` for ingested volumes.
     * operationId: ListVolumesByMetricName
     * Request URI: /api/v2/metrics/{metric_name}/volumes
     */
    public async ListVolumesByMetricName(params: Params$ListVolumesByMetricName, option?: RequestOption): Promise<Response$ListVolumesByMetricName$Status$200["application/json"]> {
        const url = this.baseUrl + `/api/v2/metrics/${params.parameter.metric_name}/volumes`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request("GET", url, headers, undefined, undefined, option);
    }
    /**
     * List permissions
     * Returns a list of all permissions, including name, description, and ID.
     * operationId: ListPermissions
     * Request URI: /api/v2/permissions
     */
    public async ListPermissions(option?: RequestOption): Promise<Response$ListPermissions$Status$200["application/json"]> {
        const url = this.baseUrl + `/api/v2/permissions`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request("GET", url, headers, undefined, undefined, option);
    }
    /**
     * Get all processes
     * Get all processes for your organization.
     * operationId: ListProcesses
     * Request URI: /api/v2/processes
     */
    public async ListProcesses(params: Params$ListProcesses, option?: RequestOption): Promise<Response$ListProcesses$Status$200["application/json"]> {
        const url = this.baseUrl + `/api/v2/processes`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            search: { value: params.parameter.search, explode: false },
            tags: { value: params.parameter.tags, explode: false },
            from: { value: params.parameter.from, explode: false },
            to: { value: params.parameter.to, explode: false },
            "page[limit]": { value: params.parameter["page[limit]"], explode: false },
            "page[cursor]": { value: params.parameter["page[cursor]"], explode: false }
        };
        return this.apiClient.request("GET", url, headers, undefined, queryParameters, option);
    }
    /**
     * List roles
     * Returns all roles, including their names and IDs.
     * operationId: ListRoles
     * Request URI: /api/v2/roles
     */
    public async ListRoles(params: Params$ListRoles, option?: RequestOption): Promise<Response$ListRoles$Status$200["application/json"]> {
        const url = this.baseUrl + `/api/v2/roles`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            "page[size]": { value: params.parameter["page[size]"], explode: false },
            "page[number]": { value: params.parameter["page[number]"], explode: false },
            sort: { value: params.parameter.sort, explode: false },
            filter: { value: params.parameter.filter, explode: false }
        };
        return this.apiClient.request("GET", url, headers, undefined, queryParameters, option);
    }
    /**
     * Create role
     * Create a new role for your organization.
     * operationId: CreateRole
     * Request URI: /api/v2/roles
     */
    public async CreateRole(params: Params$CreateRole, option?: RequestOption): Promise<Response$CreateRole$Status$200["application/json"]> {
        const url = this.baseUrl + `/api/v2/roles`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request("POST", url, headers, params.requestBody, undefined, option);
    }
    /**
     * Get a role
     * Get a role in the organization specified by the roles `role_id`.
     * operationId: GetRole
     * Request URI: /api/v2/roles/{role_id}
     */
    public async GetRole(params: Params$GetRole, option?: RequestOption): Promise<Response$GetRole$Status$200["application/json"]> {
        const url = this.baseUrl + `/api/v2/roles/${params.parameter.role_id}`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request("GET", url, headers, undefined, undefined, option);
    }
    /**
     * Delete role
     * Disables a role.
     * operationId: DeleteRole
     * Request URI: /api/v2/roles/{role_id}
     */
    public async DeleteRole(params: Params$DeleteRole, option?: RequestOption): Promise<void> {
        const url = this.baseUrl + `/api/v2/roles/${params.parameter.role_id}`;
        const headers = {};
        return this.apiClient.request("DELETE", url, headers, undefined, undefined, option);
    }
    /**
     * Update a role
     * Edit a role. Can only be used with application keys belonging to administrators.
     * operationId: UpdateRole
     * Request URI: /api/v2/roles/{role_id}
     */
    public async UpdateRole(params: Params$UpdateRole, option?: RequestOption): Promise<Response$UpdateRole$Status$200["application/json"]> {
        const url = this.baseUrl + `/api/v2/roles/${params.parameter.role_id}`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request("PATCH", url, headers, params.requestBody, undefined, option);
    }
    /**
     * Create a new role by cloning an existing role
     * Clone an existing role
     * operationId: CloneRole
     * Request URI: /api/v2/roles/{role_id}/clone
     */
    public async CloneRole(params: Params$CloneRole, option?: RequestOption): Promise<Response$CloneRole$Status$200["application/json"]> {
        const url = this.baseUrl + `/api/v2/roles/${params.parameter.role_id}/clone`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request("POST", url, headers, params.requestBody, undefined, option);
    }
    /**
     * List permissions for a role
     * Returns a list of all permissions for a single role.
     * operationId: ListRolePermissions
     * Request URI: /api/v2/roles/{role_id}/permissions
     */
    public async ListRolePermissions(params: Params$ListRolePermissions, option?: RequestOption): Promise<Response$ListRolePermissions$Status$200["application/json"]> {
        const url = this.baseUrl + `/api/v2/roles/${params.parameter.role_id}/permissions`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request("GET", url, headers, undefined, undefined, option);
    }
    /**
     * Grant permission to a role
     * Adds a permission to a role.
     * operationId: AddPermissionToRole
     * Request URI: /api/v2/roles/{role_id}/permissions
     */
    public async AddPermissionToRole(params: Params$AddPermissionToRole, option?: RequestOption): Promise<Response$AddPermissionToRole$Status$200["application/json"]> {
        const url = this.baseUrl + `/api/v2/roles/${params.parameter.role_id}/permissions`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request("POST", url, headers, params.requestBody, undefined, option);
    }
    /**
     * Revoke permission
     * Removes a permission from a role.
     * operationId: RemovePermissionFromRole
     * Request URI: /api/v2/roles/{role_id}/permissions
     */
    public async RemovePermissionFromRole(params: Params$RemovePermissionFromRole, option?: RequestOption): Promise<Response$RemovePermissionFromRole$Status$200["application/json"]> {
        const url = this.baseUrl + `/api/v2/roles/${params.parameter.role_id}/permissions`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request("DELETE", url, headers, params.requestBody, undefined, option);
    }
    /**
     * Get all users of a role
     * Gets all users of a role.
     * operationId: ListRoleUsers
     * Request URI: /api/v2/roles/{role_id}/users
     */
    public async ListRoleUsers(params: Params$ListRoleUsers, option?: RequestOption): Promise<Response$ListRoleUsers$Status$200["application/json"]> {
        const url = this.baseUrl + `/api/v2/roles/${params.parameter.role_id}/users`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            "page[size]": { value: params.parameter["page[size]"], explode: false },
            "page[number]": { value: params.parameter["page[number]"], explode: false },
            sort: { value: params.parameter.sort, explode: false },
            filter: { value: params.parameter.filter, explode: false }
        };
        return this.apiClient.request("GET", url, headers, undefined, queryParameters, option);
    }
    /**
     * Add a user to a role
     * Adds a user to a role.
     * operationId: AddUserToRole
     * Request URI: /api/v2/roles/{role_id}/users
     */
    public async AddUserToRole(params: Params$AddUserToRole, option?: RequestOption): Promise<Response$AddUserToRole$Status$200["application/json"]> {
        const url = this.baseUrl + `/api/v2/roles/${params.parameter.role_id}/users`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request("POST", url, headers, params.requestBody, undefined, option);
    }
    /**
     * Remove a user from a role
     * Removes a user from a role.
     * operationId: RemoveUserFromRole
     * Request URI: /api/v2/roles/{role_id}/users
     */
    public async RemoveUserFromRole(params: Params$RemoveUserFromRole, option?: RequestOption): Promise<Response$RemoveUserFromRole$Status$200["application/json"]> {
        const url = this.baseUrl + `/api/v2/roles/${params.parameter.role_id}/users`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request("DELETE", url, headers, params.requestBody, undefined, option);
    }
    /**
     * Get the latest Cloud Workload Security policy
     * The download endpoint generates a Cloud Workload Security policy file from your currently active
     * Cloud Workload Security rules, and downloads them as a .policy file. This file can then be deployed to
     * your agents to update the policy running in your environment.
     * operationId: DownloadCloudWorkloadPolicyFile
     * Request URI: /api/v2/security/cloud_workload/policy/download
     */
    public async DownloadCloudWorkloadPolicyFile(option?: RequestOption): Promise<Response$DownloadCloudWorkloadPolicyFile$Status$200["application/yaml"]> {
        const url = this.baseUrl + `/api/v2/security/cloud_workload/policy/download`;
        const headers = {
            Accept: "application/yaml"
        };
        return this.apiClient.request("GET", url, headers, undefined, undefined, option);
    }
    /**
     * Get all Cloud Workload Security Agent rules
     * Get the list of Agent rules.
     * operationId: ListCloudWorkloadSecurityAgentRules
     * Request URI: /api/v2/security_monitoring/cloud_workload_security/agent_rules
     */
    public async ListCloudWorkloadSecurityAgentRules(option?: RequestOption): Promise<Response$ListCloudWorkloadSecurityAgentRules$Status$200["application/json"]> {
        const url = this.baseUrl + `/api/v2/security_monitoring/cloud_workload_security/agent_rules`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request("GET", url, headers, undefined, undefined, option);
    }
    /**
     * Create a Cloud Workload Security Agent rule
     * Create a new Agent rule with the given parameters.
     * operationId: CreateCloudWorkloadSecurityAgentRule
     * Request URI: /api/v2/security_monitoring/cloud_workload_security/agent_rules
     */
    public async CreateCloudWorkloadSecurityAgentRule(params: Params$CreateCloudWorkloadSecurityAgentRule, option?: RequestOption): Promise<Response$CreateCloudWorkloadSecurityAgentRule$Status$200["application/json"]> {
        const url = this.baseUrl + `/api/v2/security_monitoring/cloud_workload_security/agent_rules`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request("POST", url, headers, params.requestBody, undefined, option);
    }
    /**
     * Get a Cloud Workload Security Agent rule
     * Get the details of a specific Agent rule.
     * operationId: GetCloudWorkloadSecurityAgentRule
     * Request URI: /api/v2/security_monitoring/cloud_workload_security/agent_rules/{agent_rule_id}
     */
    public async GetCloudWorkloadSecurityAgentRule(params: Params$GetCloudWorkloadSecurityAgentRule, option?: RequestOption): Promise<Response$GetCloudWorkloadSecurityAgentRule$Status$200["application/json"]> {
        const url = this.baseUrl + `/api/v2/security_monitoring/cloud_workload_security/agent_rules/${params.parameter.agent_rule_id}`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request("GET", url, headers, undefined, undefined, option);
    }
    /**
     * Delete a Cloud Workload Security Agent rule
     * Delete a specific Agent rule.
     * operationId: DeleteCloudWorkloadSecurityAgentRule
     * Request URI: /api/v2/security_monitoring/cloud_workload_security/agent_rules/{agent_rule_id}
     */
    public async DeleteCloudWorkloadSecurityAgentRule(params: Params$DeleteCloudWorkloadSecurityAgentRule, option?: RequestOption): Promise<void> {
        const url = this.baseUrl + `/api/v2/security_monitoring/cloud_workload_security/agent_rules/${params.parameter.agent_rule_id}`;
        const headers = {};
        return this.apiClient.request("DELETE", url, headers, undefined, undefined, option);
    }
    /**
     * Update a Cloud Workload Security Agent rule
     * Update a specific Agent rule.
     * Returns the Agent rule object when the request is successful.
     * operationId: UpdateCloudWorkloadSecurityAgentRule
     * Request URI: /api/v2/security_monitoring/cloud_workload_security/agent_rules/{agent_rule_id}
     */
    public async UpdateCloudWorkloadSecurityAgentRule(params: Params$UpdateCloudWorkloadSecurityAgentRule, option?: RequestOption): Promise<Response$UpdateCloudWorkloadSecurityAgentRule$Status$200["application/json"]> {
        const url = this.baseUrl + `/api/v2/security_monitoring/cloud_workload_security/agent_rules/${params.parameter.agent_rule_id}`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request("PATCH", url, headers, params.requestBody, undefined, option);
    }
    /**
     * Get all security filters
     * Get the list of configured security filters with their definitions.
     * operationId: ListSecurityFilters
     * Request URI: /api/v2/security_monitoring/configuration/security_filters
     */
    public async ListSecurityFilters(option?: RequestOption): Promise<Response$ListSecurityFilters$Status$200["application/json"]> {
        const url = this.baseUrl + `/api/v2/security_monitoring/configuration/security_filters`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request("GET", url, headers, undefined, undefined, option);
    }
    /**
     * Create a security filter
     * Create a security filter.
     *
     * See the [security filter guide](https://docs.datadoghq.com/security_platform/guide/how-to-setup-security-filters-using-security-monitoring-api/)
     * for more examples.
     * operationId: CreateSecurityFilter
     * Request URI: /api/v2/security_monitoring/configuration/security_filters
     */
    public async CreateSecurityFilter(params: Params$CreateSecurityFilter, option?: RequestOption): Promise<Response$CreateSecurityFilter$Status$200["application/json"]> {
        const url = this.baseUrl + `/api/v2/security_monitoring/configuration/security_filters`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request("POST", url, headers, params.requestBody, undefined, option);
    }
    /**
     * Get a security filter
     * Get the details of a specific security filter.
     *
     * See the [security filter guide](https://docs.datadoghq.com/security_platform/guide/how-to-setup-security-filters-using-security-monitoring-api/)
     * for more examples.
     * operationId: GetSecurityFilter
     * Request URI: /api/v2/security_monitoring/configuration/security_filters/{security_filter_id}
     */
    public async GetSecurityFilter(params: Params$GetSecurityFilter, option?: RequestOption): Promise<Response$GetSecurityFilter$Status$200["application/json"]> {
        const url = this.baseUrl + `/api/v2/security_monitoring/configuration/security_filters/${params.parameter.security_filter_id}`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request("GET", url, headers, undefined, undefined, option);
    }
    /**
     * Delete a security filter
     * Delete a specific security filter.
     * operationId: DeleteSecurityFilter
     * Request URI: /api/v2/security_monitoring/configuration/security_filters/{security_filter_id}
     */
    public async DeleteSecurityFilter(params: Params$DeleteSecurityFilter, option?: RequestOption): Promise<void> {
        const url = this.baseUrl + `/api/v2/security_monitoring/configuration/security_filters/${params.parameter.security_filter_id}`;
        const headers = {};
        return this.apiClient.request("DELETE", url, headers, undefined, undefined, option);
    }
    /**
     * Update a security filter
     * Update a specific security filter.
     * Returns the security filter object when the request is successful.
     * operationId: UpdateSecurityFilter
     * Request URI: /api/v2/security_monitoring/configuration/security_filters/{security_filter_id}
     */
    public async UpdateSecurityFilter(params: Params$UpdateSecurityFilter, option?: RequestOption): Promise<Response$UpdateSecurityFilter$Status$200["application/json"]> {
        const url = this.baseUrl + `/api/v2/security_monitoring/configuration/security_filters/${params.parameter.security_filter_id}`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request("PATCH", url, headers, params.requestBody, undefined, option);
    }
    /**
     * List rules
     * List rules.
     * operationId: ListSecurityMonitoringRules
     * Request URI: /api/v2/security_monitoring/rules
     */
    public async ListSecurityMonitoringRules(params: Params$ListSecurityMonitoringRules, option?: RequestOption): Promise<Response$ListSecurityMonitoringRules$Status$200["application/json"]> {
        const url = this.baseUrl + `/api/v2/security_monitoring/rules`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            "page[size]": { value: params.parameter["page[size]"], explode: false },
            "page[number]": { value: params.parameter["page[number]"], explode: false }
        };
        return this.apiClient.request("GET", url, headers, undefined, queryParameters, option);
    }
    /**
     * Create a detection rule
     * Create a detection rule.
     * operationId: CreateSecurityMonitoringRule
     * Request URI: /api/v2/security_monitoring/rules
     */
    public async CreateSecurityMonitoringRule(params: Params$CreateSecurityMonitoringRule, option?: RequestOption): Promise<Response$CreateSecurityMonitoringRule$Status$200["application/json"]> {
        const url = this.baseUrl + `/api/v2/security_monitoring/rules`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request("POST", url, headers, params.requestBody, undefined, option);
    }
    /**
     * Get a rule's details
     * Get a rule's details.
     * operationId: GetSecurityMonitoringRule
     * Request URI: /api/v2/security_monitoring/rules/{rule_id}
     */
    public async GetSecurityMonitoringRule(params: Params$GetSecurityMonitoringRule, option?: RequestOption): Promise<Response$GetSecurityMonitoringRule$Status$200["application/json"]> {
        const url = this.baseUrl + `/api/v2/security_monitoring/rules/${params.parameter.rule_id}`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request("GET", url, headers, undefined, undefined, option);
    }
    /**
     * Update an existing rule
     * Update an existing rule. When updating `cases`, `queries` or `options`, the whole field
     * must be included. For example, when modifying a query all queries must be included.
     * Default rules can only be updated to be enabled and to change notifications.
     * operationId: UpdateSecurityMonitoringRule
     * Request URI: /api/v2/security_monitoring/rules/{rule_id}
     */
    public async UpdateSecurityMonitoringRule(params: Params$UpdateSecurityMonitoringRule, option?: RequestOption): Promise<Response$UpdateSecurityMonitoringRule$Status$200["application/json"]> {
        const url = this.baseUrl + `/api/v2/security_monitoring/rules/${params.parameter.rule_id}`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request("PUT", url, headers, params.requestBody, undefined, option);
    }
    /**
     * Delete an existing rule
     * Delete an existing rule. Default rules cannot be deleted.
     * operationId: DeleteSecurityMonitoringRule
     * Request URI: /api/v2/security_monitoring/rules/{rule_id}
     */
    public async DeleteSecurityMonitoringRule(params: Params$DeleteSecurityMonitoringRule, option?: RequestOption): Promise<void> {
        const url = this.baseUrl + `/api/v2/security_monitoring/rules/${params.parameter.rule_id}`;
        const headers = {};
        return this.apiClient.request("DELETE", url, headers, undefined, undefined, option);
    }
    /**
     * Get a quick list of security signals
     * The list endpoint returns security signals that match a search query.
     * Both this endpoint and the POST endpoint can be used interchangeably when listing
     * security signals.
     * operationId: ListSecurityMonitoringSignals
     * Request URI: /api/v2/security_monitoring/signals
     */
    public async ListSecurityMonitoringSignals(params: Params$ListSecurityMonitoringSignals, option?: RequestOption): Promise<Response$ListSecurityMonitoringSignals$Status$200["application/json"]> {
        const url = this.baseUrl + `/api/v2/security_monitoring/signals`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            "filter[query]": { value: params.parameter["filter[query]"], explode: false },
            "filter[from]": { value: params.parameter["filter[from]"], explode: false },
            "filter[to]": { value: params.parameter["filter[to]"], explode: false },
            sort: { value: params.parameter.sort, explode: false },
            "page[cursor]": { value: params.parameter["page[cursor]"], explode: false },
            "page[limit]": { value: params.parameter["page[limit]"], explode: false }
        };
        return this.apiClient.request("GET", url, headers, undefined, queryParameters, option);
    }
    /**
     * Get a list of security signals
     * Returns security signals that match a search query.
     * Both this endpoint and the GET endpoint can be used interchangeably for listing
     * security signals.
     * operationId: SearchSecurityMonitoringSignals
     * Request URI: /api/v2/security_monitoring/signals/search
     */
    public async SearchSecurityMonitoringSignals(params: Params$SearchSecurityMonitoringSignals, option?: RequestOption): Promise<Response$SearchSecurityMonitoringSignals$Status$200["application/json"]> {
        const url = this.baseUrl + `/api/v2/security_monitoring/signals/search`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request("POST", url, headers, params.requestBody, undefined, option);
    }
    /**
     * Create a service account
     * Create a service account for your organization.
     * operationId: CreateServiceAccount
     * Request URI: /api/v2/service_accounts
     */
    public async CreateServiceAccount(params: Params$CreateServiceAccount, option?: RequestOption): Promise<Response$CreateServiceAccount$Status$201["application/json"]> {
        const url = this.baseUrl + `/api/v2/service_accounts`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request("POST", url, headers, params.requestBody, undefined, option);
    }
    /**
     * List application keys for this service account
     * List all application keys available for this service account.
     * operationId: ListServiceAccountApplicationKeys
     * Request URI: /api/v2/service_accounts/{service_account_id}/application_keys
     */
    public async ListServiceAccountApplicationKeys(params: Params$ListServiceAccountApplicationKeys, option?: RequestOption): Promise<Response$ListServiceAccountApplicationKeys$Status$200["application/json"]> {
        const url = this.baseUrl + `/api/v2/service_accounts/${params.parameter.service_account_id}/application_keys`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            "page[size]": { value: params.parameter["page[size]"], explode: false },
            "page[number]": { value: params.parameter["page[number]"], explode: false },
            sort: { value: params.parameter.sort, explode: false },
            filter: { value: params.parameter.filter, explode: false },
            "filter[created_at][start]": { value: params.parameter["filter[created_at][start]"], explode: false },
            "filter[created_at][end]": { value: params.parameter["filter[created_at][end]"], explode: false }
        };
        return this.apiClient.request("GET", url, headers, undefined, queryParameters, option);
    }
    /**
     * Create an application key for this service account
     * Create an application key for this service account.
     * operationId: CreateServiceAccountApplicationKey
     * Request URI: /api/v2/service_accounts/{service_account_id}/application_keys
     */
    public async CreateServiceAccountApplicationKey(params: Params$CreateServiceAccountApplicationKey, option?: RequestOption): Promise<Response$CreateServiceAccountApplicationKey$Status$201["application/json"]> {
        const url = this.baseUrl + `/api/v2/service_accounts/${params.parameter.service_account_id}/application_keys`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request("POST", url, headers, params.requestBody, undefined, option);
    }
    /**
     * Get one application key for this service account
     * Get an application key owned by this service account.
     * operationId: GetServiceAccountApplicationKey
     * Request URI: /api/v2/service_accounts/{service_account_id}/application_keys/{app_key_id}
     */
    public async GetServiceAccountApplicationKey(params: Params$GetServiceAccountApplicationKey, option?: RequestOption): Promise<Response$GetServiceAccountApplicationKey$Status$200["application/json"]> {
        const url = this.baseUrl + `/api/v2/service_accounts/${params.parameter.service_account_id}/application_keys/${params.parameter.app_key_id}`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request("GET", url, headers, undefined, undefined, option);
    }
    /**
     * Delete an application key for this service account
     * Delete an application key owned by this service account.
     * operationId: DeleteServiceAccountApplicationKey
     * Request URI: /api/v2/service_accounts/{service_account_id}/application_keys/{app_key_id}
     */
    public async DeleteServiceAccountApplicationKey(params: Params$DeleteServiceAccountApplicationKey, option?: RequestOption): Promise<void> {
        const url = this.baseUrl + `/api/v2/service_accounts/${params.parameter.service_account_id}/application_keys/${params.parameter.app_key_id}`;
        const headers = {};
        return this.apiClient.request("DELETE", url, headers, undefined, undefined, option);
    }
    /**
     * Edit an application key for this service account
     * Edit an application key owned by this service account.
     * operationId: UpdateServiceAccountApplicationKey
     * Request URI: /api/v2/service_accounts/{service_account_id}/application_keys/{app_key_id}
     */
    public async UpdateServiceAccountApplicationKey(params: Params$UpdateServiceAccountApplicationKey, option?: RequestOption): Promise<Response$UpdateServiceAccountApplicationKey$Status$200["application/json"]> {
        const url = this.baseUrl + `/api/v2/service_accounts/${params.parameter.service_account_id}/application_keys/${params.parameter.app_key_id}`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request("PATCH", url, headers, params.requestBody, undefined, option);
    }
    /**
     * Get a list of all incident services
     * Get all incident services uploaded for the requesting user's organization. If the `include[users]` query parameter is provided, the included attribute will contain the users related to these incident services.
     * operationId: ListIncidentServices
     * Request URI: /api/v2/services
     */
    public async ListIncidentServices(params: Params$ListIncidentServices, option?: RequestOption): Promise<Response$ListIncidentServices$Status$200["application/json"]> {
        const url = this.baseUrl + `/api/v2/services`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            include: { value: params.parameter.include, explode: false },
            "page[size]": { value: params.parameter["page[size]"], explode: false },
            "page[offset]": { value: params.parameter["page[offset]"], explode: false },
            filter: { value: params.parameter.filter, explode: false }
        };
        return this.apiClient.request("GET", url, headers, undefined, queryParameters, option);
    }
    /**
     * Create a new incident service
     * Creates a new incident service.
     * operationId: CreateIncidentService
     * Request URI: /api/v2/services
     */
    public async CreateIncidentService(params: Params$CreateIncidentService, option?: RequestOption): Promise<Response$CreateIncidentService$Status$201["application/json"]> {
        const url = this.baseUrl + `/api/v2/services`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request("POST", url, headers, params.requestBody, undefined, option);
    }
    /**
     * Get details of an incident service
     * Get details of an incident service. If the `include[users]` query parameter is provided,
     * the included attribute will contain the users related to these incident services.
     * operationId: GetIncidentService
     * Request URI: /api/v2/services/{service_id}
     */
    public async GetIncidentService(params: Params$GetIncidentService, option?: RequestOption): Promise<Response$GetIncidentService$Status$200["application/json"]> {
        const url = this.baseUrl + `/api/v2/services/${params.parameter.service_id}`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            include: { value: params.parameter.include, explode: false }
        };
        return this.apiClient.request("GET", url, headers, undefined, queryParameters, option);
    }
    /**
     * Delete an existing incident service
     * Deletes an existing incident service.
     * operationId: DeleteIncidentService
     * Request URI: /api/v2/services/{service_id}
     */
    public async DeleteIncidentService(params: Params$DeleteIncidentService, option?: RequestOption): Promise<void> {
        const url = this.baseUrl + `/api/v2/services/${params.parameter.service_id}`;
        const headers = {};
        return this.apiClient.request("DELETE", url, headers, undefined, undefined, option);
    }
    /**
     * Update an existing incident service
     * Updates an existing incident service. Only provide the attributes which should be updated as this request is a partial update.
     * operationId: UpdateIncidentService
     * Request URI: /api/v2/services/{service_id}
     */
    public async UpdateIncidentService(params: Params$UpdateIncidentService, option?: RequestOption): Promise<Response$UpdateIncidentService$Status$200["application/json"]> {
        const url = this.baseUrl + `/api/v2/services/${params.parameter.service_id}`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request("PATCH", url, headers, params.requestBody, undefined, option);
    }
    /**
     * Get a list of all incident teams
     * Get all incident teams for the requesting user's organization. If the `include[users]` query parameter is provided, the included attribute will contain the users related to these incident teams.
     * operationId: ListIncidentTeams
     * Request URI: /api/v2/teams
     */
    public async ListIncidentTeams(params: Params$ListIncidentTeams, option?: RequestOption): Promise<Response$ListIncidentTeams$Status$200["application/json"]> {
        const url = this.baseUrl + `/api/v2/teams`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            include: { value: params.parameter.include, explode: false },
            "page[size]": { value: params.parameter["page[size]"], explode: false },
            "page[offset]": { value: params.parameter["page[offset]"], explode: false },
            filter: { value: params.parameter.filter, explode: false }
        };
        return this.apiClient.request("GET", url, headers, undefined, queryParameters, option);
    }
    /**
     * Create a new incident team
     * Creates a new incident team.
     * operationId: CreateIncidentTeam
     * Request URI: /api/v2/teams
     */
    public async CreateIncidentTeam(params: Params$CreateIncidentTeam, option?: RequestOption): Promise<Response$CreateIncidentTeam$Status$201["application/json"]> {
        const url = this.baseUrl + `/api/v2/teams`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request("POST", url, headers, params.requestBody, undefined, option);
    }
    /**
     * Get details of an incident team
     * Get details of an incident team. If the `include[users]` query parameter is provided,
     * the included attribute will contain the users related to these incident teams.
     * operationId: GetIncidentTeam
     * Request URI: /api/v2/teams/{team_id}
     */
    public async GetIncidentTeam(params: Params$GetIncidentTeam, option?: RequestOption): Promise<Response$GetIncidentTeam$Status$200["application/json"]> {
        const url = this.baseUrl + `/api/v2/teams/${params.parameter.team_id}`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            include: { value: params.parameter.include, explode: false }
        };
        return this.apiClient.request("GET", url, headers, undefined, queryParameters, option);
    }
    /**
     * Delete an existing incident team
     * Deletes an existing incident team.
     * operationId: DeleteIncidentTeam
     * Request URI: /api/v2/teams/{team_id}
     */
    public async DeleteIncidentTeam(params: Params$DeleteIncidentTeam, option?: RequestOption): Promise<void> {
        const url = this.baseUrl + `/api/v2/teams/${params.parameter.team_id}`;
        const headers = {};
        return this.apiClient.request("DELETE", url, headers, undefined, undefined, option);
    }
    /**
     * Update an existing incident team
     * Updates an existing incident team. Only provide the attributes which should be updated as this request is a partial update.
     * operationId: UpdateIncidentTeam
     * Request URI: /api/v2/teams/{team_id}
     */
    public async UpdateIncidentTeam(params: Params$UpdateIncidentTeam, option?: RequestOption): Promise<Response$UpdateIncidentTeam$Status$200["application/json"]> {
        const url = this.baseUrl + `/api/v2/teams/${params.parameter.team_id}`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request("PATCH", url, headers, params.requestBody, undefined, option);
    }
    /**
     * Send invitation emails
     * Sends emails to one or more users inviting them to join the organization.
     * operationId: SendInvitations
     * Request URI: /api/v2/user_invitations
     */
    public async SendInvitations(params: Params$SendInvitations, option?: RequestOption): Promise<Response$SendInvitations$Status$201["application/json"]> {
        const url = this.baseUrl + `/api/v2/user_invitations`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request("POST", url, headers, params.requestBody, undefined, option);
    }
    /**
     * Get a user invitation
     * Returns a single user invitation by its UUID.
     * operationId: GetInvitation
     * Request URI: /api/v2/user_invitations/{user_invitation_uuid}
     */
    public async GetInvitation(params: Params$GetInvitation, option?: RequestOption): Promise<Response$GetInvitation$Status$200["application/json"]> {
        const url = this.baseUrl + `/api/v2/user_invitations/${params.parameter.user_invitation_uuid}`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request("GET", url, headers, undefined, undefined, option);
    }
    /**
     * List all users
     * Get the list of all users in the organization. This list includes
     * all users even if they are deactivated or unverified.
     * operationId: ListUsers
     * Request URI: /api/v2/users
     */
    public async ListUsers(params: Params$ListUsers, option?: RequestOption): Promise<Response$ListUsers$Status$200["application/json"]> {
        const url = this.baseUrl + `/api/v2/users`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            "page[size]": { value: params.parameter["page[size]"], explode: false },
            "page[number]": { value: params.parameter["page[number]"], explode: false },
            sort: { value: params.parameter.sort, explode: false },
            sort_dir: { value: params.parameter.sort_dir, explode: false },
            filter: { value: params.parameter.filter, explode: false },
            "filter[status]": { value: params.parameter["filter[status]"], explode: false }
        };
        return this.apiClient.request("GET", url, headers, undefined, queryParameters, option);
    }
    /**
     * Create a user
     * Create a user for your organization.
     * operationId: CreateUser
     * Request URI: /api/v2/users
     */
    public async CreateUser(params: Params$CreateUser, option?: RequestOption): Promise<Response$CreateUser$Status$201["application/json"]> {
        const url = this.baseUrl + `/api/v2/users`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request("POST", url, headers, params.requestBody, undefined, option);
    }
    /**
     * Get user details
     * Get a user in the organization specified by the users `user_id`.
     * operationId: GetUser
     * Request URI: /api/v2/users/{user_id}
     */
    public async GetUser(params: Params$GetUser, option?: RequestOption): Promise<Response$GetUser$Status$200["application/json"]> {
        const url = this.baseUrl + `/api/v2/users/${params.parameter.user_id}`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request("GET", url, headers, undefined, undefined, option);
    }
    /**
     * Disable a user
     * Disable a user. Can only be used with an application key belonging
     * to an administrator user.
     * operationId: DisableUser
     * Request URI: /api/v2/users/{user_id}
     */
    public async DisableUser(params: Params$DisableUser, option?: RequestOption): Promise<void> {
        const url = this.baseUrl + `/api/v2/users/${params.parameter.user_id}`;
        const headers = {};
        return this.apiClient.request("DELETE", url, headers, undefined, undefined, option);
    }
    /**
     * Update a user
     * Edit a user. Can only be used with an application key belonging
     * to an administrator user.
     * operationId: UpdateUser
     * Request URI: /api/v2/users/{user_id}
     */
    public async UpdateUser(params: Params$UpdateUser, option?: RequestOption): Promise<Response$UpdateUser$Status$200["application/json"]> {
        const url = this.baseUrl + `/api/v2/users/${params.parameter.user_id}`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request("PATCH", url, headers, params.requestBody, undefined, option);
    }
    /**
     * Get a user organization
     * Get a user organization. Returns the user information and all organizations
     * joined by this user.
     * operationId: ListUserOrganizations
     * Request URI: /api/v2/users/{user_id}/orgs
     */
    public async ListUserOrganizations(params: Params$ListUserOrganizations, option?: RequestOption): Promise<Response$ListUserOrganizations$Status$200["application/json"]> {
        const url = this.baseUrl + `/api/v2/users/${params.parameter.user_id}/orgs`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request("GET", url, headers, undefined, undefined, option);
    }
    /**
     * Get a user permissions
     * Get a user permission set. Returns a list of the users permissions
     * granted by the associated user's roles.
     * operationId: ListUserPermissions
     * Request URI: /api/v2/users/{user_id}/permissions
     */
    public async ListUserPermissions(params: Params$ListUserPermissions, option?: RequestOption): Promise<Response$ListUserPermissions$Status$200["application/json"]> {
        const url = this.baseUrl + `/api/v2/users/${params.parameter.user_id}/permissions`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request("GET", url, headers, undefined, undefined, option);
    }
}
